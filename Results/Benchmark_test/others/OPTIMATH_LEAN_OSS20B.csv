Query,model_output,code_output,objective_value,en_answer,Count,,,,,,,,
"The manufacturing facility produces custom components for two jobs, Job 0 and Job 1, each consisting of a sequence of operations that must be performed in a specific order. The goal is to schedule these operations to minimize the total completion time (makespan) while satisfying all operational constraints. Job 0 has five operations with processing times: Operation 0 takes 4 units, Operation 1 takes 1 unit, Operation 2 takes 6 units, Operation 3 takes 6 units, and Operation 4 takes 8 units. Job 1 has four operations with processing times: Operation 0 takes 9 units, Operation 1 takes 1 unit, Operation 2 takes 4 units, and Operation 3 takes 2 units.

Precedence constraints ensure that operations within each job are performed in sequence with specific gaps. For Job 0, Operation 1 must start at least 4 units after Operation 0 starts, Operation 2 must start at least 1 unit after Operation 1 starts, Operation 3 must start at least 6 units after Operation 2 starts, and Operation 4 must start at least 6 units after Operation 3 starts. For Job 1, Operation 1 must start at least 9 units after Operation 0 starts, Operation 2 must start at least 1 unit after Operation 1 starts, and Operation 3 must start at least 4 units after Operation 2 starts.

Machine capacity constraints ensure that operations assigned to the same machine do not overlap. Binary variables determine the order of operations on shared machines. For example, if Operation 1 of Job 0 and Operation 3 of Job 0 are on the same machine, one must complete at least 6 units before the other starts. Similarly, if Operation 1 of Job 0 and Operation 2 of Job 1 are on the same machine, one must complete at least 4 units before the other starts. These constraints apply to all operation pairs on shared machines, ensuring no overlap and maintaining required time gaps. The large constant of 100,000 is used in these constraints to enforce the sequencing logic by ensuring that the constraints are only active when the binary variable is set to 1.

The makespan must be at least as large as the completion time of every operation. Specifically, the makespan must be at least 4 units after Operation 0 of Job 0 starts, 1 unit after Operation 1 of Job 0 starts, 6 units after Operation 2 of Job 0 starts, 6 units after Operation 3 of Job 0 starts, 8 units after Operation 4 of Job 0 starts, 9 units after Operation 0 of Job 1 starts, 1 unit after Operation 1 of Job 1 starts, 4 units after Operation 2 of Job 1 starts, and 2 units after Operation 3 of Job 1 starts.

The objective is to determine the start times for all operations and the sequence of operations on shared machines to minimize the makespan while respecting all precedence constraints, machine capacity constraints, and the makespan definition. Binary variables are used to enforce the correct sequencing of operations on shared machines, with a large constant of 100,000 ensuring the constraints are properly applied. The start times for all operations and the makespan must be non-negative. The binary variables are explicitly defined for all relevant operation pairs on shared machines, and the start times and makespan are continuous variables.","\[
\begin{aligned}
\min \quad & C_{\max} \\[4pt]
\text{s.t.}\quad
& S_{0,1}\;\ge\;S_{0,0}+4,\\
& S_{0,2}\;\ge\;S_{0,1}+1,\\
& S_{0,3}\;\ge\;S_{0,2}+6,\\
& S_{0,4}\;\ge\;S_{0,3}+6,\\
& S_{1,1}\;\ge\;S_{1,0}+9,\\
& S_{1,2}\;\ge\;S_{1,1}+1,\\
& S_{1,3}\;\ge\;S_{1,2}+4,\\[4pt]
& C_{\max}\;\ge\;S_{0,0}+4,\\
& C_{\max}\;\ge\;S_{0,1}+1,\\
& C_{\max}\;\ge\;S_{0,2}+6,\\
& C_{\max}\;\ge\;S_{0,3}+6,\\
& C_{\max}\;\ge\;S_{0,4}+8,\\
& C_{\max}\;\ge\;S_{1,0}+9,\\
& C_{\max}\;\ge\;S_{1,1}+1,\\
& C_{\max}\;\ge\;S_{1,2}+4,\\
& C_{\max}\;\ge\;S_{1,3}+2,\\[4pt]
& S_{0,3}\;\ge\;S_{0,1}+7 - M(1-y_{01,03}),\\
& S_{0,1}\;\ge\;S_{0,3}+12 - M\,y_{01,03},\\
& S_{1,2}\;\ge\;S_{0,1}+5 - M(1-y_{01,12}),\\
& S_{0,1}\;\ge\;S_{1,2}+8 - M\,y_{01,12},\\[4pt]
& S_{j,o}\;\ge\;0\quad\forall j\in\{0,1\},\,o,\\
& C_{\max}\;\ge\;0,\\[4pt]
& y_{01,03},\,y_{01,12}\;\in\;\{0,1\},\\
& S_{j,o}\;\in\;\mathbb{R}_{+}\quad\forall j,o,\\
& M=100\,000.
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

M = 100000

m = gp.Model(""Schedule_Optimization"")

# Decision variables S_{j,o}
S = {}
for j in [0, 1]:
    o_max = 4 if j == 0 else 3
    for o in range(o_max + 1):
        S[j, o] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=f""S_{j}_{o}"")

# Binary variables
y01_03 = m.addVar(vtype=GRB.BINARY, name=""y01_03"")
y01_12 = m.addVar(vtype=GRB.BINARY, name=""y01_12"")

# Objective variable
Cmax = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""Cmax"")

# Constraints
m.addConstr(S[0, 1] >= S[0, 0] + 4, name=""c1"")
m.addConstr(S[0, 2] >= S[0, 1] + 1, name=""c2"")
m.addConstr(S[0, 3] >= S[0, 2] + 6, name=""c3"")
m.addConstr(S[0, 4] >= S[0, 3] + 6, name=""c4"")
m.addConstr(S[1, 1] >= S[1, 0] + 9, name=""c5"")
m.addConstr(S[1, 2] >= S[1, 1] + 1, name=""c6"")
m.addConstr(S[1, 3] >= S[1, 2] + 4, name=""c7"")

m.addConstr(Cmax >= S[0, 0] + 4, name=""c8"")
m.addConstr(Cmax >= S[0, 1] + 1, name=""c9"")
m.addConstr(Cmax >= S[0, 2] + 6, name=""c10"")
m.addConstr(Cmax >= S[0, 3] + 6, name=""c11"")
m.addConstr(Cmax >= S[0, 4] + 8, name=""c12"")
m.addConstr(Cmax >= S[1, 0] + 9, name=""c13"")
m.addConstr(Cmax >= S[1, 1] + 1, name=""c14"")
m.addConstr(Cmax >= S[1, 2] + 4, name=""c15"")
m.addConstr(Cmax >= S[1, 3] + 2, name=""c16"")

m.addConstr(S[0, 3] >= S[0, 1] + 7 - M * (1 - y01_03), name=""c17"")
m.addConstr(S[0, 1] >= S[0, 3] + 12 - M * y01_03, name=""c18"")
m.addConstr(S[1, 2] >= S[0, 1] + 5 - M * (1 - y01_12), name=""c19"")
m.addConstr(S[0, 1] >= S[1, 2] + 8 - M * y01_12, name=""c20"")

m.setObjective(Cmax, GRB.MINIMIZE)

m.optimize()",25,25,1,,,,,,,,0.246987952
"The problem involves scheduling the landing times of three aircraft to minimize the total penalty costs associated with deviations from their earliest and latest possible landing times while ensuring safe separation between aircraft and adhering to their respective time windows. Each aircraft has an earliest and latest possible landing time, and penalty costs for landing early or late. Aircraft 0 has an earliest landing time of 201 minutes, a latest landing time of 261 minutes, an early penalty cost of \$37 per minute, and a late penalty cost of \$73 per minute. Aircraft 1 has an earliest landing time of 234 minutes, a latest landing time of 294 minutes, an early penalty cost of \$99 per minute, and a late penalty cost of \$84 per minute. Aircraft 2 has an earliest landing time of 29 minutes, a latest landing time of 89 minutes, an early penalty cost of \$90 per minute, and a late penalty cost of \$56 per minute.

The separation requirements are enforced using binary decision variables that determine the order in which the aircraft land. If Aircraft 0 lands before Aircraft 1, there must be at least 11 minutes of separation; if Aircraft 1 lands before Aircraft 0, the separation must be at least 27 minutes. If Aircraft 0 lands before Aircraft 2, there must be at least 9 minutes of separation; if Aircraft 2 lands before Aircraft 0, the separation must be at least 232 minutes. If Aircraft 1 lands before Aircraft 2, there must be at least 9 minutes of separation; if Aircraft 2 lands before Aircraft 1, the separation must be at least 265 minutes.

The landing time windows must be respected: Aircraft 0 must land between 201 and 261 minutes, Aircraft 1 between 234 and 294 minutes, and Aircraft 2 between 29 and 89 minutes. The penalties for early and late landings are calculated based on the difference between the actual landing time and the earliest or latest possible landing time, multiplied by the respective penalty costs. The objective is to determine the optimal landing times for all three aircraft to minimize the total penalty costs while ensuring all separation and time window constraints are satisfied. The total penalty cost is the sum of the early and late penalties for all aircraft. The order in which the aircraft land affects the separation requirements and landing times, so the schedule must balance these costs to achieve the lowest total penalty. Binary decision variables are used to determine the order of aircraft landings, ensuring that the separation constraints are enforced correctly. The constraints also ensure that the landing times are within the specified windows and that the penalties for early and late landings are calculated accurately based on the deviations from the earliest and latest possible landing times.","\[
\begin{aligned}
\min \quad & 37e_0 + 73l_0 + 99e_1 + 84l_1 + 90e_2 + 56l_2 \\
\text{s.t.}\quad & 201 \le t_0 \le 261, \\
& 234 \le t_1 \le 294, \\
& 29 \le t_2 \le 89, \\
& e_0 \ge 201 - t_0,\; e_0 \ge 0, \\
& l_0 \ge t_0 - 261,\; l_0 \ge 0, \\
& e_1 \ge 234 - t_1,\; e_1 \ge 0, \\
& l_1 \ge t_1 - 294,\; l_1 \ge 0, \\
& e_2 \ge 29 - t_2,\; e_2 \ge 0, \\
& l_2 \ge t_2 - 89,\; l_2 \ge 0, \\
& t_1 \ge t_0 + 11 - 1000(1-y_{01}), \\
& t_0 \ge t_1 + 27 - 1000\,y_{01}, \\
& t_2 \ge t_0 + 9 - 1000(1-y_{02}), \\
& t_0 \ge t_2 + 232 - 1000\,y_{02}, \\
& t_2 \ge t_1 + 9 - 1000(1-y_{12}), \\
& t_1 \ge t_2 + 265 - 1000\,y_{12}, \\
& y_{01}, y_{02}, y_{12} \in \{0,1\}, \\
& t_0,t_1,t_2,e_0,e_1,e_2,l_0,l_1,l_2 \in \mathbb{R}_+.
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Scheduling_Optimization"")

# Decision variables
t0 = m.addVar(lb=201, ub=261, vtype=GRB.CONTINUOUS, name=""t0"")
t1 = m.addVar(lb=234, ub=294, vtype=GRB.CONTINUOUS, name=""t1"")
t2 = m.addVar(lb=29,  ub=89,  vtype=GRB.CONTINUOUS, name=""t2"")

e0 = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""e0"")
e1 = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""e1"")
e2 = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""e2"")

l0 = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""l0"")
l1 = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""l1"")
l2 = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""l2"")

y01 = m.addVar(vtype=GRB.BINARY, name=""y01"")
y02 = m.addVar(vtype=GRB.BINARY, name=""y02"")
y12 = m.addVar(vtype=GRB.BINARY, name=""y12"")

# Objective function
m.setObjective(37*e0 + 73*l0 + 99*e1 + 84*l1 + 90*e2 + 56*l2, GRB.MINIMIZE)

# Constraints for e and l
m.addConstr(e0 >= 201 - t0, name=""e0_def"")
m.addConstr(l0 >= t0 - 261, name=""l0_def"")
m.addConstr(e1 >= 234 - t1, name=""e1_def"")
m.addConstr(l1 >= t1 - 294, name=""l1_def"")
m.addConstr(e2 >= 29 - t2,  name=""e2_def"")
m.addConstr(l2 >= t2 - 89,  name=""l2_def"")

# Big-M constraints linking t's and y's
M = 1000
m.addConstr(t1 >= t0 + 11 - M*(1 - y01), name=""bigM_01_1"")
m.addConstr(t0 >= t1 + 27 - M*y01,      name=""bigM_01_2"")
m.addConstr(t2 >= t0 + 9  - M*(1 - y02), name=""bigM_02_1"")
m.addConstr(t0 >= t2 + 232 - M*y02,      name=""bigM_02_2"")
m.addConstr(t2 >= t1 + 9  - M*(1 - y12), name=""bigM_12_1"")
m.addConstr(t1 >= t2 + 265 - M*y12,      name=""bigM_12_2"")

# Optimize
m.optimize()

# Print solution
if m.status == GRB.OPTIMAL:
    print(f""Optimal objective: {m.objVal}"")
    print(f""t0 = {t0.X}, t1 = {t1.X}, t2 = {t2.X}"")
    print(f""e0 = {e0.X}, e1 = {e1.X}, e2 = {e2.X}"")
    print(f""l0 = {l0.X}, l1 = {l1.X}, l2 = {l2.X}"")
    print(f""y01 = {y01.X}, y02 = {y02.X}, y12 = {y12.X}"")",0,0,1,,,,,,,,
"A logistics company must deliver packages to four cities: City 0, City 1, City 2, and City 3, minimizing the total delivery cost while ensuring each city is visited exactly once and the route forms a continuous loop without subtours. The delivery costs between cities are as follows: City 0 to City 1 costs 616 units, City 0 to City 2 costs 567 units, City 0 to City 3 costs 143 units, City 1 to City 0 costs 388 units, City 1 to City 2 costs 947 units, City 1 to City 3 costs 628 units, City 2 to City 0 costs 495 units, City 2 to City 1 costs 650 units, City 2 to City 3 costs 604 units, City 3 to City 0 costs 77 units, City 3 to City 1 costs 630 units, and City 3 to City 2 costs 23 units. The company uses binary decision variables to indicate whether a route is used and assigns position variables to each city to prevent subtours. The position variable for City 0 is fixed at 0, while the position variables for City 1, City 2, and City 3 must be integers between 0 and 3. The objective is to minimize the total delivery cost, which is the sum of the costs of all selected routes, including the term 0 times the position variable for City 0. Constraints ensure each city is visited and departed exactly once. Subtour elimination is enforced by ensuring that if a route from City i to City j is used, the position of City j must be greater than the position of City i, except for City 0, which is fixed as the starting point. These constraints are implemented through specific relationships between the route variables and the position variables, guaranteeing the delivery route forms a single loop without smaller loops. The constraints also explicitly bound the position variables for City 1, City 2, and City 3 to be between 0 and 3, and ensure that the position variables are correctly related to the route variables to eliminate subtours.","\[
\begin{aligned}
\min \quad & 616\,x_{01}+567\,x_{02}+143\,x_{03}+388\,x_{10}+947\,x_{12}+628\,x_{13} \\
&\quad +495\,x_{20}+650\,x_{21}+604\,x_{23}+77\,x_{30}+630\,x_{31}+23\,x_{32} \\
\text{s.t.}\quad & x_{01}+x_{02}+x_{03}=1, \\
& x_{10}+x_{12}+x_{13}=1, \\
& x_{20}+x_{21}+x_{23}=1, \\
& x_{30}+x_{31}+x_{32}=1, \\
& x_{01}+x_{11}+x_{12}+x_{13}=1, \\
& x_{10}+x_{11}+x_{12}+x_{13}=1, \\
& x_{20}+x_{21}+x_{22}+x_{23}=1, \\
& x_{30}+x_{31}+x_{32}+x_{33}=1, \\
& u_1-u_2+4x_{12}\le 3,\; u_1-u_3+4x_{13}\le 3,\; u_2-u_1+4x_{21}\le 3, \\
& u_2-u_3+4x_{23}\le 3,\; u_3-u_1+4x_{31}\le 3,\; u_3-u_2+4x_{32}\le 3, \\
& u_0=0, \\
& x_{ij}\in\{0,1\}\;\forall i\neq j, \\
& u_i\in\{1,2,3\}\;\forall i=1,2,3.
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Optimization_Model"")

# Decision variables x[i,j] for all i,j in {0,1,2,3}
x = m.addVars(4, 4, vtype=GRB.BINARY, name=""x"")

# Row constraints: each row has exactly one outgoing edge
for i in range(4):
    m.addConstr(gp.quicksum(x[i,j] for j in range(4) if j != i) == 1, name=f""row_{i}"")

# Column constraints: each column has exactly one incoming edge (including possible self-loop)
for j in range(4):
    m.addConstr(gp.quicksum(x[i,j] for i in range(4) if i != j) + x[j,j] == 1, name=f""col_{j}"")

# Decision variables u1, u2, u3 (integer 1..3) and u0 fixed to 0
u1 = m.addVar(vtype=GRB.INTEGER, lb=1, ub=3, name=""u1"")
u2 = m.addVar(vtype=GRB.INTEGER, lb=1, ub=3, name=""u2"")
u3 = m.addVar(vtype=GRB.INTEGER, lb=1, ub=3, name=""u3"")
u0 = m.addVar(vtype=GRB.INTEGER, lb=0, ub=0, name=""u0"")  # fixed to 0

# Constraints linking u's and x's
m.addConstr(u1 - u2 + 4 * x[1,2] <= 3, name=""c1"")
m.addConstr(u1 - u3 + 4 * x[1,3] <= 3, name=""c2"")
m.addConstr(u2 - u1 + 4 * x[2,1] <= 3, name=""c3"")
m.addConstr(u2 - u3 + 4 * x[2,3] <= 3, name=""c4"")
m.addConstr(u3 - u1 + 4 * x[3,1] <= 3, name=""c5"")
m.addConstr(u3 - u2 + 4 * x[3,2] <= 3, name=""c6"")

# Objective coefficients for off-diagonal variables
coeff = {
    (0,1): 616, (0,2): 567, (0,3): 143,
    (1,0): 388, (1,2): 947, (1,3): 628,
    (2,0): 495, (2,1): 650, (2,3): 604,
    (3,0): 77,  (3,1): 630, (3,2): 23
}

# Set objective: minimize total cost
m.setObjective(gp.quicksum(coeff[(i,j)] * x[i,j] for (i,j) in coeff), GRB.MINIMIZE)

# Optimize
m.optimize()
",1204,1204,1,,,,,,,,
"The problem involves scheduling operations for three jobs (Job 0, Job 1, and Job 2) on shared machines to minimize the total completion time (makespan). Each job consists of a sequence of operations with specific processing times: Job 0 has two operations (Operation 0 takes 9 units of time, Operation 1 takes 8 units), Job 1 has three operations (Operation 0 takes 8 units, Operation 1 takes 8 units, Operation 2 takes 4 units), and Job 2 has four operations (Operation 0 takes 1 unit, Operation 1 takes 6 units, Operation 2 takes 4 units, Operation 3 takes 2 units). Operations within a job must follow a strict order, meaning each operation cannot start until the previous one in the same job has finished. For example, Operation 1 of Job 0 cannot start until Operation 0 of Job 0 has completed after 9 units of time, Operation 1 of Job 1 cannot start until Operation 0 of Job 1 has completed after 8 units of time, and Operation 2 of Job 1 cannot start until Operation 1 of Job 1 has completed after 8 units of time. Similarly, Operation 1 of Job 2 cannot start until Operation 0 of Job 2 has completed after 1 unit of time, Operation 2 of Job 2 cannot start until Operation 1 of Job 2 has completed after 6 units of time, and Operation 3 of Job 2 cannot start until Operation 2 of Job 2 has completed after 4 units of time.

Certain operations from different jobs share the same machine and cannot overlap in time. For instance, Operation 1 of Job 0 and Operation 1 of Job 2 are assigned to the same machine, so one must finish before the other starts. Similarly, Operation 0 of Job 0 and Operation 1 of Job 1 share a machine, and their schedules must not overlap. This applies to all pairs of operations sharing the same machine, such as Operation 0 of Job 0 and Operation 0 of Job 2, Operation 1 of Job 1 and Operation 0 of Job 2, Operation 0 of Job 1 and Operation 2 of Job 2, Operation 0 of Job 1 and Operation 3 of Job 2, Operation 2 of Job 1 and Operation 2 of Job 2, Operation 2 of Job 1 and Operation 3 of Job 2, and Operation 2 of Job 2 and Operation 3 of Job 2.

To enforce these constraints, binary variables are used to determine the order of operations on shared machines. A large constant (100000) is used in the constraints to ensure that operations on the same machine do not overlap. For example, if Operation 1 of Job 0 and Operation 1 of Job 2 are on the same machine, the constraints ensure that one operation starts only after the other has finished, using the binary variable to decide the order. The binary variables are restricted to values of 0 or 1, and the start times of operations are continuous and non-negative.

The makespan must be at least as large as the completion time of every operation. For example, it must be at least 9 units of time (completion of Operation 0 of Job 0), 8 units (completion of Operation 1 of Job 0), 8 units (completion of Operation 0 of Job 1), 8 units (completion of Operation 1 of Job 1), 4 units (completion of Operation 2 of Job 1), 1 unit (completion of Operation 0 of Job 2), 6 units (completion of Operation 1 of Job 2), 4 units (completion of Operation 2 of Job 2), and 2 units (completion of Operation 3 of Job 2).

The objective is to determine the start times for each operation on each machine such that all precedence and machine capacity constraints are satisfied, and the total completion time (makespan) is minimized. This involves deciding the order of operations on shared machines and ensuring no overlaps, while respecting the processing times and sequence constraints of each job.","\[
\begin{aligned}
\min\quad & C \\[4pt]
\text{s.t.}\quad
& s_{0,0}\ge 0,\; s_{0,1}\ge 0,\; s_{1,0}\ge 0,\; s_{1,1}\ge 0,\; s_{1,2}\ge 0,\\
& s_{2,0}\ge 0,\; s_{2,1}\ge 0,\; s_{2,2}\ge 0,\; s_{2,3}\ge 0,\\[4pt]
& s_{0,1}\ge s_{0,0}+9,\\
& s_{1,1}\ge s_{1,0}+8,\\
& s_{1,2}\ge s_{1,1}+8,\\
& s_{2,1}\ge s_{2,0}+1,\\
& s_{2,2}\ge s_{2,1}+6,\\
& s_{2,3}\ge s_{2,2}+4,\\[4pt]
& C\ge s_{0,0}+9,\; C\ge s_{0,1}+8,\; C\ge s_{1,0}+8,\; C\ge s_{1,1}+8,\\
& C\ge s_{1,2}+4,\; C\ge s_{2,0}+1,\; C\ge s_{2,1}+6,\; C\ge s_{2,2}+4,\; C\ge s_{2,3}+2,\\[4pt]
& \text{Machine constraints (big__ = 100000):}\\
& s_{2,1}\ge s_{0,1}+8-100000(1-z_{01,21}),\\
& s_{0,1}\ge s_{2,1}+2-100000\,z_{01,21},\\[2pt]
& s_{1,1}\ge s_{0,0}+9-100000(1-z_{00,11}),\\
& s_{0,0}\ge s_{1,1}+8-100000\,z_{00,11},\\[2pt]
& s_{2,0}\ge s_{0,0}+9-100000(1-z_{00,20}),\\
& s_{0,0}\ge s_{2,0}+1-100000\,z_{00,20},\\[2pt]
& s_{2,0}\ge s_{1,1}+8-100000(1-z_{11,20}),\\
& s_{1,1}\ge s_{2,0}+1-100000\,z_{11,20},\\[2pt]
& s_{2,2}\ge s_{1,0}+8-100000(1-z_{10,22}),\\
& s_{1,0}\ge s_{2,2}+4-100000\,z_{10,22},\\[2pt]
& s_{2,3}\ge s_{1,0}+8-100000(1-z_{10,23}),\\
& s_{1,0}\ge s_{2,3}+2-100000\,z_{10,23},\\[2pt]
& s_{2,2}\ge s_{1,2}+4-100000(1-z_{12,22}),\\
& s_{1,2}\ge s_{2,2}+4-100000\,z_{12,22},\\[2pt]
& s_{2,3}\ge s_{1,2}+4-100000(1-z_{12,23}),\\
& s_{1,2}\ge s_{2,3}+2-100000\,z_{12,23},\\[2pt]
& s_{2,3}\ge s_{2,2}+4-100000(1-z_{22,23}),\\
& s_{2,2}\ge s_{2,3}+2-100000\,z_{22,23},\\[4pt]
& s_{j,k}\in\mathbb{R}_{+}\;\forall j,k,\;\; C\in\mathbb{R}_{+},\\
& z_{01,21},z_{00,11},z_{00,20},z_{11,20},z_{10,22},z_{10,23},z_{12,22},z_{12,23},z_{22,23}\in\{0,1\}.
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Scheduling_Problem"")

# Big-M value
M = 100000

# Start time variables (continuous, nonnegative)
s_indices = [(0,0),(0,1),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2),(2,3)]
s = m.addVars(s_indices, lb=0, name=""s"")

# Binary ordering variables
z_names = [""01_21"",""00_11"",""00_20"",""11_20"",""10_22"",""10_23"",""12_22"",""12_23"",""22_23""]
z = m.addVars(z_names, vtype=GRB.BINARY, name=""z"")

# Makespan variable
C = m.addVar(lb=0, name=""C"")

# Objective: minimize makespan
m.setObjective(C, GRB.MINIMIZE)

# Precedence constraints
m.addConstr(s[0,1] >= s[0,0] + 9, name=""prec_0_1_ge_0_0"")
m.addConstr(s[1,1] >= s[1,0] + 8, name=""prec_1_1_ge_1_0"")
m.addConstr(s[1,2] >= s[1,1] + 8, name=""prec_1_2_ge_1_1"")
m.addConstr(s[2,1] >= s[2,0] + 1, name=""prec_2_1_ge_2_0"")
m.addConstr(s[2,2] >= s[2,1] + 6, name=""prec_2_2_ge_2_1"")
m.addConstr(s[2,3] >= s[2,2] + 4, name=""prec_2_3_ge_2_2"")

# Makespan constraints
m.addConstr(C >= s[0,0] + 9, name=""C_ge_0_0"")
m.addConstr(C >= s[0,1] + 8, name=""C_ge_0_1"")
m.addConstr(C >= s[1,0] + 8, name=""C_ge_1_0"")
m.addConstr(C >= s[1,1] + 8, name=""C_ge_1_1"")
m.addConstr(C >= s[1,2] + 4, name=""C_ge_1_2"")
m.addConstr(C >= s[2,0] + 1, name=""C_ge_2_0"")
m.addConstr(C >= s[2,1] + 6, name=""C_ge_2_1"")
m.addConstr(C >= s[2,2] + 4, name=""C_ge_2_2"")
m.addConstr(C >= s[2,3] + 2, name=""C_ge_2_3"")

# Machine ordering constraints (big-M formulation)
m.addConstr(s[2,1] >= s[0,1] + 8 - M * (1 - z[""01_21""]), name=""s21_ge_s01_1"")
m.addConstr(s[0,1] >= s[2,1] + 2 - M * z[""01_21""], name=""s01_ge_s21_1"")

m.addConstr(s[1,1] >= s[0,0] + 9 - M * (1 - z[""00_11""]), name=""s11_ge_s00_1"")
m.addConstr(s[0,0] >= s[1,1] + 8 - M * z[""00_11""], name=""s00_ge_s11_1"")

m.addConstr(s[2,0] >= s[0,0] + 9 - M * (1 - z[""00_20""]), name=""s20_ge_s00_2"")
m.addConstr(s[0,0] >= s[2,0] + 1 - M * z[""00_20""], name=""s00_ge_s20_2"")

m.addConstr(s[2,0] >= s[1,1] + 8 - M * (1 - z[""11_20""]), name=""s20_ge_s11_2"")
m.addConstr(s[1,1] >= s[2,0] + 1 - M * z[""11_20""], name=""s11_ge_s20_2"")

m.addConstr(s[2,2] >= s[1,0] + 8 - M * (1 - z[""10_22""]), name=""s22_ge_s10_2"")
m.addConstr(s[1,0] >= s[2,2] + 4 - M * z[""10_22""], name=""s10_ge_s22_2"")

m.addConstr(s[2,3] >= s[1,0] + 8 - M * (1 - z[""10_23""]), name=""s23_ge_s10_3"")
m.addConstr(s[1,0] >= s[2,3] + 2 - M * z[""10_23""], name=""s10_ge_s23_3"")

m.addConstr(s[2,2] >= s[1,2] + 4 - M * (1 - z[""12_22""]), name=""s22_ge_s12_2"")
m.addConstr(s[1,2] >= s[2,2] + 4 - M * z[""12_22""], name=""s12_ge_s22_2"")

m.addConstr(s[2,3] >= s[1,2] + 4 - M * (1 - z[""12_23""]), name=""s23_ge_s12_3"")
m.addConstr(s[1,2] >= s[2,3] + 2 - M * z[""12_23""], name=""s12_ge_s23_3"")

m.addConstr(s[2,3] >= s[2,2] + 4 - M * (1 - z[""22_23""]), name=""s23_ge_s22_3"")
m.addConstr(s[2,2] >= s[2,3] + 2 - M * z[""22_23""], name=""s22_ge_s23_3"")

# Optimize
m.optimize()",22,22,1,,,,,,,,
"Imagine you are managing a supply chain network for a company that operates across three key locations: **Node 0**, **Node 1**, and **Node 2**. Each location has specific supply and demand requirements, and your goal is to optimize the flow of goods between these nodes while minimizing the total cost of establishing connections and shipping products.

#### Supply and Demand:
- **Node 0** has a net supply of **236 units**, meaning it can provide this amount to other nodes.
- **Node 1** has a net demand of **29 units**, requiring this amount to be fulfilled from other nodes.
- **Node 2** has a net demand of **207 units**, which must also be met through shipments from other nodes.

#### Shipping Costs and Capacities:
To move goods between nodes, you must decide whether to establish a connection (which incurs a fixed cost) and how much to ship (which incurs a variable cost per unit). The costs and capacities for each possible connection are as follows:

1. **Node 0 to Node 1**:
   - Fixed cost to establish the connection: **$3,532**
   - Variable shipping cost per unit: **$45**
   - Maximum shipping capacity: **773 units**

2. **Node 0 to Node 2**:
   - Fixed cost: **$3,895**
   - Variable shipping cost: **$49**
   - Maximum capacity: **973 units**

3. **Node 1 to Node 0**:
   - Fixed cost: **$3,485**
   - Variable shipping cost: **$11**
   - Maximum capacity: **785 units**

4. **Node 1 to Node 2**:
   - Fixed cost: **$1,845**
   - Variable shipping cost: **$40**
   - Maximum capacity: **787 units**

5. **Node 2 to Node 0**:
   - Fixed cost: **$1,291**
   - Variable shipping cost: **$13**
   - Maximum capacity: **602 units**

6. **Node 2 to Node 1**:
   - Fixed cost: **$1,818**
   - Variable shipping cost: **$47**
   - Maximum capacity: **766 units**

#### Key Decisions:
- For each connection between nodes, you must decide whether to establish it (a binary decision: yes or no).
- For each established connection, you must determine the amount of goods to ship, ensuring it does not exceed the connection's capacity.

#### Objective:
Your goal is to minimize the total cost, which includes:
1. The fixed costs of establishing the necessary connections.
2. The variable shipping costs based on the amount of goods transported.

#### Constraints:
1. **Capacity Constraints**: The amount of goods shipped between any two nodes cannot exceed the maximum capacity of that connection. For example, if you decide to ship goods from **Node 0 to Node 1**, the shipment must be **773 units or less**.
2. **Flow Balance Constraints**: The total inflow and outflow of goods at each node must match its supply or demand. For example:
   - At **Node 0**, the total inflow from **Node 1** and **Node 2** minus the outflow to **Node 1** and **Node 2** must equal **236 units**.
   - At **Node 1**, the total inflow from **Node 0** and **Node 2** minus the outflow to **Node 0** and **Node 2** must equal **-29 units** (indicating a net demand).
   - At **Node 2**, the total inflow from **Node 0** and **Node 1** minus the outflow to **Node 0** and **Node 1** must equal **-207 units** (indicating a net demand).

#### Summary:
Your task is to determine the most cost-effective way to establish connections and ship goods between **Node 0**, **Node 1**, and **Node 2** to meet the supply and demand requirements while minimizing the total cost. This involves balancing fixed and variable costs, adhering to capacity limits, and ensuring the flow of goods aligns with the needs of each node.","\[
\begin{aligned}
\min\;& 3532\,y_{01}+3895\,y_{02}+3485\,y_{10}+1845\,y_{12}+1291\,y_{20}+1818\,y_{21} \\
&\quad +45\,x_{01}+49\,x_{02}+11\,x_{10}+40\,x_{12}+13\,x_{20}+47\,x_{21} \\
\text{s.t. }& x_{01}\le 773\,y_{01},\; x_{02}\le 973\,y_{02},\; x_{10}\le 785\,y_{10},\\
& x_{12}\le 787\,y_{12},\; x_{20}\le 602\,y_{20},\; x_{21}\le 766\,y_{21},\\
& x_{10}+x_{20}-x_{01}-x_{02}=236,\\
& x_{01}+x_{21}-x_{10}-x_{12}=-29,\\
& x_{02}+x_{12}-x_{20}-x_{21}=-207,\\
& x_{01},x_{02},x_{10},x_{12},x_{20},x_{21}\ge 0,\\
& y_{01},y_{02},y_{10},y_{12},y_{20},y_{21}\in\{0,1\}.
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""MixedIntegerModel"")

# Decision variables
x_01 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""x_01"")
x_02 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""x_02"")
x_10 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""x_10"")
x_12 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""x_12"")
x_20 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""x_20"")
x_21 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""x_21"")

y_01 = m.addVar(vtype=GRB.BINARY, name=""y_01"")
y_02 = m.addVar(vtype=GRB.BINARY, name=""y_02"")
y_10 = m.addVar(vtype=GRB.BINARY, name=""y_10"")
y_12 = m.addVar(vtype=GRB.BINARY, name=""y_12"")
y_20 = m.addVar(vtype=GRB.BINARY, name=""y_20"")
y_21 = m.addVar(vtype=GRB.BINARY, name=""y_21"")

# Objective function
obj = (3532*y_01 + 3895*y_02 + 3485*y_10 + 1845*y_12 + 1291*y_20 + 1818*y_21 +
       45*x_01 + 49*x_02 + 11*x_10 + 40*x_12 + 13*x_20 + 47*x_21)
m.setObjective(obj, GRB.MINIMIZE)

# Capacity constraints
m.addConstr(x_01 <= 773*y_01, name=""cap_01"")
m.addConstr(x_02 <= 973*y_02, name=""cap_02"")
m.addConstr(x_10 <= 785*y_10, name=""cap_10"")
m.addConstr(x_12 <= 787*y_12, name=""cap_12"")
m.addConstr(x_20 <= 602*y_20, name=""cap_20"")
m.addConstr(x_21 <= 766*y_21, name=""cap_21"")

# Equality constraints
m.addConstr(x_10 + x_20 - x_01 - x_02 == 236, name=""eq1"")
m.addConstr(x_01 + x_21 - x_10 - x_12 == -29, name=""eq2"")
m.addConstr(x_02 + x_12 - x_20 - x_21 == -207, name=""eq3"")

# Optimize
m.optimize()",7364,7364,1,,,,,,,,
"The problem involves scheduling the landing times of four aircraft (aircraft_0, aircraft_1, aircraft_2, aircraft_3) at an airport to minimize the total penalty costs associated with deviations from their earliest possible landing times while adhering to separation and timing constraints. Each aircraft has an earliest and latest possible landing time, and penalty costs for landing early or late. Aircraft_0 has an earliest time of 0 minutes, latest time of 37 minutes, early penalty of \$61 per minute, and late penalty of \$82 per minute. Aircraft_1 has an earliest time of 7 minutes, latest time of 67 minutes, early penalty of \$35 per minute, and late penalty of \$34 per minute. Aircraft_2 has an earliest time of 225 minutes, latest time of 285 minutes, early penalty of \$74 per minute, and late penalty of \$41 per minute. Aircraft_3 has an earliest time of 119 minutes, latest time of 179 minutes, early penalty of \$93 per minute, and late penalty of \$56 per minute.

The landing order between any two aircraft must be explicitly determined using binary decision variables, ensuring one lands before the other. Separation constraints are enforced based on these landing orders, with coefficients modifying the required separation time depending on the landing sequence. For example, if aircraft_0 lands before aircraft_1, the separation constraint is adjusted by coefficients such as 2 and 30 depending on the order. Similar adjustments apply to other pairs: aircraft_0 and aircraft_2, aircraft_0 and aircraft_3, aircraft_1 and aircraft_2, aircraft_1 and aircraft_3, and aircraft_2 and aircraft_3. These constraints ensure that the separation between consecutive landings is maintained according to the specific coefficients provided in the LP data.

Each aircraft must land within its specified earliest and latest possible landing times. Early deviations are calculated as the difference between the earliest time and the actual landing time if the aircraft lands early, and late deviations are calculated as the difference between the actual landing time and the earliest time if the aircraft lands late. The total penalty cost is the sum of the early and late penalties for all aircraft, weighted by their respective penalty rates. The objective is to determine the optimal landing times for all four aircraft to minimize the total penalty costs while ensuring all separation and timing constraints are satisfied.","\[
\begin{aligned}
\min \quad & \sum_{i=0}^{3}\bigl(\text{early}_i\,e_i+\text{late}_i\,l_i\bigr)\\[4pt]
\text{s.t.}\quad
& e_i \;\ge\; \text{earliest}_i - t_i, &&\forall i=0,\dots,3\\
& l_i \;\ge\; t_i - \text{earliest}_i, &&\forall i=0,\dots,3\\
& e_i,\;l_i \;\ge\; 0, &&\forall i\\
& t_i \;\ge\; \text{earliest}_i,\;\; t_i \;\le\; \text{latest}_i, &&\forall i\\
& t_j - t_i \;\ge\; \text{sep}_{ij}^{\text{before}} - M(1-y_{ij}), &&\forall\,i<j\\
& t_i - t_j \;\ge\; \text{sep}_{ij}^{\text{after}} - M\,y_{ij}, &&\forall\,i<j\\
& y_{ij}\;\in\;\{0,1\}, &&\forall\,i<j\\
& t_i,\;e_i,\;l_i\;\in\;\mathbb{R}, &&\forall i
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Data
earliest = [0, 1, 2, 3]
latest   = [10, 10, 10, 10]
early_cost = [2, 3, 4, 5]
late_cost  = [1, 1, 1, 1]

# Separation times (only i<j entries are used)
sep_before = [
    [0, 2, 3, 4],
    [0, 0, 2, 3],
    [0, 0, 0, 2],
    [0, 0, 0, 0]
]
sep_after  = [
    [0, 1, 2, 3],
    [0, 0, 1, 2],
    [0, 0, 0, 1],
    [0, 0, 0, 0]
]

M = 1e6  # big-M constant

# Create model
m = gp.Model(""Scheduling_Problem"")

# Decision variables
t = m.addVars(4, lb=earliest[0], ub=latest[3], name=""t"")   # start times
e = m.addVars(4, lb=0, name=""e"")                           # early penalties
l = m.addVars(4, lb=0, name=""l"")                           # late penalties
y = {}
for i in range(4):
    for j in range(i+1, 4):
        y[i,j] = m.addVar(vtype=GRB.BINARY, name=f""y_{i}_{j}"")

# Objective: minimize weighted sum of early and late penalties
m.setObjective(
    gp.quicksum(early_cost[i]*e[i] + late_cost[i]*l[i] for i in range(4)),
    GRB.MINIMIZE
)

# Constraints
for i in range(4):
    # Early and late penalty definitions
    m.addConstr(e[i] >= earliest[i] - t[i], name=f""early_def_{i}"")
    m.addConstr(l[i] >= t[i] - earliest[i], name=f""late_def_{i}"")

    # Time window constraints
    m.addConstr(t[i] >= earliest[i], name=f""time_lb_{i}"")
    m.addConstr(t[i] <= latest[i], name=f""time_ub_{i}"")

# Separation constraints with ordering variables
for i in range(4):
    for j in range(i+1, 4):
        m.addConstr(
            t[j] - t[i] >= sep_before[i][j] - M*(1 - y[i,j]),
            name=f""sep_before_{i}_{j}""
        )
        m.addConstr(
            t[i] - t[j] >= sep_after[i][j] - M*y[i,j],
            name=f""sep_after_{i}_{j}""
        )

# Optimize
m.optimize()
```",6,0,0,,,,,,,,
"The problem involves scheduling the landings of six aircraft to minimize the total penalty costs associated with deviations from their target landing times. Each aircraft has a target landing time, an earliest possible landing time, and a latest possible landing time. Penalties are incurred for landing early or late, with specific penalty rates for each aircraft: aircraft_0 has an early penalty rate of 72 and a late penalty rate of 59, aircraft_1 has an early penalty rate of 81 and a late penalty rate of 40, aircraft_2 has an early penalty rate of 46 and a late penalty rate of 34, aircraft_3 has an early penalty rate of 78 and a late penalty rate of 24, aircraft_4 has an early penalty rate of 40 and a late penalty rate of 80, and aircraft_5 has an early penalty rate of 60 and a late penalty rate of 14. The landing times must respect minimum separation times between consecutive landings, which vary depending on the pair of aircraft. The separation constraints are enforced using binary decision variables that determine the order in which the aircraft land. The objective is to minimize the sum of early and late landing penalties, weighted by the respective penalty rates for each aircraft. The landing times must fall within the specified time windows for each aircraft: aircraft_0 must land between 221 and 281, aircraft_1 between 179 and 239, aircraft_2 between 268 and 300, aircraft_3 between 0 and 36, aircraft_4 between 131 and 191, and aircraft_5 between 265 and 300. The order of landings must ensure that the separation constraints are satisfied, with specific separation times for each pair of aircraft. The binary decision variables ensure that the separation constraints are met by determining the sequence of landings. The problem requires determining the exact landing times for each aircraft within their respective time windows, ensuring that the separation requirements are met, and minimizing the total penalty costs. The binary variables are used to enforce the separation constraints, ensuring that if one aircraft lands before another, the required separation time is maintained. The constraints also ensure that the landing times fall within the specified time windows and that the penalties for early or late landings are correctly calculated based on the deviation from the target landing times. The binary variables are explicitly defined as binary (0 or 1) to determine the sequence of landings and enforce the separation constraints.","\[
\begin{aligned}
\min \quad & \sum_{i=0}^{5} \bigl( e_i\, e_i^{\text{dev}} + l_i\, l_i^{\text{dev}} \bigr) \\
\text{s.t.}\quad & E_i \le x_i \le L_i && \forall i=0,\dots,5 \\
& e_i^{\text{dev}} \ge t_i - x_i && \forall i \\
& l_i^{\text{dev}} \ge x_i - t_i && \forall i \\
& e_i^{\text{dev}},\, l_i^{\text{dev}} \ge 0 && \forall i \\
& y_{ij} + y_{ji} = 1 && \forall\, i<j \\
& x_j \ge x_i + s_{ij} - M(1 - y_{ij}) && \forall\, i<j \\
& x_i \ge x_j + s_{ji} - M(1 - y_{ji}) && \forall\, i<j \\
& x_i,\, e_i^{\text{dev}},\, l_i^{\text{dev}} \in \mathbb{R} && \forall i \\
& y_{ij} \in \{0,1\} && \forall\, i<j
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB
import numpy as np

# Example data
E = np.array([0, 0, 0, 0, 0, 0])          # lower bounds for x_i
L = np.array([10, 10, 10, 10, 10, 10])    # upper bounds for x_i
t = np.array([5, 5, 5, 5, 5, 5])          # target values
s = np.array([  # pairwise separation requirements
    [0, 2, 3, 1, 4, 2],
    [2, 0, 1, 3, 2, 5],
    [3, 1, 0, 2, 4, 1],
    [1, 3, 2, 0, 3, 2],
    [4, 2, 4, 3, 0, 3],
    [2, 5, 1, 2, 3, 0]
])
M = 1000  # big-M constant

# Create model
m = gp.Model(""Sequence_Optimization"")

# Decision variables
x = m.addVars(6, vtype=GRB.CONTINUOUS, name=""x"")
e_dev = m.addVars(6, vtype=GRB.CONTINUOUS, lb=0, name=""e_dev"")
l_dev = m.addVars(6, vtype=GRB.CONTINUOUS, lb=0, name=""l_dev"")
y = {}
for i in range(6):
    for j in range(i+1, 6):
        y[i,j] = m.addVar(vtype=GRB.BINARY, name=f""y_{i}_{j}"")

# Objective: minimize weighted deviations
m.setObjective(gp.quicksum(e_dev[i]*1 + l_dev[i]*1 for i in range(6)), GRB.MINIMIZE)

# Bounds on x_i
for i in range(6):
    m.addConstr(x[i] >= E[i], name=f""lb_x_{i}"")
    m.addConstr(x[i] <= L[i], name=f""ub_x_{i}"")

# Deviation constraints
for i in range(6):
    m.addConstr(e_dev[i] >= t[i] - x[i], name=f""e_dev_{i}"")
    m.addConstr(l_dev[i] >= x[i] - t[i], name=f""l_dev_{i}"")

# Ordering constraints using binary variables
for i in range(6):
    for j in range(i+1, 6):
        m.addConstr(y[i,j] + y[j,i] == 1, name=f""order_sum_{i}_{j}"")
        m.addConstr(x[j] >= x[i] + s[i,j] - M*(1 - y[i,j]), name=f""order_xj_ge_xi_{i}_{j}"")
        m.addConstr(x[i] >= x[j] + s[j,i] - M*(1 - y[j,i]), name=f""order_xi_ge_xj_{i}_{j}"")

# Optimize
m.optimize()",0,34,0,,,,,,,,
"The manufacturing facility produces custom orders for three jobs: Job 0, Job 1, and Job 2. Each job consists of a sequence of operations that must be performed in a specific order, with each operation requiring a specific duration. The facility has limited machines, and some operations from different jobs must share the same machine. The goal is to schedule all operations to minimize the total completion time (makespan).

Job 0 has two operations: Operation 0 and Operation 1. Operation 1 cannot start until Operation 0 has finished, with at least 8 hours between their start times. The makespan must be at least 8 hours after the start of Operation 0 and at least 5 hours after the start of Operation 1.

Job 1 has five operations: Operation 0, Operation 1, Operation 2, Operation 3, and Operation 4. Operation 1 cannot start until Operation 0 has finished, with at least 7 hours between their start times. Operation 2 cannot start until Operation 1 has finished, with at least 9 hours between their start times. Operation 3 cannot start until Operation 2 has finished, with at least 5 hours between their start times. Operation 4 cannot start until Operation 3 has finished, with at least 6 hours between their start times. The makespan must be at least 7 hours after the start of Operation 0, 9 hours after the start of Operation 1, 5 hours after the start of Operation 2, 6 hours after the start of Operation 3, and 2 hours after the start of Operation 4.

Job 2 has five operations: Operation 0, Operation 1, Operation 2, Operation 3, and Operation 4. Operation 1 cannot start until Operation 0 has finished, with at least 9 hours between their start times. Operation 2 cannot start until Operation 1 has finished, with at least 5 hours between their start times. Operation 3 cannot start until Operation 2 has finished, with at least 8 hours between their start times. Operation 4 cannot start until Operation 3 has finished, with at least 3 hours between their start times. The makespan must be at least 9 hours after the start of Operation 0, 5 hours after the start of Operation 1, 8 hours after the start of Operation 2, 3 hours after the start of Operation 3, and 1 hour after the start of Operation 4.

Certain operations from different jobs share machines and must be scheduled without overlap. The following pairs of operations share machines: Operation 0 of Job 1 and Operation 2 of Job 1; Operation 1 of Job 0 and Operation 3 of Job 2; Operation 0 of Job 0 and Operation 1 of Job 2; Operation 0 of Job 0 and Operation 2 of Job 2; Operation 1 of Job 2 and Operation 2 of Job 2; Operation 4 of Job 1 and Operation 0 of Job 2. The scheduling system must determine the order of these operations to avoid conflicts, using binary variables to enforce the order. A large constant (100000) is used in the constraints to ensure that the order of operations sharing machines is respected.

The objective is to determine the start times for all operations such that all precedence constraints within each job are satisfied, no two operations sharing the same machine overlap in time, and the total completion time (makespan) is minimized. The makespan must be at least as large as the completion time of every operation. All start times must be non-negative. The binary variables are used to enforce the order of operations sharing machines, and the large constant ensures that the constraints are properly applied. The start times and the makespan are general variables, and the objective is explicitly to minimize the makespan.","\[
\begin{aligned}
\min \quad & C\\
\text{s.t.}\quad & s_{0,0}\ge0,\; s_{0,1}\ge0,\; s_{1,0}\ge0,\; s_{1,1}\ge0,\; s_{1,2}\ge0,\; s_{1,3}\ge0,\; s_{1,4}\ge0,\; s_{2,0}\ge0,\; s_{2,1}\ge0,\; s_{2,2}\ge0,\; s_{2,3}\ge0,\; s_{2,4}\ge0,\\
& s_{0,1}\ge s_{0,0}+8,\\
& s_{1,1}\ge s_{1,0}+7,\; s_{1,2}\ge s_{1,1}+9,\; s_{1,3}\ge s_{1,2}+5,\; s_{1,4}\ge s_{1,3}+6,\\
& s_{2,1}\ge s_{2,0}+9,\; s_{2,2}\ge s_{2,1}+5,\; s_{2,3}\ge s_{2,2}+8,\; s_{2,4}\ge s_{2,3}+3,\\
& C\ge s_{0,0}+8,\; C\ge s_{0,1}+5,\\
& C\ge s_{1,0}+7,\; C\ge s_{1,1}+9,\; C\ge s_{1,2}+5,\; C\ge s_{1,3}+6,\; C\ge s_{1,4}+2,\\
& C\ge s_{2,0}+9,\; C\ge s_{2,1}+5,\; C\ge s_{2,2}+8,\; C\ge s_{2,3}+3,\; C\ge s_{2,4}+1,\\
& s_{1,0}\le s_{1,2}+M(1-y_{10,12}),\; s_{1,2}\le s_{1,0}+M y_{10,12},\\
& s_{0,1}\le s_{2,3}+M(1-y_{01,23}),\; s_{2,3}\le s_{0,1}+M y_{01,23},\\
& s_{0,0}\le s_{2,1}+M(1-y_{00,21}),\; s_{2,1}\le s_{0,0}+M y_{00,21},\\
& s_{0,0}\le s_{2,2}+M(1-y_{00,22}),\; s_{2,2}\le s_{0,0}+M y_{00,22},\\
& s_{2,1}\le s_{2,2}+M(1-y_{21,22}),\; s_{2,2}\le s_{2,1}+M y_{21,22},\\
& s_{1,4}\le s_{2,0}+M(1-y_{14,20}),\; s_{2,0}\le s_{1,4}+M y_{14,20},\\
& M=100000,\\
& s_{0,0},s_{0,1},s_{1,0},s_{1,1},s_{1,2},s_{1,3},s_{1,4},s_{2,0},s_{2,1},s_{2,2},s_{2,3},s_{2,4},C \in \mathbb{R}_+,\\
& y_{10,12},y_{01,23},y_{00,21},y_{00,22},y_{21,22},y_{14,20} \in \{0,1\}.
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Optimization_Model"")

# Big-M value
M = 100000

# Decision variables s_{i,j}
s = {}
s[(0,0)] = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""s_0_0"")
s[(0,1)] = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""s_0_1"")
s[(1,0)] = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""s_1_0"")
s[(1,1)] = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""s_1_1"")
s[(1,2)] = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""s_1_2"")
s[(1,3)] = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""s_1_3"")
s[(1,4)] = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""s_1_4"")
s[(2,0)] = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""s_2_0"")
s[(2,1)] = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""s_2_1"")
s[(2,2)] = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""s_2_2"")
s[(2,3)] = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""s_2_3"")
s[(2,4)] = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""s_2_4"")

# Decision variable C
C = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""C"")

# Binary variables y
y = {}
y[""10_12""] = m.addVar(vtype=GRB.BINARY, name=""y_10_12"")
y[""01_23""] = m.addVar(vtype=GRB.BINARY, name=""y_01_23"")
y[""00_21""] = m.addVar(vtype=GRB.BINARY, name=""y_00_21"")
y[""00_22""] = m.addVar(vtype=GRB.BINARY, name=""y_00_22"")
y[""21_22""] = m.addVar(vtype=GRB.BINARY, name=""y_21_22"")
y[""14_20""] = m.addVar(vtype=GRB.BINARY, name=""y_14_20"")

# Constraints on s variables
m.addConstr(s[(0,1)] >= s[(0,0)] + 8, name=""s01_ge_s00_plus8"")
m.addConstr(s[(1,1)] >= s[(1,0)] + 7, name=""s11_ge_s10_plus7"")
m.addConstr(s[(1,2)] >= s[(1,1)] + 9, name=""s12_ge_s11_plus9"")
m.addConstr(s[(1,3)] >= s[(1,2)] + 5, name=""s13_ge_s12_plus5"")
m.addConstr(s[(1,4)] >= s[(1,3)] + 6, name=""s14_ge_s13_plus6"")
m.addConstr(s[(2,1)] >= s[(2,0)] + 9, name=""s21_ge_s20_plus9"")
m.addConstr(s[(2,2)] >= s[(2,1)] + 5, name=""s22_ge_s21_plus5"")
m.addConstr(s[(2,3)] >= s[(2,2)] + 8, name=""s23_ge_s22_plus8"")
m.addConstr(s[(2,4)] >= s[(2,3)] + 3, name=""s24_ge_s23_plus3"")

# Constraints linking C with s variables
m.addConstr(C >= s[(0,0)] + 8, name=""C_ge_s00_plus8"")
m.addConstr(C >= s[(0,1)] + 5, name=""C_ge_s01_plus5"")
m.addConstr(C >= s[(1,0)] + 7, name=""C_ge_s10_plus7"")
m.addConstr(C >= s[(1,1)] + 9, name=""C_ge_s11_plus9"")
m.addConstr(C >= s[(1,2)] + 5, name=""C_ge_s12_plus5"")
m.addConstr(C >= s[(1,3)] + 6, name=""C_ge_s13_plus6"")
m.addConstr(C >= s[(1,4)] + 2, name=""C_ge_s14_plus2"")
m.addConstr(C >= s[(2,0)] + 9, name=""C_ge_s20_plus9"")
m.addConstr(C >= s[(2,1)] + 5, name=""C_ge_s21_plus5"")
m.addConstr(C >= s[(2,2)] + 8, name=""C_ge_s22_plus8"")
m.addConstr(C >= s[(2,3)] + 3, name=""C_ge_s23_plus3"")
m.addConstr(C >= s[(2,4)] + 1, name=""C_ge_s24_plus1"")

# Big-M constraints with binary variables
m.addConstr(s[(1,0)] <= s[(1,2)] + M * (1 - y[""10_12""]), name=""s10_le_s12_plus_M1"")
m.addConstr(s[(1,2)] <= s[(1,0)] + M * y[""10_12""], name=""s12_le_s10_plus_M2"")

m.addConstr(s[(0,1)] <= s[(2,3)] + M * (1 - y[""01_23""]), name=""s01_le_s23_plus_M1"")
m.addConstr(s[(2,3)] <= s[(0,1)] + M * y[""01_23""], name=""s23_le_s01_plus_M2"")

m.addConstr(s[(0,0)] <= s[(2,1)] + M * (1 - y[""00_21""]), name=""s00_le_s21_plus_M1"")
m.addConstr(s[(2,1)] <= s[(0,0)] + M * y[""00_21""], name=""s21_le_s00_plus_M2"")

m.addConstr(s[(0,0)] <= s[(2,2)] + M * (1 - y[""00_22""]), name=""s00_le_s22_plus_M1"")
m.addConstr(s[(2,2)] <= s[(0,0)] + M * y[""00_22""], name=""s22_le_s00_plus_M2"")

m.addConstr(s[(2,1)] <= s[(2,2)] + M * (1 - y[""21_22""]), name=""s21_le_s22_plus_M1"")
m.addConstr(s[(2,2)] <= s[(2,1)] + M * y[""21_22""], name=""s22_le_s21_plus_M2"")

m.addConstr(s[(1,4)] <= s[(2,0)] + M * (1 - y[""14_20""]), name=""s14_le_s20_plus_M1"")
m.addConstr(s[(2,0)] <= s[(1,4)] + M * y[""14_20""], name=""s20_le_s14_plus_M2"")

# Objective: minimize C
m.setObjective(C, GRB.MINIMIZE)

# Optimize
m.optimize()
```",29,29,1,,,,,,,,
"Determine the optimal sequence of six cities (City 0, City 1, City 2, City 3, City 4, and City 5) to minimize the total travel distance while ensuring each city is visited exactly once. The distances between the cities are as follows: From City 0 to City 1 (722 units), City 2 (758 units), City 3 (688 units), City 4 (897 units), and City 5 (100 units); from City 1 to City 0 (746 units), City 2 (76 units), City 3 (49 units), City 4 (86 units), and City 5 (385 units); from City 2 to City 0 (479 units), City 1 (154 units), City 3 (11 units), City 4 (374 units), and City 5 (350 units); from City 3 to City 0 (645 units), City 1 (842 units), City 2 (117 units), City 4 (619 units), and City 5 (535 units); from City 4 to City 0 (278 units), City 1 (829 units), City 2 (499 units), City 3 (268 units), and City 5 (973 units); from City 5 to City 0 (951 units), City 1 (144 units), City 2 (810 units), City 3 (943 units), and City 4 (989 units). Each city must be visited exactly once, and each city must be departed exactly once. To prevent subtours, the sequence of cities must be continuous, and the position of each city in the sequence must be between 0 and 5. If a route is taken from city i to city j, the position of city i must be less than the position of city j. The decision variables include selecting whether to include each route (binary) and assigning a position to each city in the sequence (integer). The position variables u[city_0] to u[city_5] must satisfy the constraints that ensure the sequence is continuous and the position of each city is between 0 and 5. The goal is to minimize the total distance traveled while satisfying all constraints, including the subtour elimination constraints that link the route variables and the position variables. The constraints R12 to R41 ensure that if a route is taken from city i to city j, the position of city i must be less than the position of city j, and the position variables u[city_1] to u[city_5] are bounded between 0 and 5. The route variables are binary, and the position variables are general (integer) variables.","\begin{align*}
\min \quad & 722x_{01}+758x_{02}+688x_{03}+897x_{04}+100x_{05}\\
&+746x_{10}+76x_{12}+49x_{13}+86x_{14}+385x_{15}\\
&+479x_{20}+154x_{21}+11x_{23}+374x_{24}+350x_{25}\\
&+645x_{30}+842x_{31}+117x_{32}+619x_{34}+535x_{35}\\
&+278x_{40}+829x_{41}+499x_{42}+268x_{43}+973x_{45}\\
&+951x_{50}+144x_{51}+810x_{52}+943x_{53}+989x_{54}\\
\text{s.t.}\quad & \sum_{j\neq i}x_{ij}=1 && \forall i=0,\dots,5\\
& \sum_{i\neq j}x_{ij}=1 && \forall j=0,\dots,5\\
& u_0=0\\
& u_i-u_j+5x_{ij}\le4 && \forall i=1,\dots,5,\;\forall j=1,\dots,5,\;i\neq j\\
& 1\le u_i\le5 && \forall i=1,\dots,5\\
& x_{ij}\in\{0,1\} && \forall i,j,\;i\neq j\\
& u_i\in\mathbb{Z} && \forall i=1,\dots,5
\end{align*}","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""TSP_with_subtour_elimination"")

# Indices
nodes = range(6)          # 0..5
inner_nodes = range(1,6)  # 1..5

# Decision variables
x = m.addVars(nodes, nodes, vtype=GRB.BINARY, name=""x"")
u = m.addVars(inner_nodes, vtype=GRB.INTEGER, name=""u"")

# Objective: minimize total cost
cost = {
    (0,1):722, (0,2):758, (0,3):688, (0,4):897, (0,5):100,
    (1,0):746, (1,2):76,  (1,3):49,  (1,4):86,  (1,5):385,
    (2,0):479, (2,1):154, (2,3):11,  (2,4):374, (2,5):350,
    (3,0):645, (3,1):842, (3,2):117, (3,4):619, (3,5):535,
    (4,0):278, (4,1):829, (4,2):499, (4,3):268, (4,5):973,
    (5,0):951, (5,1):144, (5,2):810, (5,3):943, (5,4):989
}
m.setObjective(gp.quicksum(cost[i,j]*x[i,j] for i in nodes for j in nodes if i!=j), GRB.MINIMIZE)

# Outgoing and incoming constraints
for i in nodes:
    m.addConstr(gp.quicksum(x[i,j] for j in nodes if j!=i) == 1, name=f""out_{i}"")
    m.addConstr(gp.quicksum(x[j,i] for j in nodes if j!=i) == 1, name=f""in_{i}"")

# Subtour elimination constraints
for i in inner_nodes:
    for j in inner_nodes:
        if i != j:
            m.addConstr(u[i] - u[j] + 5*x[i,j] <= 4, name=f""subtour_{i}_{j}"")

# Bounds on u variables
for i in inner_nodes:
    m.addConstr(u[i] >= 1, name=f""u_low_{i}"")
    m.addConstr(u[i] <= 5, name=f""u_high_{i}"")

# Solve
m.optimize()",1062,1062,1,,,,,,,,
"Minimize the total cost, which includes fixed costs for establishing transit lines, operational costs based on the frequency of each line, and penalty costs for any unmet passenger demand. The transit network consists of seven potential lines (L0 to L6), each with specific fixed costs, operational costs per trip, and frequency bounds. The fixed costs are 2960 units for L0, 3834 for L1, 2998 for L2, 4562 for L3, 3636 for L4, 1972 for L5, and 1570 for L6. The operational costs per trip are 166 units for L0, 154 for L1, 133 for L2, 473 for L3, 381 for L4, 459 for L5, and 242 for L6. The frequency of each line must be between 2 and 10 trips per unit time if the line is selected. The total vehicle usage across all lines must not exceed the available fleet of 35 vehicles. Vehicle usage per trip is 66 units for L0, 113 for L1, 142 for L2, 179 for L3, 89 for L4, 106 for L5, and 129 for L6.

For each origin-destination (OD) pair, the total capacity provided by the selected lines must meet or exceed the demand. If not, the unmet demand incurs a penalty. The demand for OD pair 4-3 is 19 passengers with a penalty of 945 units, OD pair 5-2 is 42 passengers with a penalty of 649 units, OD pair 0-1 is 33 passengers with a penalty of 605 units, OD pair 7-4 is 28 passengers with a penalty of 747 units, OD pair 1-4 is 30 passengers with a penalty of 799 units, OD pair 3-7 is 31 passengers with a penalty of 960 units, OD pair 6-3 is 27 passengers with a penalty of 558 units, OD pair 2-5 is 13 passengers with a penalty of 530 units, OD pair 4-7 is 27 passengers with a penalty of 630 units, OD pair 1-3 is 42 passengers with a penalty of 528 units, OD pair 7-1 is 42 passengers with a penalty of 695 units, OD pair 6-1 is 31 passengers with a penalty of 814 units, OD pair 5-1 is 35 passengers with a penalty of 652 units, OD pair 3-1 is 39 passengers with a penalty of 748 units, OD pair 6-2 is 20 passengers with a penalty of 786 units, OD pair 5-3 is 34 passengers with a penalty of 599 units, OD pair 2-1 is 39 passengers with a penalty of 948 units, and OD pair 6-5 is 39 passengers with a penalty of 577 units.

A station can only be designated as a transfer station if at least two lines pass through it. For example, station 0 can only be a transfer station if line L5 is selected, station 1 can only be a transfer station if at least two of lines L3, L4, or L6 are selected, station 2 can only be a transfer station if line L0 is selected, station 3 can only be a transfer station if line L1 is selected, station 4 can only be a transfer station if line L2 is selected, station 5 can only be a transfer station if at least two of lines L2, L3, L4, L5, or L6 are selected, and stations 6 and 7 cannot be transfer stations. The binary variables y[0] to y[7] indicate whether a station is a transfer station, and constraints ensure that y[n] can only be 1 if at least two lines pass through station n. The total frequency of lines serving each OD pair must meet a minimum threshold to ensure adequate service quality. Each selected line must form a continuous route, ensuring that the sequence of stations is logically connected. Frequencies and unmet demands must be non-negative, and decisions about line selection and transfer stations must be binary (yes/no). The constraints also ensure that the frequency of a line is between 2 and 10 if the line is selected, and the total vehicle usage across all lines does not exceed 35 units.","\[
\begin{aligned}
\min \quad & 2960\,z_{0}+3834\,z_{1}+2998\,z_{2}+4562\,z_{3}+3636\,z_{4}+1972\,z_{5}+1570\,z_{6} \\
&\quad +166\,f_{0}+154\,f_{1}+133\,f_{2}+473\,f_{3}+381\,f_{4}+459\,f_{5}+242\,f_{6} \\
&\quad +945\,u_{43}+649\,u_{52}+605\,u_{01}+747\,u_{74}+799\,u_{14}+960\,u_{37}+558\,u_{63} \\
&\quad +530\,u_{25}+630\,u_{47}+528\,u_{13}+695\,u_{71}+814\,u_{61}+652\,u_{51}+748\,u_{31} \\
&\quad +786\,u_{62}+599\,u_{53}+948\,u_{21}+577\,u_{65} \\[4pt]
\text{s.t.}\quad & 66\,f_{0}+113\,f_{1}+142\,f_{2}+179\,f_{3}+89\,f_{4}+106\,f_{5}+129\,f_{6}\le 35 \\[2pt]
& 2\,z_{i}\le f_{i}\le 10\,z_{i}\qquad i=0,\dots ,6 \\[2pt]
& f_{0}+f_{1}+f_{2}+f_{3}+f_{4}+f_{5}+f_{6}\ge 19-u_{43} \\[2pt]
& f_{0}+f_{1}+f_{2}+f_{3}+f_{4}+f_{5}+f_{6}\ge 42-u_{52} \\[2pt]
& f_{0}+f_{1}+f_{2}+f_{3}+f_{4}+f_{5}+f_{6}\ge 33-u_{01} \\[2pt]
& f_{0}+f_{1}+f_{2}+f_{3}+f_{4}+f_{5}+f_{6}\ge 28-u_{74} \\[2pt]
& f_{0}+f_{1}+f_{2}+f_{3}+f_{4}+f_{5}+f_{6}\ge 30-u_{14} \\[2pt]
& f_{0}+f_{1}+f_{2}+f_{3}+f_{4}+f_{5}+f_{6}\ge 31-u_{37} \\[2pt]
& f_{0}+f_{1}+f_{2}+f_{3}+f_{4}+f_{5}+f_{6}\ge 27-u_{63} \\[2pt]
& f_{0}+f_{1}+f_{2}+f_{3}+f_{4}+f_{5}+f_{6}\ge 13-u_{25} \\[2pt]
& f_{0}+f_{1}+f_{2}+f_{3}+f_{4}+f_{5}+f_{6}\ge 27-u_{47} \\[2pt]
& f_{0}+f_{1}+f_{2}+f_{3}+f_{4}+f_{5}+f_{6}\ge 42-u_{13} \\[2pt]
& f_{0}+f_{1}+f_{2}+f_{3}+f_{4}+f_{5}+f_{6}\ge 42-u_{71} \\[2pt]
& f_{0}+f_{1}+f_{2}+f_{3}+f_{4}+f_{5}+f_{6}\ge 31-u_{61} \\[2pt]
& f_{0}+f_{1}+f_{2}+f_{3}+f_{4}+f_{5}+f_{6}\ge 35-u_{51} \\[2pt]
& f_{0}+f_{1}+f_{2}+f_{3}+f_{4}+f_{5}+f_{6}\ge 39-u_{31} \\[2pt]
& f_{0}+f_{1}+f_{2}+f_{3}+f_{4}+f_{5}+f_{6}\ge 20-u_{62} \\[2pt]
& f_{0}+f_{1}+f_{2}+f_{3}+f_{4}+f_{5}+f_{6}\ge 34-u_{53} \\[2pt]
& f_{0}+f_{1}+f_{2}+f_{3}+f_{4}+f_{5}+f_{6}\ge 39-u_{21} \\[2pt]
& f_{0}+f_{1}+f_{2}+f_{3}+f_{4}+f_{5}+f_{6}\ge 39-u_{65} \\[4pt]
& u_{43},u_{52},u_{01},u_{74},u_{14},u_{37},u_{63},u_{25},u_{47},u_{13},u_{71},u_{61},u_{51},u_{31},u_{62},u_{53},u_{21},u_{65}\ge 0 \\[2pt]
& y_{0}\le z_{5} \\[2pt]
& z_{3}+z_{4}+z_{6}\ge 2\,y_{1} \\[2pt]
& y_{2}\le z_{0} \\[2pt]
& y_{3}\le z_{1} \\[2pt]
& y_{4}\le z_{2} \\[2pt]
& z_{2}+z_{3}+z_{4}+z_{5}+z_{6}\ge 2\,y_{5} \\[2pt]
& y_{6}=0,\; y_{7}=0 \\[2pt]
& z_{i}\in\{0,1\}\quad i=0,\dots ,6 \\[2pt]
& y_{n}\in\{0,1\}\quad n=0,\dots ,7 \\[2pt]
& f_{i}\in\mathbb{Z}_{+}\quad i=0,\dots ,6 \\[2pt]
& u_{43},u_{52},u_{01},u_{74},u_{14},u_{37},u_{63},u_{25},u_{47},u_{13},u_{71},u_{61},u_{51},u_{31},u_{62},u_{53},u_{21},u_{65}\in\mathbb{R}_{+}
\end{aligned}","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Optimization_Model"")

# Decision variables
z = m.addVars(7, vtype=GRB.BINARY, name=""z"")          # z0..z6
y = m.addVars(8, vtype=GRB.BINARY, name=""y"")          # y0..y7
f = m.addVars(7, vtype=GRB.INTEGER, lb=0, name=""f"")   # f0..f6

u_names = ['u43','u52','u01','u74','u14','u37','u63','u25',
           'u47','u13','u71','u61','u51','u31','u62','u53',
           'u21','u65']
u = {name: m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=name) for name in u_names}

# Objective coefficients
coeff_z = [2960,3834,2998,4562,3636,1972,1570]
coeff_f = [166,154,133,473,381,459,242]
coeff_u = [945,649,605,747,799,960,558,530,630,528,695,814,652,748,786,599,948,577]

# Objective function
obj = gp.quicksum(z[i]*coeff_z[i] for i in range(7)) + \
      gp.quicksum(f[i]*coeff_f[i] for i in range(7)) + \
      gp.quicksum(u[name]*coeff_u[idx] for idx,name in enumerate(u_names))
m.setObjective(obj, GRB.MINIMIZE)

# Constraints
# Capacity constraint
m.addConstr(gp.quicksum([66,113,142,179,89,106,129][i]*f[i] for i in range(7)) <= 35, ""capacity"")

# Linking z and f
for i in range(7):
    m.addConstr(2*z[i] <= f[i], f""link_lower_{i}"")
    m.addConstr(f[i] <= 10*z[i], f""link_upper_{i}"")

# Sum of f constraints with u variables
sum_f = gp.quicksum(f[i] for i in range(7))
m.addConstr(sum_f >= 19 - u['u43'], ""sum_f_u43"")
m.addConstr(sum_f >= 42 - u['u52'], ""sum_f_u52"")
m.addConstr(sum_f >= 33 - u['u01'], ""sum_f_u01"")
m.addConstr(sum_f >= 28 - u['u74'], ""sum_f_u74"")
m.addConstr(sum_f >= 30 - u['u14'], ""sum_f_u14"")
m.addConstr(sum_f >= 31 - u['u37'], ""sum_f_u37"")
m.addConstr(sum_f >= 27 - u['u63'], ""sum_f_u63"")
m.addConstr(sum_f >= 13 - u['u25'], ""sum_f_u25"")
m.addConstr(sum_f >= 27 - u['u47'], ""sum_f_u47"")
m.addConstr(sum_f >= 42 - u['u13'], ""sum_f_u13"")
m.addConstr(sum_f >= 42 - u['u71'], ""sum_f_u71"")
m.addConstr(sum_f >= 31 - u['u61'], ""sum_f_u61"")
m.addConstr(sum_f >= 35 - u['u51'], ""sum_f_u51"")
m.addConstr(sum_f >= 39 - u['u31'], ""sum_f_u31"")
m.addConstr(sum_f >= 20 - u['u62'], ""sum_f_u62"")
m.addConstr(sum_f >= 34 - u['u53'], ""sum_f_u53"")
m.addConstr(sum_f >= 39 - u['u21'], ""sum_f_u21"")
m.addConstr(sum_f >= 39 - u['u65'], ""sum_f_u65"")

# y constraints
m.addConstr(y[0] <= z[5], ""y0_z5"")
m.addConstr(z[3] + z[4] + z[6] >= 2*y[1], ""y1"")
m.addConstr(y[2] <= z[0], ""y2_z0"")
m.addConstr(y[3] <= z[1], ""y3_z1"")
m.addConstr(y[4] <= z[2], ""y4_z2"")
m.addConstr(z[2] + z[3] + z[4] + z[5] + z[6] >= 2*y[5], ""y5"")
m.addConstr(y[6] == 0, ""y6_zero"")
m.addConstr(y[7] == 0, ""y7_zero"")

# Optimize
m.optimize()",402943,402943,1,,,,,,,,
"A manufacturing facility produces custom orders for two jobs, Job 0 and Job 1. Each job consists of a sequence of operations that must be performed in a specific order, and some operations require the use of shared machinery. The goal is to schedule these operations to minimize the total production time, or makespan, ensuring all orders are completed as quickly as possible.

Job 0 has three operations: Operation 0, Operation 1, and Operation 2. Operation 1 must start at least 8 units of time after Operation 0 completes, and Operation 2 must start at least 1 unit of time after Operation 1 completes. Job 1 has six operations: Operation 0, Operation 1, Operation 2, Operation 3, Operation 4, and Operation 5. Operation 1 must start at least 5 units of time after Operation 0 completes, Operation 2 must start at least 5 units of time after Operation 1 completes, Operation 3 must start at least 7 units of time after Operation 2 completes, Operation 4 must start at least 4 units of time after Operation 3 completes, and Operation 5 must start at least 2 units of time after Operation 4 completes.

Some operations from both jobs require the use of the same machine, and only one operation can be processed on a machine at any given time. The following pairs of operations share the same machine: Operation 3 and Operation 4 of Job 1, Operation 0 and Operation 1 of Job 0, Operation 0 of Job 0 and Operation 2 of Job 1, and Operation 1 of Job 0 and Operation 2 of Job 1. For each pair of operations sharing a machine, a decision must be made about which operation is processed first. This decision is represented by a binary variable, where a value of 1 indicates that the first operation in the pair is processed before the second, and a value of 0 indicates the opposite.

The primary objective is to minimize the total production time, or makespan, which is defined as the time at which the last operation across all jobs is completed. The makespan must be at least as large as the completion time of every operation in both jobs. Specifically, the makespan must be at least 8 units of time after Operation 0 of Job 0 completes, at least 1 unit of time after Operation 1 of Job 0 completes, at least 4 units of time after Operation 2 of Job 0 completes, at least 5 units of time after Operation 0 of Job 1 completes, at least 5 units of time after Operation 1 of Job 1 completes, at least 7 units of time after Operation 2 of Job 1 completes, at least 4 units of time after Operation 3 of Job 1 completes, at least 2 units of time after Operation 4 of Job 1 completes, and at least 9 units of time after Operation 5 of Job 1 completes.

All operation start times must be non-negative, meaning no operation can start before time zero. For each pair of operations sharing a machine, the following must hold: if Operation A is scheduled before Operation B, then Operation B cannot start until Operation A has been completed, and conversely, if Operation B is scheduled before Operation A, then Operation A cannot start until Operation B has been completed. These constraints are enforced using a large constant (100,000) to ensure that the scheduling logic is maintained. The specific values derived from this constant, such as 99996, 99992, and 99999, are used in the constraints to enforce the sequencing logic.

The task is to determine the optimal schedule for all operations in both jobs, ensuring that all precedence and machine capacity constraints are satisfied, and that the total production time (makespan) is minimized. This involves deciding the order of operations on shared machines and ensuring that all operations are completed as quickly as possible.","\[
\begin{aligned}
\min\quad & C\\
\text{s.t.}\quad
& s_{0,1}\ge s_{0,0}+8\\
& s_{0,2}\ge s_{0,1}+1\\
& s_{1,1}\ge s_{1,0}+5\\
& s_{1,2}\ge s_{1,1}+5\\
& s_{1,3}\ge s_{1,2}+7\\
& s_{1,4}\ge s_{1,3}+4\\
& s_{1,5}\ge s_{1,4}+2\\
& s_{0,1}\ge s_{0,0}-M(1-b_{01})\\
& s_{0,0}\ge s_{0,1}-M\,b_{01}\\
& s_{1,2}\ge s_{0,0}-M(1-b_{0_0_1_2})\\
& s_{0,0}\ge s_{1,2}-M\,b_{0_0_1_2}\\
& s_{1,2}\ge s_{0,1}-M(1-b_{0_1_1_2})\\
& s_{0,1}\ge s_{1,2}-M\,b_{0_1_1_2}\\
& s_{1,4}\ge s_{1,3}-M(1-b_{1_3_4})\\
& s_{1,3}\ge s_{1,4}-M\,b_{1_3_4}\\
& C\ge s_{0,0}+8\\
& C\ge s_{0,1}+1\\
& C\ge s_{0,2}+4\\
& C\ge s_{1,0}+5\\
& C\ge s_{1,1}+5\\
& C\ge s_{1,2}+7\\
& C\ge s_{1,3}+4\\
& C\ge s_{1,4}+2\\
& C\ge s_{1,5}+9\\
& s_{0,0},s_{0,1},s_{0,2},s_{1,0},s_{1,1},s_{1,2},s_{1,3},s_{1,4},s_{1,5},C\ge0\\
& b_{01},b_{0_0_1_2},b_{0_1_1_2},b_{1_3_4}\in\{0,1\}
\end{aligned}
\] where \(M=100000\).","import gurobipy as gp
from gurobipy import GRB

M = 100000

m = gp.Model(""Optimization_Model"")

# Continuous decision variables
s_0_0 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_0_0"")
s_0_1 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_0_1"")
s_0_2 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_0_2"")
s_1_0 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_1_0"")
s_1_1 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_1_1"")
s_1_2 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_1_2"")
s_1_3 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_1_3"")
s_1_4 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_1_4"")
s_1_5 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_1_5"")
C = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""C"")

# Binary decision variables
b_01 = m.addVar(vtype=GRB.BINARY, name=""b_01"")
b_0_0_1_2 = m.addVar(vtype=GRB.BINARY, name=""b_0_0_1_2"")
b_0_1_1_2 = m.addVar(vtype=GRB.BINARY, name=""b_0_1_1_2"")
b_1_3_4 = m.addVar(vtype=GRB.BINARY, name=""b_1_3_4"")

# Objective
m.setObjective(C, GRB.MINIMIZE)

# Constraints
m.addConstr(s_0_1 >= s_0_0 + 8, name=""c1"")
m.addConstr(s_0_2 >= s_0_1 + 1, name=""c2"")
m.addConstr(s_1_1 >= s_1_0 + 5, name=""c3"")
m.addConstr(s_1_2 >= s_1_1 + 5, name=""c4"")
m.addConstr(s_1_3 >= s_1_2 + 7, name=""c5"")
m.addConstr(s_1_4 >= s_1_3 + 4, name=""c6"")
m.addConstr(s_1_5 >= s_1_4 + 2, name=""c7"")

m.addConstr(s_0_1 >= s_0_0 - M * (1 - b_01), name=""c8"")
m.addConstr(s_0_0 >= s_0_1 - M * b_01, name=""c9"")

m.addConstr(s_1_2 >= s_0_0 - M * (1 - b_0_0_1_2), name=""c10"")
m.addConstr(s_0_0 >= s_1_2 - M * b_0_0_1_2, name=""c11"")

m.addConstr(s_1_2 >= s_0_1 - M * (1 - b_0_1_1_2), name=""c12"")
m.addConstr(s_0_1 >= s_1_2 - M * b_0_1_1_2, name=""c13"")

m.addConstr(s_1_4 >= s_1_3 - M * (1 - b_1_3_4), name=""c14"")
m.addConstr(s_1_3 >= s_1_4 - M * b_1_3_4, name=""c15"")

m.addConstr(C >= s_0_0 + 8, name=""c16"")
m.addConstr(C >= s_0_1 + 1, name=""c17"")
m.addConstr(C >= s_0_2 + 4, name=""c18"")
m.addConstr(C >= s_1_0 + 5, name=""c19"")
m.addConstr(C >= s_1_1 + 5, name=""c20"")
m.addConstr(C >= s_1_2 + 7, name=""c21"")
m.addConstr(C >= s_1_3 + 4, name=""c22"")
m.addConstr(C >= s_1_4 + 2, name=""c23"")
m.addConstr(C >= s_1_5 + 9, name=""c24"")

m.optimize()",32,32,1,,,,,,,,
"The problem involves scheduling the landing times of three aircraft (Aircraft 0, Aircraft 1, and Aircraft 2) to minimize the total penalty costs associated with landing early or late. Each aircraft has a target landing time, and the actual landing time must fall within a specified earliest and latest possible landing time window. Aircraft 0 must land between 24 and 84 minutes, Aircraft 1 between 180 and 240 minutes, and Aircraft 2 between 215 and 275 minutes. The penalties for landing early are \$21, \$16, and \$49 per minute for Aircraft 0, 1, and 2, respectively. The penalties for landing late are \$57, \$34, and \$45 per minute for Aircraft 0, 1, and 2, respectively. The target landing times are defined such that Aircraft 0 must land no earlier than 54 minutes, Aircraft 1 no earlier than 210 minutes, and Aircraft 2 no earlier than 245 minutes. 

To ensure safe landings, separation times between aircraft must be maintained based on the order in which they land. Binary variables determine the order of landings between any two aircraft. If Aircraft 0 lands before Aircraft 1, there must be at least 5 minutes between their landings; if Aircraft 1 lands before Aircraft 0, the separation must be at least 96 minutes. If Aircraft 0 lands before Aircraft 2, the separation must be at least 4 minutes; if Aircraft 2 lands before Aircraft 0, the separation must be at least 131 minutes. If Aircraft 1 lands before Aircraft 2, the separation must be at least 5 minutes; if Aircraft 2 lands before Aircraft 1, the separation must be at least 25 minutes. Additionally, if Aircraft 0 lands before Aircraft 1, the separation must be at least 216 minutes; if Aircraft 1 lands before Aircraft 0, the separation must be at least 2 minutes. If Aircraft 0 lands before Aircraft 2, the separation must be at least 251 minutes; if Aircraft 2 lands before Aircraft 0, the separation must be at least 1 minute. If Aircraft 1 lands before Aircraft 2, the separation must be at least 95 minutes; if Aircraft 2 lands before Aircraft 1, the separation must be at least 3 minutes.

The objective is to determine the landing times for each aircraft that minimize the total penalty costs, which are calculated as the sum of the early and late penalties for all aircraft. The early penalty for each aircraft is the number of minutes it lands before its target time multiplied by its early penalty rate, and the late penalty is the number of minutes it lands after its target time multiplied by its late penalty rate. The solution must ensure that all aircraft land within their respective time windows and that the separation times between landings are respected based on the order in which the aircraft land. The decision variables include the actual landing times for each aircraft and binary variables that determine the order of landings between any two aircraft. The goal is to find the optimal landing schedule that minimizes the total penalty costs while satisfying all constraints.","\[
\begin{aligned}
\min\;& 21\,e_0+57\,l_0+16\,e_1+34\,l_1+49\,e_2+45\,l_2 \\[4pt]
\text{s.t.}\;& 24\le t_0\le 84,\\
& 180\le t_1\le 240,\\
& 215\le t_2\le 275,\\
& t_0\ge 54,\; t_1\ge 210,\; t_2\ge 245,\\[4pt]
& e_0\ge 54-t_0,\; e_0\ge 0,\\
& l_0\ge t_0-54,\; l_0\ge 0,\\
& e_1\ge 210-t_1,\; e_1\ge 0,\\
& l_1\ge t_1-210,\; l_1\ge 0,\\
& e_2\ge 245-t_2,\; e_2\ge 0,\\
& l_2\ge t_2-245,\; l_2\ge 0,\\[4pt]
& t_1-t_0\ge 5\,y_{01},\\
& t_0-t_1\ge 96\,y_{10},\\
& t_1-t_0\ge 216\,y_{01},\\
& t_0-t_1\ge 2\,y_{10},\\
& y_{01}+y_{10}=1,\\[4pt]
& t_2-t_0\ge 4\,y_{02},\\
& t_0-t_2\ge 131\,y_{20},\\
& t_2-t_0\ge 251\,y_{02},\\
& t_0-t_2\ge 1\,y_{20},\\
& y_{02}+y_{20}=1,\\[4pt]
& t_2-t_1\ge 5\,y_{12},\\
& t_1-t_2\ge 25\,y_{21},\\
& t_2-t_1\ge 95\,y_{12},\\
& t_1-t_2\ge 3\,y_{21},\\
& y_{12}+y_{21}=1,\\[4pt]
& t_0,t_1,t_2,e_0,e_1,e_2,l_0,l_1,l_2\in\mathbb{R}_+,\\
& y_{01},y_{10},y_{02},y_{20},y_{12},y_{21}\in\{0,1\}.
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Time_Optimization"")

# Decision variables
t0 = m.addVar(lb=54, ub=84, vtype=GRB.CONTINUOUS, name=""t0"")
t1 = m.addVar(lb=210, ub=240, vtype=GRB.CONTINUOUS, name=""t1"")
t2 = m.addVar(lb=245, ub=275, vtype=GRB.CONTINUOUS, name=""t2"")

e0 = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""e0"")
e1 = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""e1"")
e2 = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""e2"")

l0 = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""l0"")
l1 = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""l1"")
l2 = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""l2"")

y01 = m.addVar(vtype=GRB.BINARY, name=""y01"")
y10 = m.addVar(vtype=GRB.BINARY, name=""y10"")
y02 = m.addVar(vtype=GRB.BINARY, name=""y02"")
y20 = m.addVar(vtype=GRB.BINARY, name=""y20"")
y12 = m.addVar(vtype=GRB.BINARY, name=""y12"")
y21 = m.addVar(vtype=GRB.BINARY, name=""y21"")

# Objective
m.setObjective(21*e0 + 57*l0 + 16*e1 + 34*l1 + 49*e2 + 45*l2, GRB.MINIMIZE)

# Constraints
m.addConstr(e0 >= 54 - t0, name=""e0_def"")
m.addConstr(l0 >= t0 - 54, name=""l0_def"")
m.addConstr(e1 >= 210 - t1, name=""e1_def"")
m.addConstr(l1 >= t1 - 210, name=""l1_def"")
m.addConstr(e2 >= 245 - t2, name=""e2_def"")
m.addConstr(l2 >= t2 - 245, name=""l2_def"")

m.addConstr(y01 + y10 == 1, name=""y01_y10"")
m.addConstr(y02 + y20 == 1, name=""y02_y20"")
m.addConstr(y12 + y21 == 1, name=""y12_y21"")

m.addConstr(t1 - t0 >= 5*y01, name=""t1_t0_5y01"")
m.addConstr(t0 - t1 >= 96*y10, name=""t0_t1_96y10"")
m.addConstr(t1 - t0 >= 216*y01, name=""t1_t0_216y01"")
m.addConstr(t0 - t1 >= 2*y10, name=""t0_t1_2y10"")

m.addConstr(t2 - t0 >= 4*y02, name=""t2_t0_4y02"")
m.addConstr(t0 - t2 >= 131*y20, name=""t0_t2_131y20"")
m.addConstr(t2 - t0 >= 251*y02, name=""t2_t0_251y02"")
m.addConstr(t0 - t2 >= 1*y20, name=""t0_t2_1y20"")

m.addConstr(t2 - t1 >= 5*y12, name=""t2_t1_5y12"")
m.addConstr(t1 - t2 >= 25*y21, name=""t1_t2_25y21"")
m.addConstr(t2 - t1 >= 95*y12, name=""t2_t1_95y12"")
m.addConstr(t1 - t2 >= 3*y21, name=""t1_t2_3y21"")

# Optimize
m.optimize()

# Print solution
if m.status == GRB.OPTIMAL:
    print(f""Objective: {m.objVal}"")
    print(f""t0 = {t0.X}, t1 = {t1.X}, t2 = {t2.X}"")
    print(f""e0 = {e0.X}, e1 = {e1.X}, e2 = {e2.X}"")
    print(f""l0 = {l0.X}, l1 = {l1.X}, l2 = {l2.X}"")
    print(f""y01 = {y01.X}, y10 = {y10.X}"")
    print(f""y02 = {y02.X}, y20 = {y20.X}"")
    print(f""y12 = {y12.X}, y21 = {y21.X}"")",,0,1,,,,,,,,
"In a manufacturing facility, you are tasked with scheduling the production of two distinct jobs, Job 0 and Job 1, across a set of machines. Each job consists of a sequence of operations that must be performed in a specific order, and each operation requires a certain amount of time to complete. The goal is to minimize the total production time, known as the makespan, while ensuring that all operations are scheduled without overlapping on the same machine and that the sequence of operations within each job is respected.

Job 0 consists of two operations: Operation 0 takes 5 units of time to complete, and Operation 1 can only start after Operation 0 has finished. The makespan must be at least 5 units of time after the start of Operation 0 and at least 2 units of time after the start of Operation 1.

Job 1 consists of five operations: Operation 0 takes 9 units of time to complete, Operation 1 takes 9 units of time and can only start after Operation 0 has finished, Operation 2 takes 7 units of time and can only start after Operation 1 has finished, Operation 3 takes 2 units of time and can only start after Operation 2 has finished, and Operation 4 takes 8 units of time and can only start after Operation 3 has finished. The makespan must be at least 9 units of time after the start of Operation 0, at least 9 units of time after the start of Operation 1, at least 7 units of time after the start of Operation 2, at least 2 units of time after the start of Operation 3, and at least 8 units of time after the start of Operation 4.

Certain operations from Job 1 must be performed on the same machine, and their scheduling must avoid overlaps. Specifically, Operation 0 and Operation 4 of Job 1 cannot overlap on the same machine. If Operation 0 starts first, Operation 4 must start at least 8 units of time after Operation 0 finishes. Conversely, if Operation 4 starts first, Operation 0 must start at least 9 units of time after Operation 4 finishes. Similarly, Operation 2 and Operation 3 of Job 1 cannot overlap on the same machine. If Operation 2 starts first, Operation 3 must start at least 2 units of time after Operation 2 finishes. Conversely, if Operation 3 starts first, Operation 2 must start at least 7 units of time after Operation 3 finishes.

The primary objective is to minimize the makespan, which is the total time taken to complete all operations across both jobs. The makespan must be at least as long as the completion time of the last operation in either job. All operations must start at or after time 0, and the order of operations within each job must be strictly followed. The scheduling of operations on shared machines must respect the no-overlap constraints described above. Binary variables are used to enforce the no-overlap constraints on the shared machines, ensuring that the operations do not overlap and the sequence constraints are satisfied.","\[
\begin{aligned}
\min\quad & C \\
\text{s.t.}\quad & s_{0,1} \ge s_{0,0} + 5, \\
& s_{1,1} \ge s_{1,0} + 9, \\
& s_{1,2} \ge s_{1,1} + 9, \\
& s_{1,3} \ge s_{1,2} + 7, \\
& s_{1,4} \ge s_{1,3} + 2, \\
& C \ge s_{0,0} + 5, \\
& C \ge s_{0,1} + 2, \\
& C \ge s_{1,0} + 9, \\
& C \ge s_{1,1} + 9, \\
& C \ge s_{1,2} + 7, \\
& C \ge s_{1,3} + 2, \\
& C \ge s_{1,4} + 8, \\
& s_{1,4} \ge s_{1,0} + 17 - 1000(1 - y_{04}), \\
& s_{1,0} \ge s_{1,4} + 17 - 1000\,y_{04}, \\
& s_{1,3} \ge s_{1,2} + 9 - 1000(1 - y_{23}), \\
& s_{1,2} \ge s_{1,3} + 9 - 1000\,y_{23}, \\
& s_{0,0}, s_{0,1}, s_{1,0}, s_{1,1}, s_{1,2}, s_{1,3}, s_{1,4}, C \in \mathbb{R}_+, \\
& y_{04}, y_{23} \in \{0,1\}.
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

m = gp.Model(""Optimization_Model"")

# Decision variables
s_0_0 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_0_0"")
s_0_1 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_0_1"")
s_1_0 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_1_0"")
s_1_1 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_1_1"")
s_1_2 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_1_2"")
s_1_3 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_1_3"")
s_1_4 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_1_4"")
C = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""C"")

y_04 = m.addVar(vtype=GRB.BINARY, name=""y_04"")
y_23 = m.addVar(vtype=GRB.BINARY, name=""y_23"")

# Objective
m.setObjective(C, GRB.MINIMIZE)

# Constraints
m.addConstr(s_0_1 >= s_0_0 + 5, name=""c1"")
m.addConstr(s_1_1 >= s_1_0 + 9, name=""c2"")
m.addConstr(s_1_2 >= s_1_1 + 9, name=""c3"")
m.addConstr(s_1_3 >= s_1_2 + 7, name=""c4"")
m.addConstr(s_1_4 >= s_1_3 + 2, name=""c5"")

m.addConstr(C >= s_0_0 + 5, name=""c6"")
m.addConstr(C >= s_0_1 + 2, name=""c7"")
m.addConstr(C >= s_1_0 + 9, name=""c8"")
m.addConstr(C >= s_1_1 + 9, name=""c9"")
m.addConstr(C >= s_1_2 + 7, name=""c10"")
m.addConstr(C >= s_1_3 + 2, name=""c11"")
m.addConstr(C >= s_1_4 + 8, name=""c12"")

m.addConstr(s_1_4 >= s_1_0 + 17 - 1000*(1 - y_04), name=""c13"")
m.addConstr(s_1_0 >= s_1_4 + 17 - 1000*y_04, name=""c14"")
m.addConstr(s_1_3 >= s_1_2 + 9 - 1000*(1 - y_23), name=""c15"")
m.addConstr(s_1_2 >= s_1_3 + 9 - 1000*y_23, name=""c16"")

# Optimize
m.optimize()",37,35,0,,,,,,,,
"There are two aircraft, **aircraft_0** and **aircraft_1**, that need to be scheduled for landing. The goal is to minimize the total penalty costs associated with deviations from their target landing times. **aircraft_0** must land between 0 and 30 units of time, while **aircraft_1** must land between 128 and 188 units of time. The target landing time for **aircraft_0** is 0 units, and for **aircraft_1**, it is 158 units. Penalties are incurred for deviations from the target times: **aircraft_0** incurs a penalty of 42 units per unit time for landing early and 32 units per unit time for landing late, while **aircraft_1** incurs a penalty of 62 units per unit time for landing early and 55 units per unit time for landing late.

To ensure safety, a minimum separation time must be maintained between the landings of the two aircraft. If **aircraft_0** lands before **aircraft_1**, there must be at least 3 units of separation time. If **aircraft_1** lands before **aircraft_0**, there must be at least 98 units of separation time. The order of landings is determined by binary variables **AircraftOrder[aircraft_0,aircraft_1]** and **AircraftOrder[aircraft_1,aircraft_0]**, which are mutually exclusive and must sum to 1. The landing times must respect the separation requirements based on the landing order, and each aircraft must land within its specified time window.

The early and late deviations for each aircraft are calculated based on the difference between the actual landing time and the target time. For **aircraft_0**, the early deviation is non-negative, and the late deviation is non-negative. For **aircraft_1**, the early deviation is calculated as the difference between the target time and the actual landing time, and the late deviation is calculated as the difference between the actual landing time and the target time. The objective is to minimize the total penalty costs, which are calculated as the sum of the penalties for early and late deviations for both aircraft.","\[
\begin{aligned}
\min \quad & 42\,e_0 + 32\,l_0 + 62\,e_1 + 55\,l_1 \\[4pt]
\text{s.t.}\quad
& 0 \le t_0 \le 30, \\
& 128 \le t_1 \le 188, \\[4pt]
& e_0 \ge 0 - t_0, \\
& l_0 \ge t_0, \\
& e_0 \ge 0,\; l_0 \ge 0, \\[4pt]
& e_1 \ge 158 - t_1, \\
& l_1 \ge t_1 - 158, \\
& e_1 \ge 0,\; l_1 \ge 0, \\[4pt]
& e_1 \le 200\,y_1, \\
& l_1 \le 200\,(1-y_1), \\[4pt]
& o_{01} + o_{10} = 1, \\[4pt]
& t_1 - t_0 \ge 3 - 200\,(1-o_{01}), \\
& t_0 - t_1 \ge 98 - 200\,(1-o_{10}), \\[4pt]
& o_{01},\,o_{10},\,y_1 \in \{0,1\}, \\[4pt]
& t_0,\,t_1,\,e_0,\,l_0,\,e_1,\,l_1 \in \mathbb{R}_+ .
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

m = gp.Model(""Optimization_Model"")

# Continuous variables
t0 = m.addVar(lb=0, ub=30, name=""t0"")
t1 = m.addVar(lb=128, ub=188, name=""t1"")
e0 = m.addVar(lb=0, name=""e0"")
l0 = m.addVar(lb=0, name=""l0"")
e1 = m.addVar(lb=0, name=""e1"")
l1 = m.addVar(lb=0, name=""l1"")

# Binary variables
o01 = m.addVar(vtype=GRB.BINARY, name=""o01"")
o10 = m.addVar(vtype=GRB.BINARY, name=""o10"")
y1 = m.addVar(vtype=GRB.BINARY, name=""y1"")

# Objective
m.setObjective(42*e0 + 32*l0 + 62*e1 + 55*l1, GRB.MINIMIZE)

# Constraints
m.addConstr(e0 >= -t0, name=""e0_lower"")
m.addConstr(l0 >= t0, name=""l0_lower"")
m.addConstr(e1 >= 158 - t1, name=""e1_lower"")
m.addConstr(l1 >= t1 - 158, name=""l1_lower"")
m.addConstr(e1 <= 200*y1, name=""e1_upper"")
m.addConstr(l1 <= 200*(1-y1), name=""l1_upper"")
m.addConstr(o01 + o10 == 1, name=""o_sum"")
m.addConstr(t1 - t0 >= 3 - 200*(1-o01), name=""t1_t0_o01"")
m.addConstr(t0 - t1 >= 98 - 200*(1-o10), name=""t0_t1_o10"")

# Solve
m.optimize()

# Results
if m.status == GRB.OPTIMAL:
    print(f""Optimal objective: {m.objVal}"")
    print(f""t0 = {t0.X}"")
    print(f""t1 = {t1.X}"")
    print(f""e0 = {e0.X}"")
    print(f""l0 = {l0.X}"")
    print(f""e1 = {e1.X}"")
    print(f""l1 = {l1.X}"")
    print(f""o01 = {o01.X}"")
    print(f""o10 = {o10.X}"")
    print(f""y1 = {y1.X}"")",2572,0,0,,,,,,,,
"The manufacturing facility produces custom parts for two jobs, Job 0 and Job 1, each with a sequence of operations that must follow specific precedence constraints. Job 0 has two operations: Operation 0 must start at least 2 hours before Operation 1 begins. Job 1 has five operations: Operation 1 must start at least 4 hours after Operation 0 begins, Operation 2 must start at least 2 hours after Operation 1 completes, Operation 3 must start at least 1 hour after Operation 2 completes, and Operation 4 must start at least 3 hours after Operation 3 completes. 

Operations from different jobs share machines: Operation 0 of Job 0 and Operation 0 of Job 1 share a machine, Operation 0 of Job 0 and Operation 1 of Job 1 share a machine, Operation 0 of Job 1 and Operation 1 of Job 1 share a machine, and Operation 2 of Job 1 and Operation 4 of Job 1 share a machine. To prevent overlapping, binary variables determine the order of operations on shared machines. If Operation A is scheduled before Operation B on a shared machine, the binary variable is 1; otherwise, it is 0. 

The objective is to minimize the makespan, the total completion time for all operations. The makespan must be at least as large as the completion time of the last operation in either job. Constraints ensure that operations within the same job follow their precedence requirements and that operations sharing a machine do not overlap. For example, if Operation 0 of Job 0 is scheduled before Operation 0 of Job 1, Operation 0 of Job 1 must start at least 4 hours after Operation 0 of Job 0 begins. Similarly, if Operation 2 of Job 1 is scheduled before Operation 4 of Job 1, Operation 4 of Job 1 must start at least 7 hours after Operation 2 of Job 1 begins. 

The makespan accounts for the completion times of all operations: Operation 0 of Job 0 contributes at least 2 hours, Operation 1 of Job 0 contributes at least 4 hours, Operation 0 of Job 1 contributes at least 4 hours, Operation 1 of Job 1 contributes at least 2 hours, Operation 2 of Job 1 contributes at least 1 hour, Operation 3 of Job 1 contributes at least 3 hours, and Operation 4 of Job 1 contributes at least 7 hours. All operation start times must be non-negative, and the binary variables determining the order of operations on shared machines must be either 0 or 1. The goal is to determine the optimal schedule for all operations across both jobs, ensuring all constraints are met while minimizing the makespan.","\[
\begin{aligned}
\min \quad & C \\[4pt]
\text{s.t.}\quad
& s_{0,0}\ge 0,\; s_{0,1}\ge 0,\; s_{1,0}\ge 0,\; s_{1,1}\ge 0,\; s_{1,2}\ge 0,\; s_{1,3}\ge 0,\; s_{1,4}\ge 0,\; C\ge 0,\\[4pt]
& s_{0,1}\ge s_{0,0}+2,\\
& s_{1,1}\ge s_{1,0}+4,\\
& s_{1,2}\ge s_{1,1}+4,\\
& s_{1,3}\ge s_{1,2}+2,\\
& s_{1,4}\ge s_{1,3}+6,\\[4pt]
& s_{1,0}\ge s_{0,0}+4-M(1-b_{01}),\\
& s_{0,0}\ge s_{1,0}+4-Mb_{01},\\
& s_{1,1}\ge s_{0,0}+4-M(1-b_{02}),\\
& s_{0,0}\ge s_{1,1}+4-Mb_{02},\\
& s_{1,1}\ge s_{1,0}+4-M(1-b_{13}),\\
& s_{1,0}\ge s_{1,1}+4-Mb_{13},\\
& s_{1,4}\ge s_{1,2}+7-M(1-b_{24}),\\
& s_{1,2}\ge s_{1,4}+7-Mb_{24},\\[4pt]
& C\ge s_{0,0}+2,\\
& C\ge s_{0,1}+4,\\
& C\ge s_{1,0}+4,\\
& C\ge s_{1,1}+2,\\
& C\ge s_{1,2}+1,\\
& C\ge s_{1,3}+3,\\
& C\ge s_{1,4}+7,
\end{aligned}
\]  
where $M=100$ and  
\[
s_{0,0},s_{0,1},s_{1,0},s_{1,1},s_{1,2},s_{1,3},s_{1,4},C\in\mathbb{R}_{+},\qquad
b_{01},b_{02},b_{13},b_{24}\in\{0,1\}.
\]","import gurobipy as gp
from gurobipy import GRB

m = gp.Model(""Scheduling"")

# Continuous decision variables
s_00 = m.addVar(lb=0, name=""s_00"")
s_01 = m.addVar(lb=0, name=""s_01"")
s_10 = m.addVar(lb=0, name=""s_10"")
s_11 = m.addVar(lb=0, name=""s_11"")
s_12 = m.addVar(lb=0, name=""s_12"")
s_13 = m.addVar(lb=0, name=""s_13"")
s_14 = m.addVar(lb=0, name=""s_14"")
C    = m.addVar(lb=0, name=""C"")

# Binary decision variables
b01 = m.addVar(vtype=GRB.BINARY, name=""b01"")
b02 = m.addVar(vtype=GRB.BINARY, name=""b02"")
b13 = m.addVar(vtype=GRB.BINARY, name=""b13"")
b24 = m.addVar(vtype=GRB.BINARY, name=""b24"")

M = 100

# Objective: minimize C
m.setObjective(C, GRB.MINIMIZE)

# Constraints
m.addConstr(s_01 >= s_00 + 2, name=""c1"")
m.addConstr(s_11 >= s_10 + 4, name=""c2"")
m.addConstr(s_12 >= s_11 + 4, name=""c3"")
m.addConstr(s_13 >= s_12 + 2, name=""c4"")
m.addConstr(s_14 >= s_13 + 6, name=""c5"")

m.addConstr(s_10 >= s_00 + 4 - M*(1-b01), name=""c6"")
m.addConstr(s_00 >= s_10 + 4 - M*b01, name=""c7"")
m.addConstr(s_11 >= s_00 + 4 - M*(1-b02), name=""c8"")
m.addConstr(s_00 >= s_11 + 4 - M*b02, name=""c9"")
m.addConstr(s_11 >= s_10 + 4 - M*(1-b13), name=""c10"")
m.addConstr(s_10 >= s_11 + 4 - M*b13, name=""c11"")
m.addConstr(s_14 >= s_12 + 7 - M*(1-b24), name=""c12"")
m.addConstr(s_12 >= s_14 + 7 - M*b24, name=""c13"")

m.addConstr(C >= s_00 + 2, name=""c14"")
m.addConstr(C >= s_01 + 4, name=""c15"")
m.addConstr(C >= s_10 + 4, name=""c16"")
m.addConstr(C >= s_11 + 2, name=""c17"")
m.addConstr(C >= s_12 + 1, name=""c18"")
m.addConstr(C >= s_13 + 3, name=""c19"")
m.addConstr(C >= s_14 + 7, name=""c20"")

# Solve the model
m.optimize()",23,17,0,,,,,,,,
"The problem involves scheduling four jobs (Job 0, Job 1, Job 2, and Job 3) on a set of machines to minimize the total completion time (makespan). Each job consists of a sequence of operations, and each operation must be processed on a specific machine with a given processing time. Job 0 has two operations: Operation 0 takes 2 units of time, and Operation 1 takes 3 units of time. Job 1 has five operations: Operation 0 takes 8 units of time, Operation 1 takes 7 units of time, Operation 2 takes 4 units of time, Operation 3 takes 3 units of time, and Operation 4 takes 2 units of time. Job 2 has five operations: Operation 0 takes 8 units of time, Operation 1 takes 3 units of time, Operation 2 takes 7 units of time, Operation 3 takes 8 units of time, and Operation 4 takes 4 units of time. Job 3 has seven operations: Operation 0 takes 6 units of time, Operation 1 takes 4 units of time, Operation 2 takes 7 units of time, Operation 3 takes 6 units of time, Operation 4 takes 2 units of time, Operation 5 takes 8 units of time, and Operation 6 takes 9 units of time.

Each operation in a job must start only after the previous operation in the same job has completed. For example, in Job 1, Operation 1 cannot start until Operation 0 has finished, and in Job 3, Operation 6 cannot start until Operation 5 has finished. No two operations can be processed on the same machine at the same time. For example, if Operation 3 of Job 1 and Operation 4 of Job 2 are assigned to the same machine, they cannot overlap, and the start time of one must be at least 4 units after the other, depending on the order in which they are scheduled. Similarly, Operation 1 of Job 1 and Operation 2 of Job 3 cannot overlap on the same machine, and the start time of one must be at least 7 units after the other.

The total completion time (makespan) must be at least as large as the completion time of every operation. For example, the makespan must be at least 2 units to account for the completion of Operation 0 in Job 0, and it must also be at least 9 units to account for the completion of Operation 6 in Job 3. The objective is to minimize the makespan, which involves determining the start times for each operation on each machine while respecting the precedence and machine capacity constraints. All start times must be non-negative, and the order of operations on each machine is determined by binary decision variables, which decide whether one operation starts before another on the same machine. A large constant (100000) is used in the machine capacity constraints to ensure that the constraints are only active when the binary variable is 1 or 0.

The binary decision variables, such as \(X_{(1,3)(2,4)}\), \(X_{(1,3)(3,0)}\), and others, determine the order of operations on the same machine. For example, \(X_{(1,3)(2,4)}\) decides whether Operation 3 of Job 1 starts before Operation 4 of Job 2 on the same machine. The constraints involving these binary variables ensure that the start times of operations on the same machine do not overlap. The start times \(S_{(i,j)}\) and the makespan \(C_{\text{max}}\) are general variables that can take non-negative real values. The precedence constraints between operations of different jobs on the same machine, such as those involving \(S_{(1,3)}\), \(S_{(2,4)}\), and \(S_{(3,0)}\), are explicitly enforced to ensure that the operations are scheduled in a feasible order.","\[
\begin{aligned}
\min\quad & C_{\max} \\[4pt]
\text{s.t.}\quad
& S_{i,j}\;\ge\;0 && \forall i\in\{0,1,2,3\},\; j\in\{0,\dots,O_i-1\} \\[4pt]
& C_{\max}\;\ge\;S_{i,j}+p_{i,j} && \forall i\in\{0,1,2,3\},\; j\in\{0,\dots,O_i-1\} \\[4pt]
& S_{i,j}\;\ge\;S_{i,j-1}+p_{i,j-1} && \forall i\in\{0,1,2,3\},\; j=1,\dots,O_i-1 \\[4pt]
& S_{i_1,j_1}+p_{i_1,j_1}\;\le\;S_{i_2,j_2}+M\bigl(1-X_{(i_1,j_1),(i_2,j_2)}\bigr)+M\bigl(1-a_{(i_1,j_1),(i_2,j_2)}\bigr) && \forall (i_1,j_1)\neq(i_2,j_2) \\[4pt]
& S_{i_2,j_2}+p_{i_2,j_2}\;\le\;S_{i_1,j_1}+M\,X_{(i_1,j_1),(i_2,j_2)}+M\bigl(1-a_{(i_1,j_1),(i_2,j_2)}\bigr) && \forall (i_1,j_1)\neq(i_2,j_2) \\[4pt]
& X_{(i_1,j_1),(i_2,j_2)}\in\{0,1\} && \forall (i_1,j_1)\neq(i_2,j_2) \\[4pt]
& S_{i,j}\in\mathbb{R}_+,\; C_{\max}\in\mathbb{R}_+ && \forall i\in\{0,1,2,3\},\; j\in\{0,\dots,O_i-1\}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Example data: processing times p[i][j] for machine i and operation j
p = [
    [2, 3, 1],      # machine 0 has 3 operations
    [4, 2],         # machine 1 has 2 operations
    [3, 5, 2, 4],   # machine 2 has 4 operations
    [6]             # machine 3 has 1 operation
]
O = [len(p[i]) for i in range(len(p))]          # number of operations per machine
M = sum(sum(p[i]) for i in range(len(p))) + 1   # big-M

# Create model
m = gp.Model(""Scheduling"")

# Decision variables: start times S[i,j] and makespan C_max
S = {}
for i in range(len(p)):
    for j in range(O[i]):
        S[i, j] = m.addVar(lb=0, name=f""S_{i}_{j}"")
C_max = m.addVar(lb=0, name=""C_max"")

# Objective: minimize makespan
m.setObjective(C_max, GRB.MINIMIZE)

# Constraints
# 1. C_max >= S[i,j] + p[i,j]
for i in range(len(p)):
    for j in range(O[i]):
        m.addConstr(C_max >= S[i, j] + p[i][j], name=f""makespan_{i}_{j}"")

# 2. Sequential constraints on same machine
for i in range(len(p)):
    for j in range(1, O[i]):
        m.addConstr(S[i, j] >= S[i, j-1] + p[i][j-1], name=f""seq_{i}_{j}"")

# 3. Disjunctive constraints for operations on the same machine
#    Introduce binary variables X[(i,j1),(i,j2)] for j1<j2
X = {}
for i in range(len(p)):
    for j1 in range(O[i]):
        for j2 in range(j1+1, O[i]):
            X[i, j1, j2] = m.addVar(vtype=GRB.BINARY, name=f""X_{i}_{j1}_{j2}"")

#    Add ordering constraints
for i in range(len(p)):
    for j1 in range(O[i]):
        for j2 in range(j1+1, O[i]):
            # S[j1] + p[j1] <= S[j2] + M*(1 - X)
            m.addConstr(S[i, j1] + p[i][j1] <= S[i, j2] + M * (1 - X[i, j1, j2]),
                        name=f""order1_{i}_{j1}_{j2}"")
            # S[j2] + p[j2] <= S[j1] + M*X
            m.addConstr(S[i, j2] + p[i][j2] <= S[i, j1] + M * X[i, j1, j2],
                        name=f""order2_{i}_{j1}_{j2}"")

# Optimize
m.optimize()
```",14,42,0,,,,,,,,
"The problem involves scheduling the landing times of six aircraft at a busy airport to minimize the total penalty costs associated with deviations from their target landing times while ensuring safe separation between landings. Each aircraft has a target landing time, earliest and latest possible landing times, and penalty costs for landing early or late. The landing times must fall within the specified bounds for each aircraft: Aircraft 0 between 8 and 68 minutes, Aircraft 1 between 46 and 106 minutes, Aircraft 2 between 90 and 150 minutes, Aircraft 3 between 16 and 76 minutes, Aircraft 4 between 0 and 57 minutes, and Aircraft 5 between 39 and 99 minutes. The penalties are calculated based on the deviation from the target landing times, with specific costs per minute for early or late landings: 55 for early landing of Aircraft 0, 94 for Aircraft 1, 61 for Aircraft 2, 64 for Aircraft 3, 74 for Aircraft 4, and 84 for Aircraft 5; and 38 for late landing of Aircraft 0, 81 for Aircraft 1, 71 for Aircraft 2, 80 for Aircraft 3, 53 for Aircraft 4, and 84 for Aircraft 5. The binary decision variables ensure that for each pair of aircraft, one lands before the other, and the separation times are enforced based on the landing order. The separation constraints include specific times such as 22 minutes between Aircraft 0 and 1, 22 minutes between Aircraft 0 and 2, 5 minutes between Aircraft 0 and 3, 3 minutes between Aircraft 0 and 4, 3 minutes between Aircraft 0 and 5, 4 minutes between Aircraft 1 and 2, 3 minutes between Aircraft 1 and 3, 1 minute between Aircraft 1 and 4, 5 minutes between Aircraft 1 and 5, 2 minutes between Aircraft 2 and 3, 1 minute between Aircraft 2 and 4, 5 minutes between Aircraft 2 and 5, 5 minutes between Aircraft 3 and 4, 3 minutes between Aircraft 3 and 5, and 5 minutes between Aircraft 4 and 5. The goal is to determine the actual landing times for all six aircraft such that the total penalty cost is minimized, and all separation and landing time constraints are satisfied. The binary decision variables `AircraftOrder[i,j]` are used to determine the landing order, and the constraints involving `Early` and `Late` variables ensure that the landing times are within the acceptable deviations from the target times. The target landing times for each aircraft are implied by the constraints involving `Early` and `Late` variables, and the `AircraftOrder` variables are binary, ensuring that one aircraft lands before the other in each pair. The relationship between the separation constraints and the binary decision variables is essential for understanding the problem structure.","\[
\begin{aligned}
\text{minimize}\quad & \sum_{i=0}^{5}\bigl(e_i\,\text{Early}_i + l_i\,\text{Late}_i\bigr)\\[4pt]
\text{subject to}\quad
& L_i \;\le\; t_i \;\le\; U_i &&\forall i=0,\dots,5\\
& \text{Early}_i \;\ge\; T_i - t_i &&\forall i\\
& \text{Late}_i \;\ge\; t_i - T_i &&\forall i\\
& \text{Early}_i,\;\text{Late}_i \;\ge\; 0 &&\forall i\\[4pt]
& t_j \;\ge\; t_i + s_{ij} - M\bigl(1-\text{AircraftOrder}_{ij}\bigr) &&\forall\,i<j\\
& t_i \;\ge\; t_j + s_{ij} - M\,\text{AircraftOrder}_{ij} &&\forall\,i<j\\[4pt]
& \text{AircraftOrder}_{ij}\;\in\{0,1\} &&\forall\,i<j
\end{aligned}
\]

\[
\begin{aligned}
&\text{Parameters:}\\
&e = (55,94,61,64,74,84),\quad l = (38,81,71,80,53,84),\\
&L = (8,46,90,16,0,39),\quad U = (68,106,150,76,57,99),\\
&s_{01}=22,\; s_{02}=22,\; s_{03}=5,\; s_{04}=3,\; s_{05}=3,\\
&s_{12}=4,\; s_{13}=3,\; s_{14}=1,\; s_{15}=5,\\
&s_{23}=2,\; s_{24}=1,\; s_{25}=5,\\
&s_{34}=5,\; s_{35}=3,\; s_{45}=5,\\
&M=200.
\end{aligned}
\]

\[
\begin{aligned}
&\text{Decision variables:}\\
&t_i\in\mathbb{R},\quad \text{Early}_i,\;\text{Late}_i\in\mathbb{R}_+,\quad 
\text{AircraftOrder}_{ij}\in\{0,1\}\;\;\forall\,i<j.
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Parameters
e = [55,94,61,64,74,84]
l = [38,81,71,80,53,84]
L = [8,46,90,16,0,39]
U = [68,106,150,76,57,99]
s = {(0,1):22,(0,2):22,(0,3):5,(0,4):3,(0,5):3,
     (1,2):4,(1,3):3,(1,4):1,(1,5):5,
     (2,3):2,(2,4):1,(2,5):5,
     (3,4):5,(3,5):3,
     (4,5):5}
M = 200
n = 6

# Create model
m = gp.Model(""Aircraft_Scheduling"")

# Decision variables
t = m.addVars(n, lb=0, name=""t"")
early = m.addVars(n, lb=0, name=""Early"")
late = m.addVars(n, lb=0, name=""Late"")
order = m.addVars(n, n, vtype=GRB.BINARY, name=""Order"")

# Objective: minimize weighted sum of early and late penalties
m.setObjective(gp.quicksum(e[i]*early[i] + l[i]*late[i] for i in range(n)), GRB.MINIMIZE)

# Time window constraints
for i in range(n):
    m.addConstr(t[i] >= L[i], name=f""time_lower_{i}"")
    m.addConstr(t[i] <= U[i], name=f""time_upper_{i}"")

# Early/Late constraints
for i in range(n):
    m.addConstr(early[i] >= L[i] - t[i], name=f""early_ge_{i}"")
    m.addConstr(late[i]  >= t[i] - U[i], name=f""late_ge_{i}"")

# Aircraft order constraints (i < j)
for i in range(n):
    for j in range(i+1, n):
        sij = s[(i,j)]
        m.addConstr(t[j] >= t[i] + sij - M*(1-order[i,j]), name=f""order1_{i}_{j}"")
        m.addConstr(t[i] >= t[j] + sij - M*order[i,j], name=f""order2_{i}_{j}"")

# Solve
m.optimize()",0,0,1,,,,,,,,
"The problem involves scheduling the landing times of three aircraft (aircraft_0, aircraft_1, and aircraft_2) to minimize the total penalty costs associated with deviations from their target landing times. Each aircraft has specific time windows within which it must land: aircraft_0 must land between 19 and 79 minutes, aircraft_1 between 58 and 118 minutes, and aircraft_2 between 205 and 265 minutes. The penalties for landing early or late are as follows: aircraft_0 incurs a penalty of 58 units per minute early and 57 units per minute late, aircraft_1 incurs 25 units per minute early and 61 units per minute late, and aircraft_2 incurs 37 units per minute early and 70 units per minute late.

The landing sequence between any two aircraft is determined by binary variables, where a value of 1 indicates that one aircraft lands before the other. The constraints ensure that the landing times respect the sequence and separation requirements. For example, if aircraft_0 lands before aircraft_1, there must be at least 4 minutes of separation, but if aircraft_1 lands before aircraft_0, the required separation is 21 minutes. Similarly, if aircraft_0 lands before aircraft_2, the separation must be at least 12 minutes, but if aircraft_2 lands before aircraft_0, the separation must be at least 126 minutes. For aircraft_1 and aircraft_2, the separation is at least 13 minutes if aircraft_1 lands first, and at least 87 minutes if aircraft_2 lands first.

The objective is to minimize the total penalty costs, which include the penalties for early and late landings for all three aircraft. The constraints ensure that each aircraft lands within its specified time window, the landing sequence respects the separation requirements, and the binary variables enforce the correct sequence between aircraft pairs. The penalties for early or late landings are calculated based on the deviation from the target landing times, which are implicitly defined by the constraints on the landing times and the penalties. Specifically, the constraints ensure that the landing time of aircraft_0 plus the early penalty for aircraft_0 is at least 49 minutes, and the landing time of aircraft_0 minus the late penalty for aircraft_0 is at most 49 minutes. Similarly, the landing time of aircraft_1 plus the early penalty for aircraft_1 is at least 88 minutes, and the landing time of aircraft_1 minus the late penalty for aircraft_1 is at most 88 minutes. For aircraft_2, the landing time plus the early penalty is at least 235 minutes, and the landing time minus the late penalty is at most 235 minutes. These constraints ensure that the penalties are correctly calculated based on the deviation from the target landing times.","\[
\begin{aligned}
\min \quad & 58\,e_0 + 57\,l_0 + 25\,e_1 + 61\,l_1 + 37\,e_2 + 70\,l_2 \\[4pt]
\text{s.t.}\quad
& 19 \le t_0 \le 79,\\
& 58 \le t_1 \le 118,\\
& 205 \le t_2 \le 265,\\[4pt]
& t_0 + e_0 \ge 49,\\
& t_0 - l_0 \le 49,\\
& t_1 + e_1 \ge 88,\\
& t_1 - l_1 \le 88,\\
& t_2 + e_2 \ge 235,\\
& t_2 - l_2 \le 235,\\[4pt]
& t_0 + 4 \le t_1 + 1000(1-s_{01}),\\
& t_1 + 21 \le t_0 + 1000\,s_{01},\\
& t_0 + 12 \le t_2 + 1000(1-s_{02}),\\
& t_2 + 126 \le t_0 + 1000\,s_{02},\\
& t_1 + 13 \le t_2 + 1000(1-s_{12}),\\
& t_2 + 87 \le t_1 + 1000\,s_{12},\\[4pt]
& e_0,l_0,e_1,l_1,e_2,l_2 \ge 0,\\
& t_0,t_1,t_2 \in \mathbb{R},\\
& s_{01},s_{02},s_{12} \in \{0,1\}.
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

m = gp.Model(""Scheduling_Optimization"")

# Decision variables
e0 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""e0"")
l0 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""l0"")
e1 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""e1"")
l1 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""l1"")
e2 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""e2"")
l2 = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""l2"")

t0 = m.addVar(vtype=GRB.CONTINUOUS, name=""t0"")
t1 = m.addVar(vtype=GRB.CONTINUOUS, name=""t1"")
t2 = m.addVar(vtype=GRB.CONTINUOUS, name=""t2"")

s01 = m.addVar(vtype=GRB.BINARY, name=""s01"")
s02 = m.addVar(vtype=GRB.BINARY, name=""s02"")
s12 = m.addVar(vtype=GRB.BINARY, name=""s12"")

# Bounds on t
m.addConstr(t0 >= 19, name=""t0_lb"")
m.addConstr(t0 <= 79, name=""t0_ub"")
m.addConstr(t1 >= 58, name=""t1_lb"")
m.addConstr(t1 <= 118, name=""t1_ub"")
m.addConstr(t2 >= 205, name=""t2_lb"")
m.addConstr(t2 <= 265, name=""t2_ub"")

# Linking constraints
m.addConstr(t0 + e0 >= 49, name=""t0_e0"")
m.addConstr(t0 - l0 <= 49, name=""t0_l0"")
m.addConstr(t1 + e1 >= 88, name=""t1_e1"")
m.addConstr(t1 - l1 <= 88, name=""t1_l1"")
m.addConstr(t2 + e2 >= 235, name=""t2_e2"")
m.addConstr(t2 - l2 <= 235, name=""t2_l2"")

# Big-M ordering constraints
M = 1000
m.addConstr(t0 + 4 <= t1 + M*(1-s01), name=""order_t0_t1_s01"")
m.addConstr(t1 + 21 <= t0 + M*s01, name=""order_t1_t0_s01"")
m.addConstr(t0 + 12 <= t2 + M*(1-s02), name=""order_t0_t2_s02"")
m.addConstr(t2 + 126 <= t0 + M*s02, name=""order_t2_t0_s02"")
m.addConstr(t1 + 13 <= t2 + M*(1-s12), name=""order_t1_t2_s12"")
m.addConstr(t2 + 87 <= t1 + M*s12, name=""order_t2_t1_s12"")

# Objective
m.setObjective(58*e0 + 57*l0 + 25*e1 + 61*l1 + 37*e2 + 70*l2, GRB.MINIMIZE)

# Optimize
m.optimize()

# Print solution
if m.status == GRB.OPTIMAL:
    print(f""Optimal objective: {m.objVal}"")
    print(f""t0={t0.X}, t1={t1.X}, t2={t2.X}"")
    print(f""e0={e0.X}, l0={l0.X}, e1={e1.X}, l1={l1.X}, e2={e2.X}, l2={l2.X}"")
    print(f""s01={s01.X}, s02={s02.X}, s12={s12.X}"")",0,0,1,,,,,,,,
"The problem involves scheduling the landing times of five aircraft to minimize the total penalty costs associated with deviations from their target landing times, while ensuring that each aircraft lands within its specified time window and that the required separation times between consecutive landings are maintained. Each aircraft has a target landing time, an earliest possible landing time, and a latest possible landing time. Aircraft 0 must land between 178 and 238, aircraft 1 between 35 and 95, aircraft 2 between 266 and 300, aircraft 3 between 0 and 40, and aircraft 4 between 69 and 129. Penalties are incurred for landing early or late, with specific costs per unit time for each aircraft: aircraft 0 has an early penalty of 62 and a late penalty of 82, aircraft 1 has an early penalty of 10 and a late penalty of 65, aircraft 2 has an early penalty of 89 and a late penalty of 72, aircraft 3 has an early penalty of 81 and a late penalty of 69, and aircraft 4 has an early penalty of 50 and a late penalty of 42. The separation requirements between aircraft depend on the order in which they land, and these requirements are enforced using binary decision variables that determine the landing sequence. The separation times are as follows: between aircraft 0 and 1, the required separation is 203 if 0 lands before 1 and 3 if 1 lands before 0; between aircraft 0 and 2, the required separation is 2 if 0 lands before 2 and 28 if 2 lands before 0; between aircraft 0 and 3, the required separation is 4 if 0 lands before 3 and 238 if 3 lands before 0; between aircraft 0 and 4, the required separation is 5 if 0 lands before 4 and 169 if 4 lands before 0; between aircraft 1 and 2, the required separation is 3 if 1 lands before 2 and 171 if 2 lands before 1; between aircraft 1 and 3, the required separation is 2 if 1 lands before 3 and 95 if 3 lands before 1; between aircraft 1 and 4, the required separation is 4 if 1 lands before 4 and 26 if 4 lands before 1; between aircraft 2 and 3, the required separation is 5 if 2 lands before 3 and 300 if 3 lands before 2; between aircraft 2 and 4, the required separation is 2 if 2 lands before 4 and 231 if 4 lands before 2; between aircraft 3 and 4, the required separation is 5 if 3 lands before 4 and 29 if 4 lands before 3. The objective is to minimize the sum of the penalties for early and late landings across all aircraft. The constraints include ensuring that each aircraft lands within its time window, enforcing the separation times based on the landing order, and calculating the penalties for deviations from the target landing times. The binary decision variables ensure that only one of the two possible orders between any pair of aircraft is chosen, and the separation constraints are applied accordingly. The landing times must also satisfy bounds that are specific to each aircraft. The penalties are calculated based on the difference between the actual landing time and the target landing time, with separate variables for early and late deviations. The goal is to find the optimal landing times and sequence that minimize the total penalty costs while satisfying all constraints.","\[
\begin{aligned}
\min \quad & \sum_{i=0}^{4}\bigl(e_i\,\text{early}_i + l_i\,\text{late}_i\bigr) \\[4pt]
\text{s.t.}\quad
& \text{earliest}_i \;\le\; t_i \;\le\; \text{latest}_i && \forall i=0,\dots,4 \\[4pt]
& \text{early}_i \;\ge\; T_i - t_i && \forall i=0,\dots,4 \\[4pt]
& \text{late}_i \;\ge\; t_i - T_i && \forall i=0,\dots,4 \\[4pt]
& \text{early}_i \;\ge\; 0,\;\; \text{late}_i \;\ge\; 0 && \forall i=0,\dots,4 \\[4pt]
& t_j - t_i \;\ge\; \text{sep}_{ij} - M\,(1-y_{ij}) && \forall\,0\le i<j\le4 \\[4pt]
& t_i - t_j \;\ge\; \text{sep}_{ji} - M\,y_{ij} && \forall\,0\le i<j\le4 \\[4pt]
& y_{ij}\in\{0,1\} && \forall\,0\le i<j\le4 \\[4pt]
& t_i,\;\text{early}_i,\;\text{late}_i \in \mathbb{R}_+ && \forall i=0,\dots,4
\end{aligned}
\]

\[
\begin{array}{l}
\text{Parameters:}\\
T_i\;(i=0,\dots,4):\text{ target landing times}\\
e_i\;(i=0,\dots,4):\text{ early penalty per unit time}\\
l_i\;(i=0,\dots,4):\text{ late penalty per unit time}\\
\text{earliest}_i,\;\text{latest}_i\;(i=0,\dots,4):\text{ time windows}\\
\text{sep}_{ij},\;\text{sep}_{ji}\;(0\le i<j\le4):\text{ required separations}\\
M=1000\;\text{(big constant)}
\end{array}
\]","import gurobipy as gp
from gurobipy import GRB

# Parameters
T = [10, 12, 15, 18, 20]          # target landing times
e = [2, 3, 1, 4, 2]               # early penalty per unit time
l = [3, 2, 5, 1, 4]               # late penalty per unit time
earliest = [8, 10, 13, 16, 18]    # earliest allowed landing times
latest   = [12, 14, 17, 20, 22]   # latest allowed landing times
sep_ij = [[0, 2, 3, 4, 5],
          [0, 0, 2, 3, 4],
          [0, 0, 0, 2, 3],
          [0, 0, 0, 0, 2],
          [0, 0, 0, 0, 0]]
sep_ji = [[0, 2, 3, 4, 5],
          [2, 0, 2, 3, 4],
          [3, 2, 0, 2, 3],
          [4, 3, 2, 0, 2],
          [5, 4, 3, 2, 0]]
M = 1000

# Create model
m = gp.Model(""Landing_Scheduling"")

# Decision variables
t = {}
early = {}
late = {}
for i in range(5):
    t[i] = m.addVar(lb=earliest[i], ub=latest[i], name=f""t_{i}"")
    early[i] = m.addVar(lb=0, name=f""early_{i}"")
    late[i] = m.addVar(lb=0, name=f""late_{i}"")

y = {}
for i in range(5):
    for j in range(i+1, 5):
        y[(i,j)] = m.addVar(vtype=GRB.BINARY, name=f""y_{i}_{j}"")

# Objective: minimize penalty
m.setObjective(gp.quicksum(e[i]*early[i] + l[i]*late[i] for i in range(5)), GRB.MINIMIZE)

# Constraints
for i in range(5):
    m.addConstr(early[i] >= T[i] - t[i], name=f""early_def_{i}"")
    m.addConstr(late[i]  >= t[i] - T[i], name=f""late_def_{i}"")

for i in range(5):
    for j in range(i+1, 5):
        m.addConstr(t[j] - t[i] >= sep_ij[i][j] - M*(1 - y[(i,j)]), name=f""sep1_{i}_{j}"")
        m.addConstr(t[i] - t[j] >= sep_ji[i][j] - M*y[(i,j)], name=f""sep2_{i}_{j}"")

# Optimize
m.optimize()

# Print solution
if m.status == GRB.OPTIMAL:
    print(""\nOptimal schedule:"")
    for i in range(5):
        print(f""Flight {i}: t={t[i].X:.2f}, early={early[i].X:.2f}, late={late[i].X:.2f}"")
    print(""\nOrdering decisions:"")
    for (i,j), var in y.items():
        if var.X > 0.5:
            print(f""Flight {i} lands before Flight {j}"")
else:
    print(""No optimal solution found."")",0,0,1,,,,,,,,
"There are six jobs, each with a specific sequence of operations that must be performed on shared machines to complete their tasks. The goal is to schedule these operations to minimize the total time (makespan) required to complete all jobs. Each job has a predefined sequence of operations with specific processing times. Job 0 has two operations: the first takes 1 unit of time, and the second takes 6 units. Job 1 has two operations: the first takes 4 units, and the second takes 2 units. Job 2 has three operations: the first takes 9 units, the second takes 2 units, and the third takes 2 units. Job 3 has four operations: the first takes 5 units, the second takes 7 units, the third takes 6 units, and the fourth takes 3 units. Job 4 has four operations: the first takes 2 units, the second takes 9 units, the third takes 8 units, and the fourth takes 7 units. Job 5 has two operations: the first takes 4 units, and the second takes 8 units.

Operations from different jobs may share the same machine, and the order in which they are processed must be determined. For example, the second operation of Job 0 and the fourth operation of Job 3 share a machine. If Job 0__ second operation starts first, it must finish before Job 3__ fourth operation begins, or vice versa. Similarly, the second operation of Job 1 and the second operation of Job 2 share a machine. If Job 1__ second operation starts first, it must finish before Job 2__ second operation begins, or vice versa.

Each job__ operations must be performed in a specific order. For Job 0, the second operation cannot start until the first operation is completed. For Job 1, the second operation cannot start until the first operation is completed. For Job 2, the second operation cannot start until the first operation is completed, and the third operation cannot start until the second operation is completed. For Job 3, the second operation cannot start until the first operation is completed, the third operation cannot start until the second operation is completed, and the fourth operation cannot start until the third operation is completed. For Job 4, the second operation cannot start until the first operation is completed, the third operation cannot start until the second operation is completed, and the fourth operation cannot start until the third operation is completed. For Job 5, the second operation cannot start until the first operation is completed.

The objective is to minimize the total time (makespan) required to complete all operations for all jobs. The makespan is determined by the latest completion time among all operations. The constraints include precedence constraints, which ensure that each operation starts only after its preceding operation in the same job__ sequence is completed. For example, Job 0__ second operation must start at least 1 unit of time after the first operation starts. Job 1__ second operation must start at least 4 units of time after the first operation starts. Job 2__ second operation must start at least 9 units of time after the first operation starts, and the third operation must start at least 2 units of time after the second operation starts. Job 3__ second operation must start at least 5 units of time after the first operation starts, the third operation must start at least 7 units of time after the second operation starts, and the fourth operation must start at least 6 units of time after the third operation starts. Job 4__ second operation must start at least 2 units of time after the first operation starts, the third operation must start at least 9 units of time after the second operation starts, and the fourth operation must start at least 8 units of time after the third operation starts. Job 5__ second operation must start at least 4 units of time after the first operation starts.

Machine capacity constraints ensure that operations sharing the same machine do not overlap. For example, if Job 0__ second operation starts first on a shared machine, it must finish before Job 3__ fourth operation begins, or vice versa. A large constant (100,000) is used to enforce the order of operations on shared machines. Non-negativity constraints ensure that all operation start times are non-negative. Binary decision variables determine the order of operations on shared machines.

The processing times for each operation are fixed and provided. The precedence constraints specify the minimum time gaps between operations. The machine capacity constraints ensure that operations on shared machines do not overlap. The decisions to be made include determining the start time for each operation for all jobs, deciding the order of operations on shared machines using binary variables, and ensuring that all constraints are satisfied while minimizing the total makespan. The objective is to minimize the total time (makespan) required to complete all operations for all jobs, ensuring that all precedence and machine capacity constraints are met.","\[
\begin{aligned}
\min\;& C\\[4pt]
\text{s.t.}&\;\text{precedence constraints:}\\
& s_{0,1}+1\le s_{0,2}\\
& s_{1,1}+4\le s_{1,2}\\
& s_{2,1}+9\le s_{2,2}\\
& s_{2,2}+2\le s_{2,3}\\
& s_{3,1}+5\le s_{3,2}\\
& s_{3,2}+7\le s_{3,3}\\
& s_{3,3}+6\le s_{3,4}\\
& s_{4,1}+2\le s_{4,2}\\
& s_{4,2}+9\le s_{4,3}\\
& s_{4,3}+8\le s_{4,4}\\
& s_{5,1}+4\le s_{5,2}\\[4pt]
\text{machine constraints (big__, }M=100000\text{):}&\\
& s_{0,2}+6\le s_{3,4}+M(1-b_{0,3})\\
& s_{3,4}+3\le s_{0,2}+M\,b_{0,3}\\
& s_{1,2}+2\le s_{2,2}+M(1-b_{1,2})\\
& s_{2,2}+2\le s_{1,2}+M\,b_{1,2}\\[4pt]
\text{makespan constraints:}&\\
& s_{0,1}+1\le C,\; s_{0,2}+6\le C,\; s_{1,1}+4\le C,\; s_{1,2}+2\le C,\\
& s_{2,1}+9\le C,\; s_{2,2}+2\le C,\; s_{2,3}+2\le C,\\
& s_{3,1}+5\le C,\; s_{3,2}+7\le C,\; s_{3,3}+6\le C,\; s_{3,4}+3\le C,\\
& s_{4,1}+2\le C,\; s_{4,2}+9\le C,\; s_{4,3}+8\le C,\; s_{4,4}+7\le C,\\
& s_{5,1}+4\le C,\; s_{5,2}+8\le C\\[4pt]
\text{nonnegativity:}&\\
& s_{i,j}\ge0\;\forall i,j,\; C\ge0\\[4pt]
\text{binary variables:}&\\
& b_{0,3},\,b_{1,2}\in\{0,1\}\\[4pt]
\text{domains:}&\\
& s_{i,j}\in\mathbb{R}_+,\; C\in\mathbb{R}_+,\; b_{0,3},\,b_{1,2}\in\{0,1\}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Scheduling"")

# Big-M value
M = 100000

# Decision variables for start times
s = {}
s[(0,1)] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_0_1"")
s[(0,2)] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_0_2"")
s[(1,1)] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_1_1"")
s[(1,2)] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_1_2"")
s[(2,1)] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_2_1"")
s[(2,2)] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_2_2"")
s[(2,3)] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_2_3"")
s[(3,1)] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_3_1"")
s[(3,2)] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_3_2"")
s[(3,3)] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_3_3"")
s[(3,4)] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_3_4"")
s[(4,1)] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_4_1"")
s[(4,2)] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_4_2"")
s[(4,3)] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_4_3"")
s[(4,4)] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_4_4"")
s[(5,1)] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_5_1"")
s[(5,2)] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""s_5_2"")

# Binary variables for machine constraints
b_0_3 = m.addVar(vtype=GRB.BINARY, name=""b_0_3"")
b_1_2 = m.addVar(vtype=GRB.BINARY, name=""b_1_2"")

# Makespan variable
C = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""C"")

# Precedence constraints
m.addConstr(s[(0,1)] + 1 <= s[(0,2)], name=""prec_0"")
m.addConstr(s[(1,1)] + 4 <= s[(1,2)], name=""prec_1"")
m.addConstr(s[(2,1)] + 9 <= s[(2,2)], name=""prec_2_1"")
m.addConstr(s[(2,2)] + 2 <= s[(2,3)], name=""prec_2_2"")
m.addConstr(s[(3,1)] + 5 <= s[(3,2)], name=""prec_3_1"")
m.addConstr(s[(3,2)] + 7 <= s[(3,3)], name=""prec_3_2"")
m.addConstr(s[(3,3)] + 6 <= s[(3,4)], name=""prec_3_3"")
m.addConstr(s[(4,1)] + 2 <= s[(4,2)], name=""prec_4_1"")
m.addConstr(s[(4,2)] + 9 <= s[(4,3)], name=""prec_4_2"")
m.addConstr(s[(4,3)] + 8 <= s[(4,4)], name=""prec_4_3"")
m.addConstr(s[(5,1)] + 4 <= s[(5,2)], name=""prec_5"")

# Machine constraints with big-M
m.addConstr(s[(0,2)] + 6 <= s[(3,4)] + M * (1 - b_0_3), name=""machine_0_3_1"")
m.addConstr(s[(3,4)] + 3 <= s[(0,2)] + M * b_0_3, name=""machine_0_3_2"")
m.addConstr(s[(1,2)] + 2 <= s[(2,2)] + M * (1 - b_1_2), name=""machine_1_2_1"")
m.addConstr(s[(2,2)] + 2 <= s[(1,2)] + M * b_1_2, name=""machine_1_2_2"")

# Makespan constraints
m.addConstr(s[(0,1)] + 1 <= C, name=""makespan_0_1"")
m.addConstr(s[(0,2)] + 6 <= C, name=""makespan_0_2"")
m.addConstr(s[(1,1)] + 4 <= C, name=""makespan_1_1"")
m.addConstr(s[(1,2)] + 2 <= C, name=""makespan_1_2"")
m.addConstr(s[(2,1)] + 9 <= C, name=""makespan_2_1"")
m.addConstr(s[(2,2)] + 2 <= C, name=""makespan_2_2"")
m.addConstr(s[(2,3)] + 2 <= C, name=""makespan_2_3"")
m.addConstr(s[(3,1)] + 5 <= C, name=""makespan_3_1"")
m.addConstr(s[(3,2)] + 7 <= C, name=""makespan_3_2"")
m.addConstr(s[(3,3)] + 6 <= C, name=""makespan_3_3"")
m.addConstr(s[(3,4)] + 3 <= C, name=""makespan_3_4"")
m.addConstr(s[(4,1)] + 2 <= C, name=""makespan_4_1"")
m.addConstr(s[(4,2)] + 9 <= C, name=""makespan_4_2"")
m.addConstr(s[(4,3)] + 8 <= C, name=""makespan_4_3"")
m.addConstr(s[(4,4)] + 7 <= C, name=""makespan_4_4"")
m.addConstr(s[(5,1)] + 4 <= C, name=""makespan_5_1"")
m.addConstr(s[(5,2)] + 8 <= C, name=""makespan_5_2"")

# Objective: minimize makespan
m.setObjective(C, GRB.MINIMIZE)

# Optimize
m.optimize()
",26,29,0,,,,,,,,
"The manufacturing facility produces custom parts for two jobs, Job 0 and Job 1, each consisting of operations performed on shared machines. The goal is to minimize the total completion time (makespan) by scheduling operations efficiently while respecting constraints.

Job 0 has three operations: Operation 0 takes 2 hours, Operation 1 takes 8 hours, and Operation 2 takes 5 hours. Job 1 has two operations: Operation 0 takes 1 hour, and Operation 1 takes 7 hours.

For Job 0, Operation 1 cannot start until Operation 0 has finished, with at least 2 hours between the finish of Operation 0 and the start of Operation 1. Operation 2 cannot start until Operation 1 has finished, with at least 8 hours between the finish of Operation 1 and the start of Operation 2.

For Job 1, Operation 1 cannot start until Operation 0 has finished, with at least 1 hour between the finish of Operation 0 and the start of Operation 1.

Operations on shared machines cannot overlap. If Operation 0 of Job 1 is scheduled before Operation 1 of Job 1, there must be at least 1 hour between the finish of Operation 0 and the start of Operation 1. If Operation 1 of Job 1 is scheduled before Operation 0 of Job 1, there must be at least 7 hours between the finish of Operation 1 and the start of Operation 0.

For Job 0, if Operation 0 is scheduled before Operation 1, there must be at least 8 hours between the finish of Operation 0 and the start of Operation 1. If Operation 0 is scheduled before Operation 2, there must be at least 5 hours between the finish of Operation 0 and the start of Operation 2. If Operation 1 is scheduled before Operation 2, there must be at least 5 hours between the finish of Operation 1 and the start of Operation 2.

The makespan must be at least as large as the completion time of every operation: Operation 0 of Job 0 contributes at least 2 hours, Operation 1 of Job 0 contributes at least 8 hours, Operation 2 of Job 0 contributes at least 5 hours, Operation 0 of Job 1 contributes at least 1 hour, and Operation 1 of Job 1 contributes at least 7 hours.

Binary variables determine the order of operations on shared machines, ensuring no overlap. The objective is to determine the start times for all operations and their processing order on shared machines to minimize the makespan while satisfying all constraints.","\[
\begin{aligned}
\min\quad & C_{\max} \\
\text{s.t.}\quad & s_{00}\ge0,\; s_{01}\ge0,\; s_{02}\ge0,\; s_{10}\ge0,\; s_{11}\ge0,\; C_{\max}\ge0 \\[4pt]
& s_{01}\ge s_{00}+2+2 \quad\text{(precedence Job_0 Op_1)}\\
& s_{02}\ge s_{01}+8+8 \quad\text{(precedence Job_0 Op_2)}\\
& s_{11}\ge s_{10}+1+1 \quad\text{(precedence Job_1 Op_1)}\\[4pt]
& s_{01}\ge s_{00}+2+8-M(1-y_{01}^{01}) \\
& s_{00}\ge s_{01}+8-M\,y_{01}^{01} \\
& s_{02}\ge s_{00}+2+5-M(1-y_{01}^{02}) \\
& s_{00}\ge s_{02}+5-M\,y_{01}^{02} \\
& s_{02}\ge s_{01}+8+5-M(1-y_{01}^{12}) \\
& s_{01}\ge s_{02}+5-M\,y_{01}^{12} \\
& s_{11}\ge s_{10}+1+1-M(1-y_{10}^{01}) \\
& s_{10}\ge s_{11}+7-M\,y_{10}^{01} \\[4pt]
& C_{\max}\ge s_{00}+2,\; C_{\max}\ge s_{01}+8,\; C_{\max}\ge s_{02}+5,\\
& \quad C_{\max}\ge s_{10}+1,\; C_{\max}\ge s_{11}+7 \\[4pt]
& y_{01}^{01},\,y_{01}^{02},\,y_{01}^{12},\,y_{10}^{01}\in\{0,1\} \\[4pt]
& s_{00},s_{01},s_{02},s_{10},s_{11},C_{\max}\in\mathbb{R}_{+}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Job_Scheduling"")

# Big-M value
M = 100

# Decision variables
s00 = m.addVar(lb=0, name=""s00"")
s01 = m.addVar(lb=0, name=""s01"")
s02 = m.addVar(lb=0, name=""s02"")
s10 = m.addVar(lb=0, name=""s10"")
s11 = m.addVar(lb=0, name=""s11"")
Cmax = m.addVar(lb=0, name=""Cmax"")

y01_01 = m.addVar(vtype=GRB.BINARY, name=""y01_01"")
y01_02 = m.addVar(vtype=GRB.BINARY, name=""y01_02"")
y01_12 = m.addVar(vtype=GRB.BINARY, name=""y01_12"")
y10_01 = m.addVar(vtype=GRB.BINARY, name=""y10_01"")

# Precedence constraints
m.addConstr(s01 >= s00 + 2 + 2, name=""prec_00_01"")
m.addConstr(s02 >= s01 + 8 + 8, name=""prec_01_02"")
m.addConstr(s11 >= s10 + 1 + 1, name=""prec_10_11"")

# Disjunctive constraints
m.addConstr(s01 >= s00 + 2 + 8 - M * (1 - y01_01), name=""disc_01_01"")
m.addConstr(s00 >= s01 + 8 - M * y01_01, name=""disc_00_01"")

m.addConstr(s02 >= s00 + 2 + 5 - M * (1 - y01_02), name=""disc_02_02"")
m.addConstr(s00 >= s02 + 5 - M * y01_02, name=""disc_00_02"")

m.addConstr(s02 >= s01 + 8 + 5 - M * (1 - y01_12), name=""disc_02_12"")
m.addConstr(s01 >= s02 + 5 - M * y01_12, name=""disc_01_12"")

m.addConstr(s11 >= s10 + 1 + 1 - M * (1 - y10_01), name=""disc_11_01"")
m.addConstr(s10 >= s11 + 7 - M * y10_01, name=""disc_10_01"")

# Makespan constraints
m.addConstr(Cmax >= s00 + 2, name=""Cmax_00"")
m.addConstr(Cmax >= s01 + 8, name=""Cmax_01"")
m.addConstr(Cmax >= s02 + 5, name=""Cmax_02"")
m.addConstr(Cmax >= s10 + 1, name=""Cmax_10"")
m.addConstr(Cmax >= s11 + 7, name=""Cmax_11"")

# Objective
m.setObjective(Cmax, GRB.MINIMIZE)

# Optimize
m.optimize()
",31,15,0,,,,,,,,
"The problem involves scheduling operations for three jobs (Job 0, Job 1, and Job 2) on a set of machines in a manufacturing facility to minimize the total completion time (makespan). Each job consists of a sequence of operations with specific processing times. Job 0 has 5 operations with processing times of 7, 9, 8, 3, and 9 hours. Job 1 has 6 operations with processing times of 1, 3, 4, 1, 2, and 9 hours. Job 2 has 7 operations with processing times of 9, 3, 1, 3, 3, 3, and 5 hours. Each operation must start only after the previous operation in the same job has been completed. For example, Operation 1 of Job 0 cannot start until Operation 0 has been completed (7 hours), and Operation 1 of Job 1 cannot start until Operation 0 has been completed (1 hour). Operations from different jobs that require the same machine must be scheduled in a specific order to avoid overlapping. Binary decision variables determine the order of operations on shared machines. For instance, if Operation 0 of Job 0 is scheduled before Operation 0 of Job 1, the binary variable is set to 1; otherwise, it is set to 0. A large constant (100,000) is used in the constraints to ensure they are only active when necessary. The makespan must be at least as long as the completion time of the last operation across all jobs. The start times for all operations must be non-negative, and the objective is to minimize the makespan while satisfying all precedence and machine capacity constraints. Specifically, the constraints include precedence constraints within each job, machine capacity constraints to prevent overlapping operations on the same machine, and makespan constraints to ensure the makespan is at least as large as the completion time of every operation. The binary variables are used to enforce the order of operations on shared machines, and the large constant ensures the constraints are only active when necessary. The start times and the makespan are continuous variables, and the binary variables are restricted to 0 or 1. The machine capacity constraints are formulated such that for each pair of operations assigned to the same machine, the start time of one operation plus its processing time must be less than or equal to the start time of the other operation plus the large constant multiplied by the complement of the binary variable. This ensures that the operations do not overlap on the same machine. The makespan constraints ensure that the makespan is at least as large as the completion time of every operation. The precedence constraints ensure that operations within the same job are scheduled in the correct order. The binary variables are used to determine the order of operations on shared machines, and the large constant is used to make the constraints active only when necessary. The start times for all operations must be non-negative, and the objective is to minimize the makespan while satisfying all constraints.","\[
\begin{aligned}
\min \quad & C_{\max} \\[4pt]
\text{s.t.} \quad
& S_{j,o+1} \;\ge\; S_{j,o} + p_{j,o} && \forall j\in J,\; o=0,\dots,n_j-2 \\[2pt]
& S_{j,o} \;\ge\; 0 && \forall j\in J,\; o=0,\dots,n_j-1 \\[2pt]
& C_{\max} \;\ge\; S_{j,o} + p_{j,o} && \forall j\in J,\; o=0,\dots,n_j-1 \\[2pt]
& S_{j_1,o_1} + p_{j_1,o_1} \;\le\; S_{j_2,o_2} + M\,(1-y_{j_1o_1j_2o_2}) && \forall (j_1,o_1,j_2,o_2)\in P \\[2pt]
& S_{j_2,o_2} + p_{j_2,o_2} \;\le\; S_{j_1,o_1} + M\,y_{j_1o_1j_2o_2} && \forall (j_1,o_1,j_2,o_2)\in P \\[2pt]
& y_{j_1o_1j_2o_2} \;\in\; \{0,1\} && \forall (j_1,o_1,j_2,o_2)\in P \\[2pt]
& S_{j,o} \;\in\; \mathbb{R}_+ && \forall j\in J,\; o=0,\dots,n_j-1 \\[2pt]
& C_{\max} \;\in\; \mathbb{R}_+ 
\end{aligned}
\]  
where  
\(J=\{0,1,2\}\),  
\(n_0=5,\; n_1=6,\; n_2=7\),  
\(p_{0,0}=7,\; p_{0,1}=9,\; p_{0,2}=8,\; p_{0,3}=3,\; p_{0,4}=9\),  
\(p_{1,0}=1,\; p_{1,1}=3,\; p_{1,2}=4,\; p_{1,3}=1,\; p_{1,4}=2,\; p_{1,5}=9\),  
\(p_{2,0}=9,\; p_{2,1}=3,\; p_{2,2}=1,\; p_{2,3}=3,\; p_{2,4}=3,\; p_{2,5}=3,\; p_{2,6}=5\),  
\(M=100\,000\),  
\(P=\{(j_1,o_1,j_2,o_2)\mid m_{j_1,o_1}=m_{j_2,o_2},\;(j_1,o_1)<(j_2,o_2)\}\).","import gurobipy as gp
from gurobipy import GRB

# Data
J = [0, 1, 2]
n = {0: 5, 1: 6, 2: 7}
p = {
    0: [7, 9, 8, 3, 9],
    1: [1, 3, 4, 1, 2, 9],
    2: [9, 3, 1, 3, 3, 3, 5]
}
M = 100000

# Create model
m = gp.Model(""Job_Scheduling"")

# Decision variables: start times S[j,o] and makespan Cmax
S = {}
for j in J:
    for o in range(n[j]):
        S[j, o] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=f""S_{j}_{o}"")

Cmax = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""Cmax"")

# Sequencing constraints within each job
for j in J:
    for o in range(n[j] - 1):
        m.addConstr(S[j, o + 1] >= S[j, o] + p[j][o], name=f""seq_{j}_{o}"")

# Makespan constraints
for j in J:
    for o in range(n[j]):
        m.addConstr(Cmax >= S[j, o] + p[j][o], name=f""makespan_{j}_{o}"")

# Objective: minimize makespan
m.setObjective(Cmax, GRB.MINIMIZE)

# Optimize
m.optimize()

# Print results
if m.status == GRB.OPTIMAL:
    print(f""Optimal makespan: {Cmax.X}"")
    for j in J:
        for o in range(n[j]):
            print(f""Start time of job {j} operation {o}: {S[j, o].X}"")",36,36,1,,,,,,,,
"The problem involves scheduling four jobs (Job 0, Job 1, Job 2, and Job 3) across multiple machines to minimize the total completion time (makespan). Each job consists of a sequence of operations that must be performed in a specific order, and each operation is assigned to a particular machine. The processing times for each operation are as follows: Job 0 has Operation 0 (6 units), Operation 1 (8 units), and Operation 2 (9 units); Job 1 has Operation 0 (3 units), Operation 1 (8 units), Operation 2 (5 units), Operation 3 (5 units), and Operation 4 (2 units); Job 2 has Operation 0 (8 units), Operation 1 (1 unit), and Operation 2 (6 units); Job 3 has Operation 0 (1 unit), Operation 1 (9 units), Operation 2 (4 units), and Operation 3 (5 units).

Each machine can process only one operation at a time. If two operations are assigned to the same machine, they cannot overlap in time. The order of operations on the same machine is determined by binary decision variables. For example, if Operation 0 of Job 0 and Operation 3 of Job 1 are on the same machine, the binary variable determines whether Operation 0 of Job 0 is processed before Operation 3 of Job 1 or vice versa. Similar constraints apply to other operation pairs on the same machine, such as Operation 2 of Job 1 and Operation 4 of Job 1, Operation 2 of Job 0 and Operation 0 of Job 2, Operation 2 of Job 0 and Operation 3 of Job 3, Operation 0 of Job 2 and Operation 3 of Job 3, Operation 0 of Job 1 and Operation 1 of Job 2, Operation 0 of Job 1 and Operation 2 of Job 3, and Operation 1 of Job 2 and Operation 2 of Job 3.

The objective is to minimize the makespan, which must be at least as large as the completion time of every operation. For example, the completion time of Operation 0 of Job 0 is at least 6 units, so the makespan must be at least 6 units. Similarly, the completion time of Operation 1 of Job 0 is at least 8 units, so the makespan must be at least 8 units. This applies to all operations, with the final operation of Job 3 requiring at least 5 units.

Constraints include precedence constraints within jobs, ensuring that each operation starts only after the previous operation in the same job has completed. For example, Operation 1 of Job 0 cannot start until Operation 0 of Job 0 has completed, which takes at least 6 units. Machine capacity constraints ensure that operations assigned to the same machine do not overlap, with binary variables determining the order of operations on the same machine. The makespan must be at least as large as the completion time of every operation, and all start times for operations must be non-negative. Binary variables must be either 0 or 1, determining the order of operations on the same machine.

The goal is to find the optimal schedule that meets all these constraints while minimizing the total time required to complete all jobs.","\[
\begin{aligned}
\min\quad & C\\
\text{s.t.}\quad
& s_{0,0}+6\le C,\; s_{0,1}+8\le C,\; s_{0,2}+9\le C,\\
& s_{1,0}+3\le C,\; s_{1,1}+8\le C,\; s_{1,2}+5\le C,\; s_{1,3}+5\le C,\; s_{1,4}+2\le C,\\
& s_{2,0}+8\le C,\; s_{2,1}+1\le C,\; s_{2,2}+6\le C,\\
& s_{3,0}+1\le C,\; s_{3,1}+9\le C,\; s_{3,2}+4\le C,\; s_{3,3}+5\le C,\\
& s_{0,1}\ge s_{0,0}+6,\; s_{0,2}\ge s_{0,1}+8,\\
& s_{1,1}\ge s_{1,0}+3,\; s_{1,2}\ge s_{1,1}+8,\; s_{1,3}\ge s_{1,2}+5,\; s_{1,4}\ge s_{1,3}+5,\\
& s_{2,1}\ge s_{2,0}+8,\; s_{2,2}\ge s_{2,1}+1,\\
& s_{3,1}\ge s_{3,0}+1,\; s_{3,2}\ge s_{3,1}+9,\; s_{3,3}\ge s_{3,2}+4,\\
& s_{j,o}\ge0\quad\forall j\in\{0,1,2,3\},\; o\in\text{ops of }j,\\
& s_{0,0}+6\le s_{1,3}+M(1-y_{0,0,1,3}),\; s_{1,3}+5\le s_{0,0}+M y_{0,0,1,3},\\
& s_{1,2}+5\le s_{1,4}+M(1-y_{1,2,1,4}),\; s_{1,4}+2\le s_{1,2}+M y_{1,2,1,4},\\
& s_{0,2}+9\le s_{2,0}+M(1-y_{0,2,2,0}),\; s_{2,0}+8\le s_{0,2}+M y_{0,2,2,0},\\
& s_{0,2}+9\le s_{3,3}+M(1-y_{0,2,3,3}),\; s_{3,3}+5\le s_{0,2}+M y_{0,2,3,3},\\
& s_{2,0}+8\le s_{3,3}+M(1-y_{2,0,3,3}),\; s_{3,3}+5\le s_{2,0}+M y_{2,0,3,3},\\
& s_{1,0}+3\le s_{2,1}+M(1-y_{1,0,2,1}),\; s_{2,1}+1\le s_{1,0}+M y_{1,0,2,1},\\
& s_{1,0}+3\le s_{3,2}+M(1-y_{1,0,3,2}),\; s_{3,2}+4\le s_{1,0}+M y_{1,0,3,2},\\
& s_{2,1}+1\le s_{3,2}+M(1-y_{2,1,3,2}),\; s_{3,2}+4\le s_{2,1}+M y_{2,1,3,2},\\
& M=80,\\
& s_{j,o}\in\mathbb{R}_+,\; C\in\mathbb{R}_+,\; y_{0,0,1,3},y_{1,2,1,4},y_{0,2,2,0},y_{0,2,3,3},y_{2,0,3,3},y_{1,0,2,1},y_{1,0,3,2},y_{2,1,3,2}\in\{0,1\}.
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Job_Shop_Scheduling"")

# Processing times
proc = {
    (0,0):6, (0,1):8, (0,2):9,
    (1,0):3, (1,1):8, (1,2):5, (1,3):5, (1,4):2,
    (2,0):8, (2,1):1, (2,2):6,
    (3,0):1, (3,1):9, (3,2):4, (3,3):5
}

# Decision variables for start times
s = {}
for (j,o),p in proc.items():
    s[(j,o)] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=f""s_{j}_{o}"")

# Binary variables for ordering between operations of different jobs
y = {}
pairs = [
    ((0,0),(1,3)),
    ((1,2),(1,4)),
    ((0,2),(2,0)),
    ((0,2),(3,3)),
    ((2,0),(3,3)),
    ((1,0),(2,1)),
    ((1,0),(3,2)),
    ((2,1),(3,2))
]
for (i,o),(k,p) in pairs:
    y[(i,o,k,p)] = m.addVar(vtype=GRB.BINARY, name=f""y_{i}_{o}_{k}_{p}"")

# Variable for makespan
C = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""C"")

# Objective: minimize C
m.setObjective(C, GRB.MINIMIZE)

# Constraints: each operation finishes before C
for (j,o),p in proc.items():
    m.addConstr(s[(j,o)] + p <= C, name=f""finish_C_{j}_{o}"")

# Precedence constraints within each job
# Job 0
m.addConstr(s[(0,1)] >= s[(0,0)] + proc[(0,0)], name=""prec_0_1"")
m.addConstr(s[(0,2)] >= s[(0,1)] + proc[(0,1)], name=""prec_0_2"")
# Job 1
m.addConstr(s[(1,1)] >= s[(1,0)] + proc[(1,0)], name=""prec_1_1"")
m.addConstr(s[(1,2)] >= s[(1,1)] + proc[(1,1)], name=""prec_1_2"")
m.addConstr(s[(1,3)] >= s[(1,2)] + proc[(1,2)], name=""prec_1_3"")
m.addConstr(s[(1,4)] >= s[(1,3)] + proc[(1,3)], name=""prec_1_4"")
# Job 2
m.addConstr(s[(2,1)] >= s[(2,0)] + proc[(2,0)], name=""prec_2_1"")
m.addConstr(s[(2,2)] >= s[(2,1)] + proc[(2,1)], name=""prec_2_2"")
# Job 3
m.addConstr(s[(3,1)] >= s[(3,0)] + proc[(3,0)], name=""prec_3_1"")
m.addConstr(s[(3,2)] >= s[(3,1)] + proc[(3,1)], name=""prec_3_2"")
m.addConstr(s[(3,3)] >= s[(3,2)] + proc[(3,2)], name=""prec_3_3"")

# Cross-job ordering constraints with big M
M = 80
# (0,0) vs (1,3)
m.addConstr(s[(0,0)] + proc[(0,0)] <= s[(1,3)] + M*(1 - y[(0,0,1,3)]), name=""order_0_0_1_3_1"")
m.addConstr(s[(1,3)] + proc[(1,3)] <= s[(0,0)] + M*y[(0,0,1,3)], name=""order_0_0_1_3_2"")
# (1,2) vs (1,4)
m.addConstr(s[(1,2)] + proc[(1,2)] <= s[(1,4)] + M*(1 - y[(1,2,1,4)]), name=""order_1_2_1_4_1"")
m.addConstr(s[(1,4)] + proc[(1,4)] <= s[(1,2)] + M*y[(1,2,1,4)], name=""order_1_2_1_4_2"")
# (0,2) vs (2,0)
m.addConstr(s[(0,2)] + proc[(0,2)] <= s[(2,0)] + M*(1 - y[(0,2,2,0)]), name=""order_0_2_2_0_1"")
m.addConstr(s[(2,0)] + proc[(2,0)] <= s[(0,2)] + M*y[(0,2,2,0)], name=""order_0_2_2_0_2"")
# (0,2) vs (3,3)
m.addConstr(s[(0,2)] + proc[(0,2)] <= s[(3,3)] + M*(1 - y[(0,2,3,3)]), name=""order_0_2_3_3_1"")
m.addConstr(s[(3,3)] + proc[(3,3)] <= s[(0,2)] + M*y[(0,2,3,3)], name=""order_0_2_3_3_2"")
# (2,0) vs (3,3)
m.addConstr(s[(2,0)] + proc[(2,0)] <= s[(3,3)] + M*(1 - y[(2,0,3,3)]), name=""order_2_0_3_3_1"")
m.addConstr(s[(3,3)] + proc[(3,3)] <= s[(2,0)] + M*y[(2,0,3,3)], name=""order_2_0_3_3_2"")
# (1,0) vs (2,1)
m.addConstr(s[(1,0)] + proc[(1,0)] <= s[(2,1)] + M*(1 - y[(1,0,2,1)]), name=""order_1_0_2_1_1"")
m.addConstr(s[(2,1)] + proc[(2,1)] <= s[(1,0)] + M*y[(1,0,2,1)], name=""order_1_0_2_1_2"")
# (1,0) vs (3,2)
m.addConstr(s[(1,0)] + proc[(1,0)] <= s[(3,2)] + M*(1 - y[(1,0,3,2)]), name=""order_1_0_3_2_1"")
m.addConstr(s[(3,2)] + proc[(3,2)] <= s[(1,0)] + M*y[(1,0,3,2)], name=""order_1_0_3_2_2"")
# (2,1) vs (3,2)
m.addConstr(s[(2,1)] + proc[(2,1)] <= s[(3,2)] + M*(1 - y[(2,1,3,2)]), name=""order_2_1_3_2_1"")
m.addConstr(s[(3,2)] + proc[(3,2)] <= s[(2,1)] + M*y[(2,1,3,2)], name=""order_2_1_3_2_2"")

# Optimize
m.optimize()
```",28,28,1,,,,,,,,
"Imagine you are managing a supply chain network for a company that operates across six key locations (nodes). Each location has specific supply and demand requirements, and your goal is to optimize the flow of goods between these locations while minimizing the total cost, which includes both fixed costs for establishing connections and variable costs for shipping goods.

#### Supply and Demand:
- **Location 0** has a demand of 116 units.
- **Location 1** has a demand of 134 units.
- **Location 2** has no net supply or demand (balance is 0).
- **Location 3** has a demand of 141 units.
- **Location 4** has a demand of 8 units.
- **Location 5** has a demand of 101 units.

#### Costs and Capacities:
To establish a connection between any two locations, there is a fixed cost. Additionally, shipping goods between locations incurs a variable cost per unit. Each connection also has a maximum capacity, limiting the amount of goods that can be shipped.

Here are the specific costs and capacities for each possible connection:

- **Fixed Costs (for establishing connections):**
  - From Location 0: To Location 1 costs 1972, to Location 2 costs 2030, to Location 3 costs 2048, to Location 4 costs 1951, to Location 5 costs 2043.
  - From Location 1: To Location 0 costs 1993, to Location 2 costs 2029, to Location 3 costs 1975, to Location 4 costs 1967, to Location 5 costs 2026.
  - From Location 2: To Location 0 costs 2042, to Location 1 costs 1973, to Location 3 costs 2001, to Location 4 costs 2034, to Location 5 costs 2035.
  - From Location 3: To Location 0 costs 2007, to Location 1 costs 1968, to Location 2 costs 2004, to Location 4 costs 1996, to Location 5 costs 1969.
  - From Location 4: To Location 0 costs 1973, to Location 1 costs 1955, to Location 2 costs 2038, to Location 3 costs 1953, to Location 5 costs 2000.
  - From Location 5: To Location 0 costs 1999, to Location 1 costs 2031, to Location 2 costs 2011, to Location 3 costs 1965, to Location 4 costs 1984.

- **Variable Costs (per unit shipped):**
  - From Location 0: To Location 1 costs 21, to Location 2 costs 19, to Location 3 costs 20, to Location 4 costs 21, to Location 5 costs 21.
  - From Location 1: To Location 0 costs 21, to Location 2 costs 19, to Location 3 costs 21, to Location 4 costs 19, to Location 5 costs 20.
  - From Location 2: To Location 0 costs 20, to Location 1 costs 20, to Location 3 costs 21, to Location 4 costs 21, to Location 5 costs 20.
  - From Location 3: To Location 0 costs 19, to Location 1 costs 19, to Location 2 costs 20, to Location 4 costs 19, to Location 5 costs 20.
  - From Location 4: To Location 0 costs 20, to Location 1 costs 19, to Location 2 costs 20, to Location 3 costs 20, to Location 5 costs 19.
  - From Location 5: To Location 0 costs 21, to Location 1 costs 20, to Location 2 costs 20, to Location 3 costs 19, to Location 4 costs 21.

- **Maximum Capacities (units that can be shipped):**
  - From Location 0: To Location 1 can handle up to 137 units, to Location 2 up to 154 units, to Location 3 up to 189 units, to Location 4 up to 188 units, to Location 5 up to 247 units.
  - From Location 1: To Location 0 up to 163 units, to Location 2 up to 197 units, to Location 3 up to 242 units, to Location 4 up to 191 units, to Location 5 up to 135 units.
  - From Location 2: To Location 0 up to 226 units, to Location 1 up to 155 units, to Location 3 up to 182 units, to Location 4 up to 189 units, to Location 5 up to 160 units.
  - From Location 3: To Location 0 up to 179 units, to Location 1 up to 232 units, to Location 2 up to 210 units, to Location 4 up to 146 units, to Location 5 up to 241 units.
  - From Location 4: To Location 0 up to 238 units, to Location 1 up to 164 units, to Location 2 up to 238 units, to Location 3 up to 218 units, to Location 5 up to 195 units.
  - From Location 5: To Location 0 up to 237 units, to Location 1 up to 191 units, to Location 2 up to 165 units, to Location 3 up to 133 units, to Location 4 up to 191 units.

#### Objective:
Your task is to determine which connections to establish and how much to ship between locations to meet all demand requirements while minimizing the total cost. The total cost includes both the fixed costs of establishing connections and the variable costs of shipping goods.

#### Constraints:
1. **Capacity Constraints:** The amount of goods shipped between any two locations cannot exceed the maximum capacity of that connection.
2. **Flow Balance:** The total amount of goods entering a location minus the total amount leaving must equal the net supply or demand at that location.
3. **Binary Decisions:** For each connection, you must decide whether to establish it (yes or no), which incurs the fixed cost.

By carefully analyzing these factors, you aim to find the most cost-effective way to manage the supply chain network, ensuring all locations receive the goods they need without exceeding capacity limits or incurring unnecessary costs.","\[
\begin{aligned}
\min\;&\sum_{\substack{i=0\\i\neq j}}^{5}\sum_{\substack{j=0\\j\neq i}}^{5}
\Bigl( F_{ij}\,y_{ij}+V_{ij}\,f_{ij}\Bigr)\\[4pt]
\text{s.t.}\;&
f_{ij}\;\le\;C_{ij}\,y_{ij}\qquad\forall\,i\neq j\\[4pt]
&\sum_{\substack{j=0\\j\neq i}}^{5} f_{ji}\;-\;\sum_{\substack{j=0\\j\neq i}}^{5} f_{ij}
\;=\;d_i\qquad\forall\,i=0,\dots,5\\[4pt]
&y_{ij}\in\{0,1\}\qquad\forall\,i\neq j\\
&f_{ij}\in\mathbb{R}_+\qquad\forall\,i\neq j
\end{aligned}
\]

where  

\[
\begin{array}{c|ccccc}
F_{ij}&j=1&2&3&4&5\\\hline
i=0&1972&2030&2048&1951&2043\\
i=1&1993&2029&1975&1967&2026\\
i=2&2042&1973&2001&2034&2035\\
i=3&2007&1968&2004&1996&1969\\
i=4&1973&1955&2038&1953&2000\\
i=5&1999&2031&2011&1965&1984
\end{array}
\]

\[
\begin{array}{c|ccccc}
V_{ij}&j=1&2&3&4&5\\\hline
i=0&21&19&20&21&21\\
i=1&21&19&21&19&20\\
i=2&20&20&21&21&20\\
i=3&19&19&20&19&20\\
i=4&20&19&20&20&19\\
i=5&21&20&20&19&21
\end{array}
\]

\[
\begin{array}{c|ccccc}
C_{ij}&j=1&2&3&4&5\\\hline
i=0&137&154&189&188&247\\
i=1&163&197&242&191&135\\
i=2&226&155&182&189&160\\
i=3&179&232&210&146&241\\
i=4&238&164&238&218&195\\
i=5&237&191&165&133&191
\end{array}
\]

\[
d_0=116,\; d_1=134,\; d_2=0,\; d_3=141,\; d_4=8,\; d_5=101.
\]","import gurobipy as gp
from gurobipy import GRB

# Data matrices (6x6) with zeros on the diagonal
F = [[0]*6 for _ in range(6)]
V = [[0]*6 for _ in range(6)]
C = [[0]*6 for _ in range(6)]

# Fill given values for j=1..5
F_vals = {
    (0,1):1972,(0,2):2030,(0,3):2048,(0,4):1951,(0,5):2043,
    (1,1):1993,(1,2):2029,(1,3):1975,(1,4):1967,(1,5):2026,
    (2,1):2042,(2,2):1973,(2,3):2001,(2,4):2034,(2,5):2035,
    (3,1):2007,(3,2):1968,(3,3):2004,(3,4):1996,(3,5):1969,
    (4,1):1973,(4,2):1955,(4,3):2038,(4,4):1953,(4,5):2000,
    (5,1):1999,(5,2):2031,(5,3):2011,(5,4):1965,(5,5):1984
}
V_vals = {
    (0,1):21,(0,2):19,(0,3):20,(0,4):21,(0,5):21,
    (1,1):21,(1,2):19,(1,3):21,(1,4):19,(1,5):20,
    (2,1):20,(2,2):20,(2,3):21,(2,4):21,(2,5):20,
    (3,1):19,(3,2):19,(3,3):20,(3,4):19,(3,5):20,
    (4,1):20,(4,2):19,(4,3):20,(4,4):20,(4,5):19,
    (5,1):21,(5,2):20,(5,3):20,(5,4):19,(5,5):21
}
C_vals = {
    (0,1):137,(0,2):154,(0,3):189,(0,4):188,(0,5):247,
    (1,1):163,(1,2):197,(1,3):242,(1,4):191,(1,5):135,
    (2,1):226,(2,2):155,(2,3):182,(2,4):189,(2,5):160,
    (3,1):179,(3,2):232,(3,3):210,(3,4):146,(3,5):241,
    (4,1):238,(4,2):164,(4,3):238,(4,4):218,(4,5):195,
    (5,1):237,(5,2):191,(5,3):165,(5,4):133,(5,5):191
}

for (i,j), val in F_vals.items():
    F[i][j] = val
for (i,j), val in V_vals.items():
    V[i][j] = val
for (i,j), val in C_vals.items():
    C[i][j] = val

# Set large capacity for missing edges to node 0
for i in range(6):
    C[i][0] = 1e6
    F[i][0] = 0
    V[i][0] = 0
    C[0][i] = 1e6
    F[0][i] = 0
    V[0][i] = 0

# Demand vector
d = [116, 134, 0, 141, 8, 101]

# Create model
m = gp.Model(""Network_Design"")

# Decision variables
y = {}
f = {}
for i in range(6):
    for j in range(6):
        if i != j:
            y[i,j] = m.addVar(vtype=GRB.BINARY, name=f""y_{i}_{j}"")
            f[i,j] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=f""f_{i}_{j}"")

m.update()

# Objective: minimize sum(F_ij*y_ij + V_ij*f_ij)
obj = gp.quicksum(F[i][j]*y[i,j] + V[i][j]*f[i,j] for i in range(6) for j in range(6) if i!=j)
m.setObjective(obj, GRB.MINIMIZE)

# Capacity constraints: f_ij <= C_ij * y_ij
for i in range(6):
    for j in range(6):
        if i != j:
            m.addConstr(f[i,j] <= C[i][j]*y[i,j], name=f""cap_{i}_{j}"")

# Flow conservation constraints
for i in range(6):
    inflow = gp.quicksum(f[j,i] for j in range(6) if j!=i)
    outflow = gp.quicksum(f[i,j] for j in range(6) if j!=i)
    m.addConstr(inflow - outflow == d[i], name=f""flow_{i}"")

# Optimize
m.optimize()

# Print results
if m.status == GRB.OPTIMAL:
    print(f""Optimal objective: {m.objVal}"")
    for i in range(6):
        for j in range(6):
            if i != j and y[i,j].X > 0.5:
                print(f""Edge {i}->{j}: y={y[i,j].X}, f={f[i,j].X}"")
else:
    print(""No optimal solution found."")",,13033,0,,,,,,,,
"You are tasked with optimizing the deployment of cell towers across a region to maximize population coverage while adhering to a strict budget constraint. The region is divided into 33 distinct areas, each with a specific population size that needs to be covered by cell tower signals. The goal is to determine which cell towers to build and which areas to cover to ensure the maximum number of people have access to cellular service.

For each of the 29 available cell tower locations (tower_0 to tower_28), you must decide whether to build the tower (a binary decision: build or not build). For each of the 33 regions (region_0 to region_32), you must decide whether the region will be covered by at least one active cell tower (a binary decision: cover or not cover).

The objective is to maximize the total population covered by the deployed cell towers. The population sizes for the regions are as follows: Region 0: 4,901; Region 1: 2,727; Region 2: 2,994; Region 3: 2,984; Region 4: 3,693; Region 5: 2,615; Region 6: 3,354; Region 7: 4,965; Region 8: 4,223; Region 9: 4,738; Region 10: 2,345; Region 11: 3,915; Region 12: 4,068; Region 13: 2,613; Region 14: 3,140; Region 15: 4,894; Region 16: 3,503; Region 17: 3,733; Region 18: 4,275; Region 19: 3,795; Region 20: 3,803; Region 21: 3,497; Region 22: 2,403; Region 23: 3,441; Region 24: 3,116; Region 25: 2,091; Region 26: 4,494; Region 27: 3,593; Region 28: 2,090; Region 29: 3,397; Region 30: 3,973; Region 31: 2,362; Region 32: 2,068.

Each region can only be considered covered if at least one of the cell towers that can serve it is built. For example, Region 0 can be covered if any of the following towers are built: Tower 1, Tower 2, Tower 3, Tower 4, Tower 5, Tower 6, Tower 9, Tower 12, Tower 14, Tower 15, Tower 16, Tower 17, Tower 19, or Tower 26. Similar constraints apply to all 33 regions, with each region having a specific set of towers that can provide coverage.

The total cost of building the selected cell towers must not exceed the available budget of 2,996 units. The costs for building each tower are as follows: Tower 0: 227; Tower 1: 355; Tower 2: 287; Tower 3: 487; Tower 4: 497; Tower 5: 412; Tower 6: 495; Tower 7: 294; Tower 8: 212; Tower 9: 290; Tower 10: 427; Tower 11: 399; Tower 12: 361; Tower 13: 253; Tower 14: 350; Tower 15: 314; Tower 16: 234; Tower 17: 203; Tower 18: 257; Tower 19: 248; Tower 20: 406; Tower 21: 264; Tower 22: 277; Tower 23: 419; Tower 24: 426; Tower 25: 297; Tower 26: 474; Tower 27: 333; Tower 28: 491.

Your task is to select which cell towers to build and which regions to cover, ensuring that the total population covered is maximized while staying within the budget. Each region can only be covered if at least one of its associated towers is built, and the total cost of building the selected towers must not exceed 2,996 units. The solution must balance the trade-off between coverage and cost to achieve the best possible outcome.","\begin{align*}\max\; 4901y_0+2727y_1+2994y_2+2984y_3+3693y_4+2615y_5+3354y_6+4965y_7+4223y_8+4738y_9+2345y_{10}+3915y_{11}+4068y_{12}+2613y_{13}+3140y_{14}+4894y_{15}+3503y_{16}+3733y_{17}+4275y_{18}+3795y_{19}+3803y_{20}+3497y_{21}+2403y_{22}+3441y_{23}+3116y_{24}+2091y_{25}+4494y_{26}+3593y_{27}+2090y_{28}+3397y_{29}+3973y_{30}+2362y_{31}+2068y_{32}\\\text{s.t.}\; 227x_0+355x_1+287x_2+487x_3+497x_4+412x_5+495x_6+294x_7+212x_8+290x_9+427x_{10}+399x_{11}+361x_{12}+253x_{13}+350x_{14}+314x_{15}+234x_{16}+203x_{17}+257x_{18}+248x_{19}+406x_{20}+264x_{21}+277x_{22}+419x_{23}+426x_{24}+297x_{25}+474x_{26}+333x_{27}+491x_{28}\le 2996\\ y_r\le\sum_{t\in S_r}x_t\;\forall r=0,\dots,32\\ x_t\in\{0,1\}\;\forall t=0,\dots,28\\ y_r\in\{0,1\}\;\forall r=0,\dots,32\end{align*}","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Optimization"")

# Decision variables
x = m.addVars(29, vtype=GRB.BINARY, name=""x"")
y = m.addVars(33, vtype=GRB.BINARY, name=""y"")

# Objective coefficients for y
coeff_y = [4901,2727,2994,2984,3693,2615,3354,4965,4223,4738,2345,3915,4068,2613,3140,4894,3503,3733,4275,3795,3803,3497,2403,3441,3116,2091,4494,3593,2090,3397,3973,2362,2068]
m.setObjective(gp.quicksum(coeff_y[r]*y[r] for r in range(33)), GRB.MAXIMIZE)

# Coefficients for x in resource constraint
coeff_x = [227,355,287,487,497,412,495,294,212,290,427,399,361,253,350,314,234,203,257,248,406,264,277,419,426,297,474,333,491]
m.addConstr(gp.quicksum(coeff_x[t]*x[t] for t in range(29)) <= 2996, name=""resource"")

# Define S_r sets (example: all x indices for each y)
S = {r: list(range(29)) for r in range(33)}

# Constraints y_r <= sum_{t in S_r} x_t
for r in range(33):
    m.addConstr(y[r] <= gp.quicksum(x[t] for t in S[r]), name=f""y_le_sum_{r}"")

# Optimize
m.optimize()",113803,113803,1,,,,,,,,
"You are tasked with managing the distribution of resources across a network of nine cities. Each city has a specific supply or demand for resources, and your goal is to ensure that all cities meet their requirements while minimizing the total transportation cost. The transportation costs vary depending on the route taken between cities, and each route has a maximum capacity limit for resource shipments.

#### City Requirements:
- **City 0** has a net demand of **41 units**.
- **City 1** has a net demand of **23 units**.
- **City 2** has a net supply of **15 units** (indicated by a negative demand of -15).
- **City 3** has a net demand of **2 units**.
- **City 4** has a net supply of **13 units** (indicated by a negative demand of -13).
- **City 5** has a net supply of **4 units** (indicated by a negative demand of -4).
- **City 6** has a net supply of **7 units** (indicated by a negative demand of -7).
- **City 7** has a net supply of **2 units** (indicated by a negative demand of -2).
- **City 8** has a net supply of **25 units** (indicated by a negative demand of -25).

#### Transportation Costs and Capacities:
The cost of shipping resources between cities varies, and each route has a maximum capacity. Below are the costs and capacities for each possible route:

- **From City 0**:  
  - To City 1: Cost = 7, Capacity = 35  
  - To City 2: Cost = 9, Capacity = 60  
  - To City 3: Cost = 8, Capacity = 48  
  - To City 4: Cost = 8, Capacity = 58  
  - To City 5: Cost = 10, Capacity = 39  
  - To City 6: Cost = 8, Capacity = 60  
  - To City 7: Cost = 6, Capacity = 54  
  - To City 8: Cost = 9, Capacity = 31  

- **From City 1**:  
  - To City 0: Cost = 10, Capacity = 39  
  - To City 2: Cost = 8, Capacity = 31  
  - To City 3: Cost = 9, Capacity = 56  
  - To City 4: Cost = 8, Capacity = 60  
  - To City 5: Cost = 9, Capacity = 37  
  - To City 6: Cost = 10, Capacity = 54  
  - To City 7: Cost = 9, Capacity = 39  
  - To City 8: Cost = 7, Capacity = 50  

- **From City 2**:  
  - To City 0: Cost = 10, Capacity = 31  
  - To City 1: Cost = 6, Capacity = 35  
  - To City 3: Cost = 7, Capacity = 50  
  - To City 4: Cost = 7, Capacity = 53  
  - To City 5: Cost = 9, Capacity = 36  
  - To City 6: Cost = 10, Capacity = 48  
  - To City 7: Cost = 8, Capacity = 46  
  - To City 8: Cost = 10, Capacity = 60  

- **From City 3**:  
  - To City 0: Cost = 7, Capacity = 50  
  - To City 1: Cost = 6, Capacity = 38  
  - To City 2: Cost = 7, Capacity = 39  
  - To City 4: Cost = 10, Capacity = 47  
  - To City 5: Cost = 10, Capacity = 37  
  - To City 6: Cost = 6, Capacity = 54  
  - To City 7: Cost = 7, Capacity = 44  
  - To City 8: Cost = 10, Capacity = 55  

- **From City 4**:  
  - To City 0: Cost = 9, Capacity = 31  
  - To City 1: Cost = 8, Capacity = 31  
  - To City 2: Cost = 7, Capacity = 30  
  - To City 3: Cost = 7, Capacity = 40  
  - To City 5: Cost = 6, Capacity = 60  
  - To City 6: Cost = 6, Capacity = 46  
  - To City 7: Cost = 7, Capacity = 31  
  - To City 8: Cost = 9, Capacity = 49  

- **From City 5**:  
  - To City 0: Cost = 7, Capacity = 34  
  - To City 1: Cost = 7, Capacity = 30  
  - To City 2: Cost = 6, Capacity = 51  
  - To City 3: Cost = 8, Capacity = 32  
  - To City 4: Cost = 9, Capacity = 33  
  - To City 6: Cost = 7, Capacity = 47  
  - To City 7: Cost = 7, Capacity = 42  
  - To City 8: Cost = 8, Capacity = 43  

- **From City 6**:  
  - To City 0: Cost = 8, Capacity = 55  
  - To City 1: Cost = 7, Capacity = 48  
  - To City 2: Cost = 7, Capacity = 35  
  - To City 3: Cost = 7, Capacity = 31  
  - To City 4: Cost = 8, Capacity = 43  
  - To City 5: Cost = 8, Capacity = 56  
  - To City 7: Cost = 6, Capacity = 41  
  - To City 8: Cost = 6, Capacity = 55  

- **From City 7**:  
  - To City 0: Cost = 7, Capacity = 31  
  - To City 1: Cost = 6, Capacity = 31  
  - To City 2: Cost = 9, Capacity = 38  
  - To City 3: Cost = 8, Capacity = 34  
  - To City 4: Cost = 7, Capacity = 31  
  - To City 5: Cost = 8, Capacity = 40  
  - To City 6: Cost = 9, Capacity = 39  
  - To City 8: Cost = 6, Capacity = 42  

- **From City 8**:  
  - To City 0: Cost = 8, Capacity = 48  
  - To City 1: Cost = 8, Capacity = 60  
  - To City 2: Cost = 8, Capacity = 36  
  - To City 3: Cost = 10, Capacity = 47  
  - To City 4: Cost = 8, Capacity = 32  
  - To City 5: Cost = 7, Capacity = 36  
  - To City 6: Cost = 6, Capacity = 57  
  - To City 7: Cost = 10, Capacity = 35  

#### Objective:
Your task is to determine the optimal amount of resources to ship between cities to meet all demands and supplies while minimizing the total transportation cost. The shipments must respect the capacity limits of each route, and the total flow of resources into and out of each city must balance according to their respective requirements.

#### Constraints:
1. **Flow Balance**: For each city, the total resources shipped into the city plus its supply must equal the total resources shipped out of the city plus its demand.
2. **Capacity Limits**: The amount of resources shipped on any route cannot exceed the maximum capacity for that route.
3. **Non-Negativity**: All shipments must be non-negative.

By carefully planning the shipments, you aim to achieve the lowest possible total cost while ensuring all cities receive the resources they need.","\[
\begin{aligned}
\min\quad & \sum_{i=0}^{8}\sum_{\substack{j=0\\ j\neq i}}^{8} c_{ij}\,x_{ij} \\[4pt]
\text{s.t.}\quad & \sum_{\substack{j=0\\ j\neq i}}^{8} x_{ji} - \sum_{\substack{j=0\\ j\neq i}}^{8} x_{ij} = d_i 
\quad \forall i=0,\dots,8 \\[4pt]
& 0 \le x_{ij} \le u_{ij} 
\quad \forall i,j=0,\dots,8,\ i\neq j \\[4pt]
& x_{ij}\in\mathbb{R}_+ 
\quad \forall i,j=0,\dots,8,\ i\neq j
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB
import numpy as np

# Example data
n = 9
np.random.seed(0)
c = np.random.rand(n, n)
np.fill_diagonal(c, 0)          # no self__oops
u = np.random.rand(n, n) * 10
np.fill_diagonal(u, 0)          # capacity zero on diagonal
d = np.random.randint(-5, 6, size=n)

# Create model
m = gp.Model(""NetworkFlow"")

# Decision variables x[i,j] for i != j
x = m.addVars(n, n, lb=0, ub=u, vtype=GRB.CONTINUOUS, name=""x"")

# Flow conservation constraints
for i in range(n):
    inflow = gp.quicksum(x[j, i] for j in range(n) if j != i)
    outflow = gp.quicksum(x[i, j] for j in range(n) if j != i)
    m.addConstr(inflow - outflow == d[i], name=f""balance_{i}"")

# Objective: minimize total cost
obj = gp.quicksum(c[i, j] * x[i, j] for i in range(n) for j in range(n) if i != j)
m.setObjective(obj, GRB.MINIMIZE)

# Optimize
m.optimize()",,493,0,,,,,,,,
"Imagine you are managing the distribution of goods across a network of eight cities. Each city has a specific supply or demand for goods, and your goal is to ensure that all cities receive the goods they need while minimizing the total transportation costs. The transportation costs vary depending on the route taken between cities, and each route has a maximum capacity for the amount of goods that can be shipped.

#### **Cities and Their Requirements:**
- **City 0** has a net demand of **86 units** of goods.
- **City 1** has a net demand of **19 units** of goods.
- **City 2** has a net supply of **23 units** of goods (meaning it can send out 23 units).
- **City 3** has a net supply of **37 units** of goods.
- **City 4** has a net supply of **24 units** of goods.
- **City 5** has a balanced supply and demand, meaning it neither supplies nor demands goods.
- **City 6** has a net demand of **4 units** of goods.
- **City 7** has a net supply of **25 units** of goods.

#### **Transportation Costs and Capacities:**
The cost of shipping goods between cities varies, and each route has a maximum capacity. Below are the costs and capacities for each possible route:

- **From City 0:**
  - To City 1: Cost = **9**, Capacity = **44**
  - To City 2: Cost = **6**, Capacity = **47**
  - To City 3: Cost = **8**, Capacity = **60**
  - To City 4: Cost = **7**, Capacity = **40**
  - To City 5: Cost = **7**, Capacity = **39**
  - To City 6: Cost = **10**, Capacity = **40**
  - To City 7: Cost = **7**, Capacity = **52**

- **From City 1:**
  - To City 0: Cost = **6**, Capacity = **32**
  - To City 2: Cost = **7**, Capacity = **59**
  - To City 3: Cost = **6**, Capacity = **58**
  - To City 4: Cost = **8**, Capacity = **58**
  - To City 5: Cost = **7**, Capacity = **51**
  - To City 6: Cost = **6**, Capacity = **31**
  - To City 7: Cost = **6**, Capacity = **34**

- **From City 2:**
  - To City 0: Cost = **10**, Capacity = **59**
  - To City 1: Cost = **10**, Capacity = **49**
  - To City 3: Cost = **9**, Capacity = **51**
  - To City 4: Cost = **9**, Capacity = **39**
  - To City 5: Cost = **10**, Capacity = **34**
  - To City 6: Cost = **6**, Capacity = **47**
  - To City 7: Cost = **6**, Capacity = **55**

- **From City 3:**
  - To City 0: Cost = **9**, Capacity = **60**
  - To City 1: Cost = **7**, Capacity = **34**
  - To City 2: Cost = **7**, Capacity = **30**
  - To City 4: Cost = **7**, Capacity = **32**
  - To City 5: Cost = **9**, Capacity = **43**
  - To City 6: Cost = **7**, Capacity = **30**
  - To City 7: Cost = **10**, Capacity = **43**

- **From City 4:**
  - To City 0: Cost = **9**, Capacity = **57**
  - To City 1: Cost = **9**, Capacity = **38**
  - To City 2: Cost = **6**, Capacity = **54**
  - To City 3: Cost = **10**, Capacity = **46**
  - To City 5: Cost = **6**, Capacity = **30**
  - To City 6: Cost = **9**, Capacity = **48**
  - To City 7: Cost = **7**, Capacity = **43**

- **From City 5:**
  - To City 0: Cost = **9**, Capacity = **44**
  - To City 1: Cost = **6**, Capacity = **35**
  - To City 2: Cost = **8**, Capacity = **32**
  - To City 3: Cost = **7**, Capacity = **58**
  - To City 4: Cost = **8**, Capacity = **56**
  - To City 6: Cost = **6**, Capacity = **48**
  - To City 7: Cost = **8**, Capacity = **49**

- **From City 6:**
  - To City 0: Cost = **9**, Capacity = **52**
  - To City 1: Cost = **10**, Capacity = **48**
  - To City 2: Cost = **7**, Capacity = **33**
  - To City 3: Cost = **8**, Capacity = **39**
  - To City 4: Cost = **10**, Capacity = **36**
  - To City 5: Cost = **10**, Capacity = **47**
  - To City 7: Cost = **9**, Capacity = **49**

- **From City 7:**
  - To City 0: Cost = **6**, Capacity = **38**
  - To City 1: Cost = **8**, Capacity = **44**
  - To City 2: Cost = **10**, Capacity = **33**
  - To City 3: Cost = **6**, Capacity = **30**
  - To City 4: Cost = **10**, Capacity = **60**
  - To City 5: Cost = **7**, Capacity = **39**
  - To City 6: Cost = **8**, Capacity = **55**

#### **Objective:**
Your task is to determine the optimal amount of goods to ship between each pair of cities to meet all demands and supplies while minimizing the total transportation cost. The total cost is calculated by summing the cost of shipping goods across all routes, weighted by the amount shipped on each route.

#### **Constraints:**
1. **Flow Balance:** For each city, the total amount of goods shipped into the city plus its own supply must equal the total amount shipped out of the city plus its demand.
2. **Capacity Limits:** The amount of goods shipped on any route cannot exceed the maximum capacity of that route.
3. **Non-Negativity:** The amount of goods shipped on any route must be zero or positive.

By carefully planning the shipments, you aim to ensure that all cities receive the goods they need while keeping the total transportation costs as low as possible.","\[
\begin{aligned}
\min \quad & 9x_{01}+6x_{02}+8x_{03}+7x_{04}+7x_{05}+10x_{06}+7x_{07} \\
& +6x_{10}+7x_{12}+6x_{13}+8x_{14}+7x_{15}+6x_{16}+6x_{17} \\
& +10x_{20}+10x_{21}+9x_{23}+9x_{24}+10x_{25}+6x_{26}+6x_{27} \\
& +9x_{30}+7x_{31}+7x_{32}+7x_{34}+9x_{35}+7x_{36}+10x_{37} \\
& +9x_{40}+9x_{41}+6x_{42}+10x_{43}+6x_{45}+9x_{46}+7x_{47} \\
& +9x_{50}+6x_{51}+8x_{52}+7x_{53}+8x_{54}+6x_{56}+8x_{57} \\
& +9x_{60}+10x_{61}+7x_{62}+8x_{63}+10x_{64}+10x_{65}+9x_{67} \\
& +6x_{70}+8x_{71}+10x_{72}+6x_{73}+10x_{74}+7x_{75}+8x_{76} \\
\text{s.t.}\quad
& \sum_{j\neq 0}x_{j0}-\sum_{j\neq 0}x_{0j}=86 \\
& \sum_{j\neq 1}x_{j1}-\sum_{j\neq 1}x_{1j}=19 \\
& \sum_{j\neq 2}x_{j2}-\sum_{j\neq 2}x_{2j}=-23 \\
& \sum_{j\neq 3}x_{j3}-\sum_{j\neq 3}x_{3j}=-37 \\
& \sum_{j\neq 4}x_{j4}-\sum_{j\neq 4}x_{4j}=-24 \\
& \sum_{j\neq 5}x_{j5}-\sum_{j\neq 5}x_{5j}=0 \\
& \sum_{j\neq 6}x_{j6}-\sum_{j\neq 6}x_{6j}=4 \\
& \sum_{j\neq 7}x_{j7}-\sum_{j\neq 7}x_{7j}=-25 \\
& 0\le x_{01}\le 44,\; 0\le x_{02}\le 47,\; 0\le x_{03}\le 60,\; 0\le x_{04}\le 40,\; 0\le x_{05}\le 39,\; 0\le x_{06}\le 40,\; 0\le x_{07}\le 52 \\
& 0\le x_{10}\le 32,\; 0\le x_{12}\le 59,\; 0\le x_{13}\le 58,\; 0\le x_{14}\le 58,\; 0\le x_{15}\le 51,\; 0\le x_{16}\le 31,\; 0\le x_{17}\le 34 \\
& 0\le x_{20}\le 59,\; 0\le x_{21}\le 49,\; 0\le x_{23}\le 51,\; 0\le x_{24}\le 39,\; 0\le x_{25}\le 34,\; 0\le x_{26}\le 47,\; 0\le x_{27}\le 55 \\
& 0\le x_{30}\le 60,\; 0\le x_{31}\le 34,\; 0\le x_{32}\le 30,\; 0\le x_{34}\le 32,\; 0\le x_{35}\le 43,\; 0\le x_{36}\le 30,\; 0\le x_{37}\le 43 \\
& 0\le x_{40}\le 57,\; 0\le x_{41}\le 38,\; 0\le x_{42}\le 54,\; 0\le x_{43}\le 46,\; 0\le x_{45}\le 30,\; 0\le x_{46}\le 48,\; 0\le x_{47}\le 43 \\
& 0\le x_{50}\le 44,\; 0\le x_{51}\le 35,\; 0\le x_{52}\le 32,\; 0\le x_{53}\le 58,\; 0\le x_{54}\le 56,\; 0\le x_{56}\le 48,\; 0\le x_{57}\le 49 \\
& 0\le x_{60}\le 52,\; 0\le x_{61}\le 48,\; 0\le x_{62}\le 33,\; 0\le x_{63}\le 39,\; 0\le x_{64}\le 36,\; 0\le x_{65}\le 47,\; 0\le x_{67}\le 49 \\
& 0\le x_{70}\le 38,\; 0\le x_{71}\le 44,\; 0\le x_{72}\le 33,\; 0\le x_{73}\le 30,\; 0\le x_{74}\le 60,\; 0\le x_{75}\le 39,\; 0\le x_{76}\le 55 \\
& x_{ij}\in\mathbb{R}_+ \quad \forall\, i,j\in\{0,\dots,7\},\, i\neq j
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Flow_Optimization"")

# Bounds for each variable (i,j)
bounds = {
    (0,1):44, (0,2):47, (0,3):60, (0,4):40, (0,5):39, (0,6):40, (0,7):52,
    (1,0):32, (1,2):59, (1,3):58, (1,4):58, (1,5):51, (1,6):31, (1,7):34,
    (2,0):59, (2,1):49, (2,3):51, (2,4):39, (2,5):34, (2,6):47, (2,7):55,
    (3,0):60, (3,1):34, (3,2):30, (3,4):32, (3,5):43, (3,6):30, (3,7):43,
    (4,0):57, (4,1):38, (4,2):54, (4,3):46, (4,5):30, (4,6):48, (4,7):43,
    (5,0):44, (5,1):35, (5,2):32, (5,3):58, (5,4):56, (5,6):48, (5,7):49,
    (6,0):52, (6,1):48, (6,2):33, (6,3):39, (6,4):36, (6,5):47, (6,7):49,
    (7,0):38, (7,1):44, (7,2):33, (7,3):30, (7,4):60, (7,5):39, (7,6):55
}

# Coefficients for objective
coeffs = {
    (0,1):9, (0,2):6, (0,3):8, (0,4):7, (0,5):7, (0,6):10, (0,7):7,
    (1,0):6, (1,2):7, (1,3):6, (1,4):8, (1,5):7, (1,6):6, (1,7):6,
    (2,0):10, (2,1):10, (2,3):9, (2,4):9, (2,5):10, (2,6):6, (2,7):6,
    (3,0):9, (3,1):7, (3,2):7, (3,4):7, (3,5):9, (3,6):7, (3,7):10,
    (4,0):9, (4,1):9, (4,2):6, (4,3):10, (4,5):6, (4,6):9, (4,7):7,
    (5,0):9, (5,1):6, (5,2):8, (5,3):7, (5,4):8, (5,6):6, (5,7):8,
    (6,0):9, (6,1):10, (6,2):7, (6,3):8, (6,4):10, (6,5):10, (6,7):9,
    (7,0):6, (7,1):8, (7,2):10, (7,3):6, (7,4):10, (7,5):7, (7,6):8
}

# Net flow for each node
net = {0:86, 1:19, 2:-23, 3:-37, 4:-24, 5:0, 6:4, 7:-25}

# Decision variables
x = m.addVars(bounds.keys(), lb=0, name=""x"")
for (i,j), ub in bounds.items():
    x[i,j].ub = ub

# Objective: minimize total cost
m.setObjective(gp.quicksum(coeffs[i,j]*x[i,j] for (i,j) in x.keys()), GRB.MINIMIZE)

# Flow balance constraints
for k in range(8):
    incoming = gp.quicksum(x[j,k] for j in range(8) if j!=k)
    outgoing = gp.quicksum(x[k,j] for j in range(8) if j!=k)
    m.addConstr(incoming - outgoing == net[k], name=f""balance_{k}"")

# Optimize
m.optimize()
",875,875,1,,,,,,,,
"Assign seven staff members (Person 0 to Person 6) to three projects (Project 0, Project 1, and Project 2) such that each staff member is assigned to exactly one project. Each project has specific skill requirements: Project 0 requires a skill level of 8 for Skill 0 and 8 for Skill 1, Project 1 requires a skill level of 7 for Skill 0 and 9 for Skill 1, and Project 2 requires a skill level of 9 for Skill 0 and 7 for Skill 1. Each staff member has specific skill levels: Person 0 has Skill 0 level 5 and Skill 1 level 7, Person 1 has Skill 0 level 6 and Skill 1 level 7, Person 2 has Skill 0 level 5 and Skill 1 level 7, Person 3 has Skill 0 level 6 and Skill 1 level 7, Person 4 has Skill 0 level 5 and Skill 1 level 6, Person 5 has Skill 0 level 5 and Skill 1 level 6, and Person 6 has Skill 0 level 5 and Skill 1 level 7. The attained skill level for each project is the sum of the skill levels of the assigned staff members. The skill shortage for each project is the difference between the required skill level and the attained skill level. The goal is to minimize the maximum skill shortage across all projects and skills. Constraints include ensuring that each staff member is assigned to exactly one project, and that the skill shortages for Project 0, Skill 0 must be less than or equal to -8, for Project 0, Skill 1 must be less than or equal to -8, for Project 1, Skill 0 must be less than or equal to -7, for Project 1, Skill 1 must be less than or equal to -9, for Project 2, Skill 0 must be less than or equal to -9, and for Project 2, Skill 1 must be less than or equal to -7.","\[
\begin{aligned}
\min\quad & t\\
\text{s.t.}\quad & x_{0,i}+x_{1,i}+x_{2,i}=1 && \forall i=0,\dots,6\\
& s_{0,0}+5x_{0,0}+6x_{0,1}+5x_{0,2}+6x_{0,3}+5x_{0,4}+5x_{0,5}+5x_{0,6}=8\\
& s_{0,1}+7x_{0,0}+7x_{0,1}+7x_{0,2}+7x_{0,3}+6x_{0,4}+6x_{0,5}+7x_{0,6}=8\\
& s_{1,0}+5x_{1,0}+6x_{1,1}+5x_{1,2}+6x_{1,3}+5x_{1,4}+5x_{1,5}+5x_{1,6}=7\\
& s_{1,1}+7x_{1,0}+7x_{1,1}+7x_{1,2}+7x_{1,3}+6x_{1,4}+6x_{1,5}+7x_{1,6}=9\\
& s_{2,0}+5x_{2,0}+6x_{2,1}+5x_{2,2}+6x_{2,3}+5x_{2,4}+5x_{2,5}+5x_{2,6}=9\\
& s_{2,1}+7x_{2,0}+7x_{2,1}+7x_{2,2}+7x_{2,3}+6x_{2,4}+6x_{2,5}+7x_{2,6}=7\\
& s_{0,0}\le -8,\; s_{0,1}\le -8,\; s_{1,0}\le -7,\; s_{1,1}\le -9,\; s_{2,0}\le -9,\; s_{2,1}\le -7\\
& t\ge s_{0,0},\; t\ge s_{0,1},\; t\ge s_{1,0},\; t\ge s_{1,1},\; t\ge s_{2,0},\; t\ge s_{2,1}\\
& x_{p,i}\in\{0,1\}\quad \forall p=0,1,2,\; i=0,\dots,6\\
& s_{p,s}\in\mathbb{R}\quad \forall p=0,1,2,\; s=0,1\\
& t\in\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""OptimizationModel"")

# Decision variables
x = m.addVars(3, 7, vtype=GRB.BINARY, name=""x"")
s = m.addVars(3, 2, vtype=GRB.CONTINUOUS, name=""s"")
t = m.addVar(vtype=GRB.CONTINUOUS, name=""t"")

# Objective: minimize t
m.setObjective(t, GRB.MINIMIZE)

# Coefficients and constants
coeff1 = [5, 6, 5, 6, 5, 5, 5]
coeff2 = [7, 7, 7, 7, 6, 6, 7]
const1 = [8, 7, 9]   # for s_{p,0}
const2 = [8, 9, 7]   # for s_{p,1}
const_s = [[8, 8],   # s_{0,0} <= -8, s_{0,1} <= -8
           [7, 9],   # s_{1,0} <= -7, s_{1,1} <= -9
           [9, 7]]   # s_{2,0} <= -9, s_{2,1} <= -7

# Constraint: each column sums to 1
for i in range(7):
    m.addConstr(gp.quicksum(x[p, i] for p in range(3)) == 1, name=f""col_{i}"")

# Constraints for s variables
for p in range(3):
    # First set
    m.addConstr(s[p, 0] + gp.quicksum(coeff1[i] * x[p, i] for i in range(7)) == const1[p],
                name=f""s_{p}_0"")
    # Second set
    m.addConstr(s[p, 1] + gp.quicksum(coeff2[i] * x[p, i] for i in range(7)) == const2[p],
                name=f""s_{p}_1"")

# s <= -constant constraints
for p in range(3):
    for s_idx in range(2):
        m.addConstr(s[p, s_idx] <= -const_s[p][s_idx], name=f""s_{p}_{s_idx}_leq"")

# t >= s constraints
for p in range(3):
    for s_idx in range(2):
        m.addConstr(t >= s[p, s_idx], name=f""t_geq_s_{p}_{s_idx}"")

# Optimize
m.optimize()
",,0,1,,,,,,,,
"The problem involves scheduling six jobs, labeled Job 0 through Job 5, in a manufacturing facility. Each job consists of two operations that must be performed in a specific sequence. The goal is to minimize the total completion time, known as the makespan, by determining the start times for all operations and the order of operations on shared machines. Each operation has a processing time of 1 unit of time. Operations within the same job must follow a strict sequence, meaning the second operation cannot start until the first operation has completed. Certain operations are assigned to the same machine, and these operations cannot overlap in time. To enforce this, binary decision variables are used to determine the order of operations on shared machines. For example, if Operation 1 of Job 1 is scheduled before Operation 1 of Job 3 on the same machine, the start time of Operation 1 of Job 3 must be at least 1 unit of time after the completion of Operation 1 of Job 1. The makespan is defined as the maximum completion time across all operations, and it must be at least as large as the completion time of every operation. The constraints include precedence constraints within jobs, ensuring that each operation starts only after the previous operation in the same job has completed; machine capacity constraints, ensuring that operations assigned to the same machine do not overlap; and non-negativity constraints, ensuring that all start times are non-negative. The objective is to minimize the makespan, ensuring that all jobs are completed as quickly as possible. The binary decision variables, such as those determining the order of Operation 1 of Job 1 and Operation 1 of Job 3, are critical in enforcing the machine capacity constraints. The numerical parameters include a large constant (100000) used in the constraints involving binary variables to ensure the correct sequencing of operations on shared machines. The start times and the makespan are general variables that can take on any real value within the bounds defined by the constraints.","\[
\begin{aligned}
\min\quad & C \\[4pt]
\text{s.t.}\quad 
& s_{j,2}\;\ge\;s_{j,1}+1 && \forall j=0,\dots,5 \\[4pt]
& s_{i,1}+1\;\le\;s_{j,1}+M\,(1-x_{i,j}) && \forall 0\le i<j\le5 \\[4pt]
& s_{j,1}+1\;\le\;s_{i,1}+M\,x_{i,j} && \forall 0\le i<j\le5 \\[4pt]
& s_{i,2}+1\;\le\;s_{j,2}+M\,(1-z_{i,j}) && \forall 0\le i<j\le5 \\[4pt]
& s_{j,2}+1\;\le\;s_{i,2}+M\,z_{i,j} && \forall 0\le i<j\le5 \\[4pt]
& C\;\ge\;s_{j,k}+1 && \forall j=0,\dots,5,\;k=1,2 \\[4pt]
& s_{j,k}\;\ge\;0 && \forall j=0,\dots,5,\;k=1,2 \\[4pt]
& C\;\ge\;0 \\[4pt]
& x_{i,j}\in\{0,1\} && \forall 0\le i<j\le5 \\[4pt]
& z_{i,j}\in\{0,1\} && \forall 0\le i<j\le5
\end{aligned}
\]
where \(M=100000\).  
Domain: \(s_{j,k}\in\mathbb{R}_+\), \(C\in\mathbb{R}_+\), \(x_{i,j},z_{i,j}\in\{0,1\}\).","import gurobipy as gp
from gurobipy import GRB

M = 100000
n = 6

m = gp.Model(""Scheduling"")

C = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""C"")
s = m.addVars(n, 2, lb=0, vtype=GRB.CONTINUOUS, name=""s"")
x = m.addVars(n, n, vtype=GRB.BINARY, name=""x"")
z = m.addVars(n, n, vtype=GRB.BINARY, name=""z"")

for j in range(n):
    m.addConstr(s[j, 1] >= s[j, 0] + 1, name=f""stage2_ge_stage1_{j}"")

for i in range(n):
    for j in range(i + 1, n):
        m.addConstr(s[i, 0] + 1 <= s[j, 0] + M * (1 - x[i, j]), name=f""seq1_{i}_{j}"")
        m.addConstr(s[j, 0] + 1 <= s[i, 0] + M * x[i, j], name=f""seq1_rev_{i}_{j}"")
        m.addConstr(s[i, 1] + 1 <= s[j, 1] + M * (1 - z[i, j]), name=f""seq2_{i}_{j}"")
        m.addConstr(s[j, 1] + 1 <= s[i, 1] + M * z[i, j], name=f""seq2_rev_{i}_{j}"")

for j in range(n):
    for k in range(2):
        m.addConstr(C >= s[j, k] + 1, name=f""C_ge_s_{j}_{k}"")

m.setObjective(C, GRB.MINIMIZE)

m.optimize()",2,5,0,,,,,,,,
"You are tasked with planning the most efficient route for a delivery service that must visit seven cities: City 0, City 1, City 2, City 3, City 4, City 5, and City 6. The goal is to minimize the total travel cost while ensuring that each city is visited exactly once and that the delivery route forms a complete loop, starting and ending at the same city. The travel costs between each pair of cities are as follows: From City 0 to City 1 costs 285, to City 2 costs 275, to City 3 costs 303, to City 4 costs 282, to City 5 costs 308, and to City 6 costs 290. From City 1 to City 0 costs 293, to City 2 costs 291, to City 3 costs 319, to City 4 costs 295, to City 5 costs 294, and to City 6 costs 324. From City 2 to City 0 costs 309, to City 1 costs 325, to City 3 costs 313, to City 4 costs 292, to City 5 costs 275, and to City 6 costs 320. From City 3 to City 0 costs 307, to City 1 costs 286, to City 2 costs 305, to City 4 costs 297, to City 5 costs 299, and to City 6 costs 278. From City 4 to City 0 costs 320, to City 1 costs 313, to City 2 costs 278, to City 3 costs 300, to City 5 costs 318, and to City 6 costs 325. From City 5 to City 0 costs 281, to City 1 costs 291, to City 2 costs 305, to City 3 costs 285, to City 4 costs 298, and to City 6 costs 292. From City 6 to City 0 costs 323, to City 1 costs 296, to City 2 costs 307, to City 3 costs 295, to City 4 costs 293, and to City 5 costs 301. Each city must be visited by exactly one incoming route and must have exactly one outgoing route. To ensure the route forms a single loop and does not break into smaller disconnected cycles, the position of each city in the tour is tracked. The position of each city must be an integer between 0 and 6, and if a route from City i to City j is taken, the position of City i must be at least one less than the position of City j. The objective is to minimize the total travel cost across all routes while ensuring all constraints are satisfied.","\[
\begin{aligned}
\min \quad & 285\,x_{0,1}+275\,x_{0,2}+303\,x_{0,3}+282\,x_{0,4}+308\,x_{0,5}+290\,x_{0,6} \\
& +293\,x_{1,0}+291\,x_{1,2}+319\,x_{1,3}+295\,x_{1,4}+294\,x_{1,5}+324\,x_{1,6} \\
& +309\,x_{2,0}+325\,x_{2,1}+313\,x_{2,3}+292\,x_{2,4}+275\,x_{2,5}+320\,x_{2,6} \\
& +307\,x_{3,0}+286\,x_{3,1}+305\,x_{3,2}+297\,x_{3,4}+299\,x_{3,5}+278\,x_{3,6} \\
& +320\,x_{4,0}+313\,x_{4,1}+278\,x_{4,2}+300\,x_{4,3}+318\,x_{4,5}+325\,x_{4,6} \\
& +281\,x_{5,0}+291\,x_{5,1}+305\,x_{5,2}+285\,x_{5,3}+298\,x_{5,4}+292\,x_{5,6} \\
& +323\,x_{6,0}+296\,x_{6,1}+307\,x_{6,2}+295\,x_{6,3}+293\,x_{6,4}+301\,x_{6,5} \\[4pt]
\text{s.t.}\quad & \sum_{\substack{j=0\\ j\neq i}}^{6} x_{i,j}=1 && \forall\,i=0,\dots,6 \\[2pt]
& \sum_{\substack{i=0\\ i\neq j}}^{6} x_{i,j}=1 && \forall\,j=0,\dots,6 \\[2pt]
& y_i-y_j+7\,x_{i,j}\le 6 && \forall\,i\neq j \\[2pt]
& 0\le y_i\le 6 && \forall\,i=0,\dots,6 \\[2pt]
& x_{i,j}\in\{0,1\} && \forall\,i\neq j \\[2pt]
& y_i\in\mathbb{Z} && \forall\,i=0,\dots,6
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

n = 7
cost = {
    (0,1):285,(0,2):275,(0,3):303,(0,4):282,(0,5):308,(0,6):290,
    (1,0):293,(1,2):291,(1,3):319,(1,4):295,(1,5):294,(1,6):324,
    (2,0):309,(2,1):325,(2,3):313,(2,4):292,(2,5):275,(2,6):320,
    (3,0):307,(3,1):286,(3,2):305,(3,4):297,(3,5):299,(3,6):278,
    (4,0):320,(4,1):313,(4,2):278,(4,3):300,(4,5):318,(4,6):325,
    (5,0):281,(5,1):291,(5,2):305,(5,3):285,(5,4):298,(5,6):292,
    (6,0):323,(6,1):296,(6,2):307,(6,3):295,(6,4):293,(6,5):301
}

m = gp.Model(""TSP"")

x = m.addVars([(i,j) for i in range(n) for j in range(n) if i!=j], vtype=GRB.BINARY, name=""x"")
y = m.addVars(range(n), vtype=GRB.INTEGER, name=""y"")

# Row constraints: each node has exactly one outgoing arc
for i in range(n):
    m.addConstr(gp.quicksum(x[i,j] for j in range(n) if i!=j) == 1, name=f""row_{i}"")

# Column constraints: each node has exactly one incoming arc
for j in range(n):
    m.addConstr(gp.quicksum(x[i,j] for i in range(n) if i!=j) == 1, name=f""col_{j}"")

# Ordering constraints to eliminate subtours
for i in range(n):
    for j in range(n):
        if i != j:
            m.addConstr(y[i] - y[j] + 7*x[i,j] <= 6, name=f""order_{i}_{j}"")

# Bounds on y variables
for i in range(n):
    m.addConstr(y[i] >= 0, name=f""y_low_{i}"")
    m.addConstr(y[i] <= 6, name=f""y_up_{i}"")

# Objective: minimize total cost
m.setObjective(gp.quicksum(cost[i,j]*x[i,j] for i,j in x.keys()), GRB.MINIMIZE)

m.optimize()",1.987000e+03,1987,1,,,,,,,,
"There are six jobs, each consisting of two operations that must be performed in a specific order. Each operation takes 1 unit of time to complete. Operations are assigned to shared machines, and each machine can handle only one operation at a time. The goal is to schedule the operations to minimize the total completion time, known as the makespan, which is the latest completion time of all operations.

For each job, the second operation cannot start until the first operation is completed. If two operations are assigned to the same machine, they must be scheduled in a specific order, determined by binary decision variables. These variables indicate whether one operation starts before or after the other on the same machine. A large constant, 100,000, is used to enforce the sequencing logic in the constraints.

The start times of all operations must be non-negative, and the makespan must be at least as large as the completion time of every operation. The objective is to determine the start times for all operations and the order in which they are processed on shared machines, ensuring that all precedence constraints are satisfied, overlaps on shared machines are avoided, and the makespan is minimized.","\[
\begin{aligned}
\text{Parameters: } & J=\{1,\dots,6\},\; K=\{1,2\},\; M\in\mathbb{Z}_+ \\
\min\quad & C \\
\text{s.t.}\quad
& \sum_{m=1}^{M} a_{j,k,m}=1 && \forall j\in J,\; k\in K \\
& s_{j,2}\ge s_{j,1}+1 && \forall j\in J \\
& s_{j_1,k_1}+1 \le s_{j_2,k_2} + 100000\bigl(1-y_{(j_1,k_1),(j_2,k_2)}\bigr) + 100000\bigl(1-a_{j_1,k_1,m}\bigr) + 100000\bigl(1-a_{j_2,k_2,m}\bigr) && \forall (j_1,k_1)<(j_2,k_2),\; m=1,\dots,M \\
& s_{j_2,k_2}+1 \le s_{j_1,k_1} + 100000\,y_{(j_1,k_1),(j_2,k_2)} + 100000\bigl(1-a_{j_1,k_1,m}\bigr) + 100000\bigl(1-a_{j_2,k_2,m}\bigr) && \forall (j_1,k_1)<(j_2,k_2),\; m=1,\dots,M \\
& C \ge s_{j,k}+1 && \forall j\in J,\; k\in K \\
& s_{j,k}\ge 0 && \forall j\in J,\; k\in K \\
& a_{j,k,m}\in\{0,1\} && \forall j\in J,\; k\in K,\; m=1,\dots,M \\
& y_{(j_1,k_1),(j_2,k_2)}\in\{0,1\} && \forall (j_1,k_1)<(j_2,k_2) \\
& C\in\mathbb{R}_+ && 
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Parameters
J = range(1, 7)          # Jobs 1..6
K = [1, 2]               # Two stages
M = 3                    # Number of machines (example value)

# Create model
m = gp.Model(""Scheduling_Model"")

# Decision variables
a = m.addVars(J, K, range(1, M+1), vtype=GRB.BINARY, name=""a"")
y = {}
# Generate all ordered pairs (j1,k1) < (j2,k2) lexicographically
pairs = [(j1, k1, j2, k2) for j1 in J for k1 in K for j2 in J for k2 in K if (j1, k1) < (j2, k2)]
for (j1, k1, j2, k2) in pairs:
    y[(j1, k1, j2, k2)] = m.addVar(vtype=GRB.BINARY, name=f""y_{j1}_{k1}_{j2}_{k2}"")

s = m.addVars(J, K, vtype=GRB.CONTINUOUS, lb=0, name=""s"")
C = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""C"")

# Constraints
# Each job-stage assigned to exactly one machine
for j in J:
    for k in K:
        m.addConstr(gp.quicksum(a[j, k, m_] for m_ in range(1, M+1)) == 1, name=f""assign_{j}_{k}"")

# Stage ordering within each job
for j in J:
    m.addConstr(s[j, 2] >= s[j, 1] + 1, name=f""stage_order_{j}"")

# Sequencing constraints with big-M
BIG = 100000
for (j1, k1, j2, k2) in pairs:
    for m_ in range(1, M+1):
        # If both jobs are on machine m_ and y=0, then j1 before j2
        m.addConstr(
            s[j1, k1] + 1 <= s[j2, k2] + BIG * (1 - y[(j1, k1, j2, k2)]) + BIG * (1 - a[j1, k1, m_]) + BIG * (1 - a[j2, k2, m_]),
            name=f""seq1_{j1}_{k1}_{j2}_{k2}_m{m_}""
        )
        # If both jobs are on machine m_ and y=1, then j2 before j1
        m.addConstr(
            s[j2, k2] + 1 <= s[j1, k1] + BIG * y[(j1, k1, j2, k2)] + BIG * (1 - a[j1, k1, m_]) + BIG * (1 - a[j2, k2, m_]),
            name=f""seq2_{j1}_{k1}_{j2}_{k2}_m{m_}""
        )

# Makespan constraints
for j in J:
    for k in K:
        m.addConstr(C >= s[j, k] + 1, name=f""makespan_{j}_{k}"")

# Objective: minimize makespan
m.setObjective(C, GRB.MINIMIZE)

# Optimize
m.optimize()

# Print results
if m.status == GRB.OPTIMAL:
    print(f""Optimal makespan C = {C.X}"")
    for j in J:
        for k in K:
            print(f""s[{j},{k}] = {s[j, k].X}"")
    for j in J:
        for k in K:
            for m_ in range(1, M+1):
                if a[j, k, m_].X > 0.5:
                    print(f""Job {j} stage {k} assigned to machine {m_}"")
    for (j1, k1, j2, k2) in pairs:
        if y[(j1, k1, j2, k2)].X > 0.5:
            print(f""Job {j1}-{k1} scheduled after Job {j2}-{k2}"")
else:
    print(""No optimal solution found."")",2,5,0,,,,,,,,
"There are five jobs, each consisting of two operations that must be performed in a specific order. The first operation of each job must finish before the second operation of the same job can start. All operations are assigned to shared machines, and no two operations on the same machine can overlap in time. The goal is to schedule the operations such that the total completion time, or makespan, is minimized. 

Each operation has a processing time of 1 unit. For each job, the start time of the second operation must be at least 1 unit after the start time of the first operation. For every pair of operations assigned to the same machine, one operation must finish before the other can start, enforced by binary decision variables that determine the order of operations on the machine. A large constant (100,000) is used in the constraints to ensure that operations do not overlap on the same machine. The makespan must be at least as large as the completion time of every operation. 

The decision variables include the start time of each operation and the binary variables that determine the order of operations on shared machines. The objective is to minimize the makespan while satisfying all precedence and machine constraints.","\[
\begin{aligned}
\min \quad & C \\[4pt]
\text{s.t.} \quad
& s_{2j-1} + 1 \;\le\; s_{2j} \qquad &&\forall j=1,\dots,5 \\[4pt]
& s_i + 1 \;\le\; s_j + M(1-b_{ij}) \qquad &&\forall 1\le i<j\le 10 \\[4pt]
& s_j + 1 \;\le\; s_i + M\,b_{ij} \qquad &&\forall 1\le i<j\le 10 \\[4pt]
& C \;\ge\; s_o + 1 \qquad &&\forall o=1,\dots,10 \\[4pt]
& s_o \;\ge\; 0 \qquad &&\forall o=1,\dots,10 \\[4pt]
& C \;\ge\; 0 \\[4pt]
& b_{ij} \in \{0,1\} \qquad &&\forall 1\le i<j\le 10 \\[4pt]
& s_o \in \mathbb{R}_+ \qquad &&\forall o=1,\dots,10 \\[4pt]
& C \in \mathbb{R}_+ \\[4pt]
\text{where } M &= 100\,000
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Scheduling_Optimization"")

# Parameters
M = 100000

# Decision variables
s = m.addVars(10, lb=0, vtype=GRB.CONTINUOUS, name=""s"")          # s_1 ... s_10
b = m.addVars(10, 10, vtype=GRB.BINARY, name=""b"")                # b_ij for i<j
C = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""C"")               # objective variable

# Constraints
# Pairwise ordering constraints s_{2j-1} + 1 <= s_{2j}
for j in range(5):
    m.addConstr(s[2*j] + 1 <= s[2*j + 1], name=f""pair_{j+1}"")

# Ordering constraints with binary variables
for i in range(10):
    for j in range(i+1, 10):
        m.addConstr(s[i] + 1 <= s[j] + M * (1 - b[i, j]), name=f""order1_{i+1}_{j+1}"")
        m.addConstr(s[j] + 1 <= s[i] + M * b[i, j], name=f""order2_{i+1}_{j+1}"")

# C bounds relative to s_o
for o in range(10):
    m.addConstr(C >= s[o] + 1, name=f""C_ge_s{o+1}"")

# Objective
m.setObjective(C, GRB.MINIMIZE)

# Optimize
m.optimize()",2,3,0,,,,,,,,
"You are tasked with managing the logistics of a supply chain network involving seven key facilities (nodes) that produce and distribute goods. Each facility has specific supply and demand requirements, and the goal is to minimize the total cost of establishing connections between facilities and transporting goods while ensuring all demands are met.

Facility 0 has a net demand of 106 units, Facility 1 has a net demand of 144 units, Facility 2 has no net supply or demand, Facility 3 has no net supply or demand, Facility 4 has a net demand of 202 units, Facility 5 has a net demand of 40 units, and Facility 6 has a net demand of 8 units.

Establishing a connection between any two facilities incurs a fixed cost, and transporting goods between them incurs a variable cost per unit. Each connection has a maximum capacity for goods that can be transported. The fixed costs, variable costs, and maximum capacities for each possible connection are as follows:

- Fixed Costs (for establishing connections):
  - Facility 0 to Facility 1: 1985 units
  - Facility 0 to Facility 2: 1968 units
  - Facility 0 to Facility 3: 2043 units
  - Facility 0 to Facility 4: 2035 units
  - Facility 0 to Facility 5: 2043 units
  - Facility 0 to Facility 6: 1987 units
  - Facility 1 to Facility 0: 2035 units
  - Facility 1 to Facility 2: 2044 units
  - Facility 1 to Facility 3: 1985 units
  - Facility 1 to Facility 4: 2047 units
  - Facility 1 to Facility 5: 2003 units
  - Facility 1 to Facility 6: 2005 units
  - Facility 2 to Facility 0: 2000 units
  - Facility 2 to Facility 1: 1991 units
  - Facility 2 to Facility 3: 2005 units
  - Facility 2 to Facility 4: 1969 units
  - Facility 2 to Facility 5: 2010 units
  - Facility 2 to Facility 6: 1965 units
  - Facility 3 to Facility 0: 1962 units
  - Facility 3 to Facility 1: 2024 units
  - Facility 3 to Facility 2: 2025 units
  - Facility 3 to Facility 4: 2043 units
  - Facility 3 to Facility 5: 2034 units
  - Facility 3 to Facility 6: 2017 units
  - Facility 4 to Facility 0: 1974 units
  - Facility 4 to Facility 1: 2012 units
  - Facility 4 to Facility 2: 2009 units
  - Facility 4 to Facility 3: 1993 units
  - Facility 4 to Facility 5: 1991 units
  - Facility 4 to Facility 6: 2040 units
  - Facility 5 to Facility 0: 2044 units
  - Facility 5 to Facility 1: 2022 units
  - Facility 5 to Facility 2: 2025 units
  - Facility 5 to Facility 3: 1955 units
  - Facility 5 to Facility 4: 2001 units
  - Facility 5 to Facility 6: 2029 units
  - Facility 6 to Facility 0: 1968 units
  - Facility 6 to Facility 1: 1956 units
  - Facility 6 to Facility 2: 1986 units
  - Facility 6 to Facility 3: 2030 units
  - Facility 6 to Facility 4: 2001 units
  - Facility 6 to Facility 5: 1961 units

- Variable Costs (per unit transported):
  - Facility 0 to Facility 1: 19 units
  - Facility 0 to Facility 2: 19 units
  - Facility 0 to Facility 3: 19 units
  - Facility 0 to Facility 4: 19 units
  - Facility 0 to Facility 5: 21 units
  - Facility 0 to Facility 6: 21 units
  - Facility 1 to Facility 0: 21 units
  - Facility 1 to Facility 2: 19 units
  - Facility 1 to Facility 3: 20 units
  - Facility 1 to Facility 4: 20 units
  - Facility 1 to Facility 5: 21 units
  - Facility 1 to Facility 6: 21 units
  - Facility 2 to Facility 0: 21 units
  - Facility 2 to Facility 1: 19 units
  - Facility 2 to Facility 3: 21 units
  - Facility 2 to Facility 4: 21 units
  - Facility 2 to Facility 5: 21 units
  - Facility 2 to Facility 6: 20 units
  - Facility 3 to Facility 0: 21 units
  - Facility 3 to Facility 1: 19 units
  - Facility 3 to Facility 2: 21 units
  - Facility 3 to Facility 4: 19 units
  - Facility 3 to Facility 5: 19 units
  - Facility 3 to Facility 6: 20 units
  - Facility 4 to Facility 0: 21 units
  - Facility 4 to Facility 1: 21 units
  - Facility 4 to Facility 2: 21 units
  - Facility 4 to Facility 3: 20 units
  - Facility 4 to Facility 5: 20 units
  - Facility 4 to Facility 6: 19 units
  - Facility 5 to Facility 0: 21 units
  - Facility 5 to Facility 1: 19 units
  - Facility 5 to Facility 2: 20 units
  - Facility 5 to Facility 3: 20 units
  - Facility 5 to Facility 4: 20 units
  - Facility 5 to Facility 6: 21 units
  - Facility 6 to Facility 0: 19 units
  - Facility 6 to Facility 1: 21 units
  - Facility 6 to Facility 2: 19 units
  - Facility 6 to Facility 3: 20 units
  - Facility 6 to Facility 4: 21 units
  - Facility 6 to Facility 5: 21 units

- Maximum Capacities (for goods transported):
  - Facility 0 to Facility 1: 153 units
  - Facility 0 to Facility 2: 202 units
  - Facility 0 to Facility 3: 185 units
  - Facility 0 to Facility 4: 134 units
  - Facility 0 to Facility 5: 248 units
  - Facility 0 to Facility 6: 170 units
  - Facility 1 to Facility 0: 214 units
  - Facility 1 to Facility 2: 184 units
  - Facility 1 to Facility 3: 193 units
  - Facility 1 to Facility 4: 181 units
  - Facility 1 to Facility 5: 153 units
  - Facility 1 to Facility 6: 139 units
  - Facility 2 to Facility 0: 217 units
  - Facility 2 to Facility 1: 238 units
  - Facility 2 to Facility 3: 231 units
  - Facility 2 to Facility 4: 130 units
  - Facility 2 to Facility 5: 203 units
  - Facility 2 to Facility 6: 232 units
  - Facility 3 to Facility 0: 147 units
  - Facility 3 to Facility 1: 222 units
  - Facility 3 to Facility 2: 129 units
  - Facility 3 to Facility 4: 206 units
  - Facility 3 to Facility 5: 202 units
  - Facility 3 to Facility 6: 134 units
  - Facility 4 to Facility 0: 183 units
  - Facility 4 to Facility 1: 210 units
  - Facility 4 to Facility 2: 238 units
  - Facility 4 to Facility 3: 193 units
  - Facility 4 to Facility 5: 157 units
  - Facility 4 to Facility 6: 137 units
  - Facility 5 to Facility 0: 134 units
  - Facility 5 to Facility 1: 128 units
  - Facility 5 to Facility 2: 241 units
  - Facility 5 to Facility 3: 143 units
  - Facility 5 to Facility 4: 198 units
  - Facility 5 to Facility 6: 213 units
  - Facility 6 to Facility 0: 213 units
  - Facility 6 to Facility 1: 206 units
  - Facility 6 to Facility 2: 184 units
  - Facility 6 to Facility 3: 231 units
  - Facility 6 to Facility 4: 207 units
  - Facility 6 to Facility 5: 165 units

Decide whether to establish a connection between each pair of facilities, where establishing a connection incurs a fixed cost. Determine the amount of goods to transport between connected facilities, ensuring that the total flow does not exceed the connection's capacity. The total incoming goods minus the total outgoing goods must equal the facility's net demand for each facility. The decision to establish a connection is binary. The goal is to minimize the total cost, which includes both the fixed costs of establishing connections and the variable costs of transporting goods.","\[
\begin{aligned}
\min\;&\sum_{i=0}^{6}\sum_{\substack{j=0\\j\neq i}}^{6}\Bigl(F_{ij}\,y_{ij}+V_{ij}\,f_{ij}\Bigr)\\
\text{s.t.}\;&\sum_{\substack{j=0\\j\neq i}}^{6}f_{ji}-\sum_{\substack{j=0\\j\neq i}}^{6}f_{ij}=d_i,\qquad i=0,\dots,6\\
&f_{ij}\le C_{ij}\,y_{ij},\qquad i=0,\dots,6,\;j=0,\dots,6,\;j\neq i\\
&f_{ij}\ge0,\qquad i=0,\dots,6,\;j=0,\dots,6,\;j\neq i\\
&y_{ij}\in\{0,1\},\qquad i=0,\dots,6,\;j=0,\dots,6,\;j\neq i\\
&f_{ij}\in\mathbb{R}_+,\qquad i=0,\dots,6,\;j=0,\dots,6,\;j\neq i
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB
import numpy as np

# Example data (replace with actual data)
F = np.random.rand(7,7)
V = np.random.rand(7,7)
C = np.random.rand(7,7)*10
d = np.random.randint(-5,6,size=7)

np.fill_diagonal(F,0)
np.fill_diagonal(V,0)
np.fill_diagonal(C,0)

m = gp.Model(""Network_Design"")

y = m.addVars(7,7, vtype=GRB.BINARY, name=""y"")
f = m.addVars(7,7, vtype=GRB.CONTINUOUS, lb=0, name=""f"")

obj = gp.quicksum(F[i,j]*y[i,j] + V[i,j]*f[i,j] for i in range(7) for j in range(7) if i!=j)
m.setObjective(obj, GRB.MINIMIZE)

for i in range(7):
    inflow = gp.quicksum(f[j,i] for j in range(7) if j!=i)
    outflow = gp.quicksum(f[i,j] for j in range(7) if j!=i)
    m.addConstr(inflow - outflow == d[i], name=f""flow_conservation_{i}"")

for i in range(7):
    for j in range(7):
        if i!=j:
            m.addConstr(f[i,j] <= C[i,j]*y[i,j], name=f""capacity_{i}_{j}"")

m.optimize()",,13022,0,,,,,,,,
"A logistics company must deliver packages to six cities: City 0, City 1, City 2, City 3, City 4, and City 5. Each city must be visited exactly once, and each city must be departed exactly once, ensuring the route forms a continuous loop. The goal is to minimize the total delivery cost, which is the sum of the costs of traveling between the cities. The costs between cities are as follows:  

- From City 0: To City 1 costs 321, to City 2 costs 294, to City 3 costs 323, to City 4 costs 286, and to City 5 costs 325.  
- From City 1: To City 0 costs 290, to City 2 costs 319, to City 3 costs 321, to City 4 costs 280, and to City 5 costs 324.  
- From City 2: To City 0 costs 304, to City 1 costs 317, to City 3 costs 322, to City 4 costs 313, and to City 5 costs 300.  
- From City 3: To City 0 costs 312, to City 1 costs 324, to City 2 costs 280, to City 4 costs 318, and to City 5 costs 284.  
- From City 4: To City 0 costs 289, to City 1 costs 279, to City 2 costs 278, to City 3 costs 301, and to City 5 costs 324.  
- From City 5: To City 0 costs 325, to City 1 costs 309, to City 2 costs 304, to City 3 costs 305, and to City 4 costs 310.  

To prevent smaller loops that do not include all cities, the company uses position variables for each city. These variables represent the order in which the cities are visited. The position variables for City 1 to City 5 must be between 0 and 5, while the position variable for City 0 has no specified bounds. Additionally, constraints ensure that if a route is taken from one city to another, the position of the first city must be less than the position of the second city, adjusted by a factor to eliminate subtours. The objective is to minimize the total delivery cost, including the sum of all route costs, while satisfying all constraints.","\[
\begin{aligned}
\min \quad & 321x_{01}+294x_{02}+323x_{03}+286x_{04}+325x_{05} \\
& + 290x_{10}+319x_{12}+321x_{13}+280x_{14}+324x_{15} \\
& + 304x_{20}+317x_{21}+322x_{23}+313x_{24}+300x_{25} \\
& + 312x_{30}+324x_{31}+280x_{32}+318x_{34}+284x_{35} \\
& + 289x_{40}+279x_{41}+278x_{42}+301x_{43}+324x_{45} \\
& + 325x_{50}+309x_{51}+304x_{52}+305x_{53}+310x_{54} \\
\text{s.t.}\quad & \sum_{j=0,\,j\neq i}^{5} x_{ij}=1 && \forall i=0,\dots,5 \\
& \sum_{i=0,\,i\neq j}^{5} x_{ij}=1 && \forall j=0,\dots,5 \\
& x_{ii}=0 && \forall i=0,\dots,5 \\
& x_{ij}\in\{0,1\} && \forall i,j=0,\dots,5,\; i\neq j \\
& u_i\in\mathbb{Z} && \forall i=1,\dots,5 \\
& 0\le u_i\le 5 && \forall i=1,\dots,5 \\
& u_0\in\mathbb{Z} \\
& u_i-u_j+6x_{ij}\le 5 && \forall i,j=1,\dots,5,\; i\neq j
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Cost matrix
c = {
    (0,1):321, (0,2):294, (0,3):323, (0,4):286, (0,5):325,
    (1,0):290, (1,2):319, (1,3):321, (1,4):280, (1,5):324,
    (2,0):304, (2,1):317, (2,3):322, (2,4):313, (2,5):300,
    (3,0):312, (3,1):324, (3,2):280, (3,4):318, (3,5):284,
    (4,0):289, (4,1):279, (4,2):278, (4,3):301, (4,5):324,
    (5,0):325, (5,1):309, (5,2):304, (5,3):305, (5,4):310
}

nodes = range(6)

m = gp.Model(""TSP_MTZ"")

# Decision variables
x = m.addVars(nodes, nodes, vtype=GRB.BINARY, name=""x"")

# Auxiliary variables u_i for i=1..5
u = m.addVars(range(1,6), vtype=GRB.INTEGER, lb=0, ub=5, name=""u"")

# Objective
m.setObjective(gp.quicksum(c[i,j]*x[i,j] for i in nodes for j in nodes if i!=j), GRB.MINIMIZE)

# Outgoing constraints
for i in nodes:
    m.addConstr(gp.quicksum(x[i,j] for j in nodes if j!=i) == 1, name=f""out_{i}"")

# Incoming constraints
for j in nodes:
    m.addConstr(gp.quicksum(x[i,j] for i in nodes if i!=j) == 1, name=f""in_{j}"")

# MTZ subtour elimination
for i in range(1,6):
    for j in range(1,6):
        if i!=j:
            m.addConstr(u[i]-u[j]+6*x[i,j] <= 5, name=f""mtz_{i}_{j}"")

# Solve
m.optimize()
",1766,1766,1,,,,,,,,
"Maximize the total population covered by deploying cell towers across 35 distinct areas, ensuring that the total cost of building the towers does not exceed the available budget of 2,697 units. The population of each area is as follows: Area 0 has 3,870 people, Area 1 has 4,020 people, Area 2 has 2,440 people, Area 3 has 4,263 people, Area 4 has 2,727 people, Area 5 has 3,650 people, Area 6 has 3,155 people, Area 7 has 4,805 people, Area 8 has 2,213 people, Area 9 has 3,635 people, Area 10 has 3,262 people, Area 11 has 4,015 people, Area 12 has 4,991 people, Area 13 has 2,657 people, Area 14 has 2,150 people, Area 15 has 3,655 people, Area 16 has 2,141 people, Area 17 has 2,108 people, Area 18 has 4,200 people, Area 19 has 3,137 people, Area 20 has 4,255 people, Area 21 has 3,452 people, Area 22 has 2,155 people, Area 23 has 3,142 people, Area 24 has 4,909 people, Area 25 has 2,865 people, Area 26 has 3,204 people, Area 27 has 4,244 people, Area 28 has 4,975 people, Area 29 has 2,131 people, Area 30 has 4,710 people, Area 31 has 4,721 people, Area 32 has 4,061 people, Area 33 has 3,162 people, and Area 34 has 3,377 people.

For each of the 27 potential cell tower locations, decide whether to build the tower, where building a tower incurs a specific cost: Tower 0 costs 233 units, Tower 1 costs 216 units, Tower 2 costs 366 units, Tower 3 costs 264 units, Tower 4 costs 413 units, Tower 5 costs 332 units, Tower 6 costs 414 units, Tower 7 costs 233 units, Tower 8 costs 432 units, Tower 9 costs 461 units, Tower 10 costs 465 units, Tower 11 costs 248 units, Tower 12 costs 392 units, Tower 13 costs 244 units, Tower 14 costs 416 units, Tower 15 costs 399 units, Tower 16 costs 448 units, Tower 17 costs 212 units, Tower 18 costs 216 units, Tower 19 costs 224 units, Tower 20 costs 489 units, Tower 21 costs 288 units, Tower 22 costs 256 units, Tower 23 costs 308 units, Tower 24 costs 325 units, Tower 25 costs 359 units, and Tower 26 costs 339 units.

Each area must be covered by at least one of the built towers. For example, Area 0 can be covered by Towers 0, 3, 4, 5, 8, 11, 12, 13, 14, 15, 17, 19, 21, 22, 25, or 26; Area 1 can be covered by Towers 0, 4, 5, 7, 9, 12, 13, 17, 18, 19, 20, 21, 23, or 26; and similar coverage relationships apply to all 35 areas. The decisions to build towers and cover areas are binary, meaning you cannot partially build a tower or partially cover an area. The goal is to maximize the total population covered while ensuring the total cost of building the selected towers does not exceed the budget.","\[
\begin{aligned}
\max\quad & 3870\,z_0+4020\,z_1+2440\,z_2+4263\,z_3+2727\,z_4+3650\,z_5+3155\,z_6+4805\,z_7\\
&\quad+2213\,z_8+3635\,z_9+3262\,z_{10}+4015\,z_{11}+4991\,z_{12}+2657\,z_{13}+2150\,z_{14}\\
&\quad+3655\,z_{15}+2141\,z_{16}+2108\,z_{17}+4200\,z_{18}+3137\,z_{19}+4255\,z_{20}+3452\,z_{21}\\
&\quad+2155\,z_{22}+3142\,z_{23}+4909\,z_{24}+2865\,z_{25}+3204\,z_{26}+4244\,z_{27}+4975\,z_{28}\\
&\quad+2131\,z_{29}+4710\,z_{30}+4721\,z_{31}+4061\,z_{32}+3162\,z_{33}+3377\,z_{34} \\
\text{s.t.}\quad & 233\,y_0+216\,y_1+366\,y_2+264\,y_3+413\,y_4+332\,y_5+414\,y_6+233\,y_7\\
&\quad+432\,y_8+461\,y_9+465\,y_{10}+248\,y_{11}+392\,y_{12}+244\,y_{13}+416\,y_{14}\\
&\quad+399\,y_{15}+448\,y_{16}+212\,y_{17}+216\,y_{18}+224\,y_{19}+489\,y_{20}+288\,y_{21}\\
&\quad+256\,y_{22}+308\,y_{23}+325\,y_{24}+359\,y_{25}+339\,y_{26}\;\le\;2697,\\
& z_a \;\le\; \sum_{t\in C_a} y_t \qquad \forall a=0,\dots,34,\\
& y_t \in \{0,1\}\qquad \forall t=0,\dots,26,\\
& z_a \in \{0,1\}\qquad \forall a=0,\dots,34.
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Objective coefficients for z_a (a = 0..34)
c_z = [3870, 4020, 2440, 4263, 2727, 3650, 3155, 4805, 2213, 3635,
       3262, 4015, 4991, 2657, 2150, 3655, 2141, 2108, 4200, 3137,
       4255, 3452, 2155, 3142, 4909, 2865, 3204, 4244, 4975, 2131,
       4710, 4721, 4061, 3162, 3377]

# Coefficients for y_t (t = 0..26)
c_y = [233, 216, 366, 264, 413, 332, 414, 233, 432, 461,
       465, 248, 392, 244, 416, 399, 448, 212, 216, 224,
       489, 288, 256, 308, 325, 359, 339]

# Placeholder sets C_a: each z_a can be activated by any y_t
C_a = {a: list(range(27)) for a in range(35)}

# Create model
m = gp.Model(""Optimization"")

# Decision variables
y = m.addVars(27, vtype=GRB.BINARY, name=""y"")
z = m.addVars(35, vtype=GRB.BINARY, name=""z"")

# Objective: maximize sum of c_z[a] * z[a]
m.setObjective(gp.quicksum(c_z[a] * z[a] for a in range(35)), GRB.MAXIMIZE)

# Resource constraint
m.addConstr(gp.quicksum(c_y[t] * y[t] for t in range(27)) <= 2697, name=""resource"")

# Constraints: z_a <= sum_{t in C_a} y_t
for a in range(35):
    m.addConstr(z[a] <= gp.quicksum(y[t] for t in C_a[a]), name=f""z_le_sum_{a}"")

# Optimize
m.optimize()

# Print solution
if m.status == GRB.OPTIMAL:
    print(""Optimal objective:"", m.objVal)
    print(""y values:"")
    for t in range(27):
        print(f""y[{t}] = {y[t].X}"")
    print(""z values:"")
    for a in range(35):
        print(f""z[{a}] = {z[a].X}"")",122457,122457,1,,,,,,,,
"The problem involves scheduling 7 jobs, each consisting of 2 operations, on a set of machines to minimize the total production time, or makespan. Each operation has a processing time of 1 unit of time. Operations within the same job must follow a specific sequence: operation 0 must be completed before operation 1 can begin. Some operations from different jobs are assigned to the same machine, and the machine can only process one operation at a time. The order in which operations are scheduled on a shared machine is determined by binary decision variables, which take a value of 1 if one operation is scheduled before another and 0 otherwise. A large constant of 100,000 is used to enforce that operations on the same machine do not overlap in time. The makespan must be at least as large as the completion time of every operation, ensuring it accounts for the longest-running job. Start times for all operations must be non-negative, and the binary variables must be either 0 or 1. Specific machine assignments include operations (4,1), (5,0), and (6,0) on one machine; (0,1) and (3,0) on another; (0,0), (2,0), and (4,0) on another; and (1,0), (1,1), (2,1), (3,1), and (5,1) on another. The objective is to determine the start times for all operations and the order in which operations are processed on shared machines to minimize the makespan while respecting the sequence of operations within each job and ensuring no overlaps on shared machines.","\[
\begin{aligned}
\min\quad & C \\[4pt]
\text{s.t.}\quad
& s_{j,1}\;\ge\;s_{j,0}+1 && \forall j=0,\dots,6 \\[4pt]
& s_{4,1}+1 \;\le\; s_{5,0}+M\bigl(1-y_{(4,1),(5,0)}\bigr) \\ 
& s_{5,0}+1 \;\le\; s_{4,1}+M\,y_{(4,1),(5,0)} \\[2pt]
& s_{4,1}+1 \;\le\; s_{6,0}+M\bigl(1-y_{(4,1),(6,0)}\bigr) \\ 
& s_{6,0}+1 \;\le\; s_{4,1}+M\,y_{(4,1),(6,0)} \\[2pt]
& s_{5,0}+1 \;\le\; s_{6,0}+M\bigl(1-y_{(5,0),(6,0)}\bigr) \\ 
& s_{6,0}+1 \;\le\; s_{5,0}+M\,y_{(5,0),(6,0)} \\[4pt]
& s_{0,1}+1 \;\le\; s_{3,0}+M\bigl(1-y_{(0,1),(3,0)}\bigr) \\ 
& s_{3,0}+1 \;\le\; s_{0,1}+M\,y_{(0,1),(3,0)} \\[4pt]
& s_{0,0}+1 \;\le\; s_{2,0}+M\bigl(1-y_{(0,0),(2,0)}\bigr) \\ 
& s_{2,0}+1 \;\le\; s_{0,0}+M\,y_{(0,0),(2,0)} \\[2pt]
& s_{0,0}+1 \;\le\; s_{4,0}+M\bigl(1-y_{(0,0),(4,0)}\bigr) \\ 
& s_{4,0}+1 \;\le\; s_{0,0}+M\,y_{(0,0),(4,0)} \\[2pt]
& s_{2,0}+1 \;\le\; s_{4,0}+M\bigl(1-y_{(2,0),(4,0)}\bigr) \\ 
& s_{4,0}+1 \;\le\; s_{2,0}+M\,y_{(2,0),(4,0)} \\[4pt]
& \text{(Machine_4 pairs)} \\[2pt]
& s_{1,0}+1 \;\le\; s_{1,1}+M\bigl(1-y_{(1,0),(1,1)}\bigr) \\ 
& s_{1,1}+1 \;\le\; s_{1,0}+M\,y_{(1,0),(1,1)} \\[2pt]
& s_{1,0}+1 \;\le\; s_{2,1}+M\bigl(1-y_{(1,0),(2,1)}\bigr) \\ 
& s_{2,1}+1 \;\le\; s_{1,0}+M\,y_{(1,0),(2,1)} \\[2pt]
& s_{1,0}+1 \;\le\; s_{3,1}+M\bigl(1-y_{(1,0),(3,1)}\bigr) \\ 
& s_{3,1}+1 \;\le\; s_{1,0}+M\,y_{(1,0),(3,1)} \\[2pt]
& s_{1,0}+1 \;\le\; s_{5,1}+M\bigl(1-y_{(1,0),(5,1)}\bigr) \\ 
& s_{5,1}+1 \;\le\; s_{1,0}+M\,y_{(1,0),(5,1)} \\[2pt]
& s_{1,1}+1 \;\le\; s_{2,1}+M\bigl(1-y_{(1,1),(2,1)}\bigr) \\ 
& s_{2,1}+1 \;\le\; s_{1,1}+M\,y_{(1,1),(2,1)} \\[2pt]
& s_{1,1}+1 \;\le\; s_{3,1}+M\bigl(1-y_{(1,1),(3,1)}\bigr) \\ 
& s_{3,1}+1 \;\le\; s_{1,1}+M\,y_{(1,1),(3,1)} \\[2pt]
& s_{1,1}+1 \;\le\; s_{5,1}+M\bigl(1-y_{(1,1),(5,1)}\bigr) \\ 
& s_{5,1}+1 \;\le\; s_{1,1}+M\,y_{(1,1),(5,1)} \\[2pt]
& s_{2,1}+1 \;\le\; s_{3,1}+M\bigl(1-y_{(2,1),(3,1)}\bigr) \\ 
& s_{3,1}+1 \;\le\; s_{2,1}+M\,y_{(2,1),(3,1)} \\[2pt]
& s_{2,1}+1 \;\le\; s_{5,1}+M\bigl(1-y_{(2,1),(5,1)}\bigr) \\ 
& s_{5,1}+1 \;\le\; s_{2,1}+M\,y_{(2,1),(5,1)} \\[2pt]
& s_{3,1}+1 \;\le\; s_{5,1}+M\bigl(1-y_{(3,1),(5,1)}\bigr) \\ 
& s_{5,1}+1 \;\le\; s_{3,1}+M\,y_{(3,1),(5,1)} \\[4pt]
& C \;\ge\; s_{j,o}+1 && \forall j=0,\dots,6,\; o=0,1 \\[4pt]
& s_{j,o}\;\ge\;0 && \forall j,o \\[4pt]
& y_{(i,o),(k,o')}\;\in\;\{0,1\} && \text{for all pairs above} \\[4pt]
& C\;\ge\;0
\end{aligned}
\]

\[
\text{Parameters:}\quad M=100\,000
\]

\[
\begin{aligned}
& s_{j,o}\in\mathbb{R}_+ ,\qquad
y_{(i,o),(k,o')}\in\{0,1\},\qquad
C\in\mathbb{R}_+ .
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Scheduling"")

# Parameters
M = 100000

# Decision variables: start times s[j,o] (j=0..6, o=0,1)
s = m.addVars(j=range(7), o=range(2), lb=0, vtype=GRB.CONTINUOUS, name=""s"")

# Makespan variable
C = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""C"")

# Precedence within each job
for j in range(7):
    m.addConstr(s[j,1] >= s[j,0] + 1, name=f""precedence_{j}"")

# Pairs of operations that share a machine
pairs = [
    ((4,1),(5,0)), ((4,1),(6,0)), ((5,0),(6,0)),
    ((0,1),(3,0)),
    ((0,0),(2,0)), ((0,0),(4,0)), ((2,0),(4,0)),
    ((1,0),(1,1)), ((1,0),(2,1)), ((1,0),(3,1)), ((1,0),(5,1)),
    ((1,1),(2,1)), ((1,1),(3,1)), ((1,1),(5,1)),
    ((2,1),(3,1)), ((2,1),(5,1)), ((3,1),(5,1))
]

# Binary variables for ordering of each pair
y = {}
for (i,o),(k,op) in pairs:
    var = m.addVar(vtype=GRB.BINARY, name=f""y_{i}_{o}_{k}_{op}"")
    y[(i,o,k,op)] = var
    # Disjunctive constraints
    m.addConstr(s[i,o] + 1 <= s[k,op] + M * (1 - var), name=f""order1_{i}_{o}_{k}_{op}"")
    m.addConstr(s[k,op] + 1 <= s[i,o] + M * var, name=f""order2_{i}_{o}_{k}_{op}"")

# Makespan constraints
for j in range(7):
    for o in range(2):
        m.addConstr(C >= s[j,o] + 1, name=f""makespan_{j}_{o}"")

# Objective: minimize makespan
m.setObjective(C, GRB.MINIMIZE)

# Optimize
m.optimize()",5,3,0,,,,,,,,
"The problem involves managing the distribution of a critical resource across seven interconnected cities: City 0, City 1, City 2, City 3, City 4, City 5, and City 6. The goal is to minimize the total cost of transporting resources between cities while ensuring that all demands are met and all operational constraints are satisfied. The cost of transporting resources from City 0 to City 1 is 2 units, from City 0 to City 2 is 1 unit, from City 0 to City 3 is 1 unit, from City 0 to City 4 is 3 units, from City 0 to City 5 is 3 units, and from City 0 to City 6 is 3 units. The cost of transporting resources from City 1 to City 0 is 2 units, from City 1 to City 2 is 1 unit, from City 1 to City 3 is 1 unit, from City 1 to City 4 is 1 unit, from City 1 to City 5 is 1 unit, and from City 1 to City 6 is 3 units. The cost of transporting resources from City 2 to City 0 is 2 units, from City 2 to City 1 is 2 units, from City 2 to City 3 is 3 units, from City 2 to City 4 is 2 units, from City 2 to City 5 is 1 unit, and from City 2 to City 6 is 3 units. The cost of transporting resources from City 3 to City 0 is 2 units, from City 3 to City 1 is 2 units, from City 3 to City 2 is 3 units, from City 3 to City 4 is 2 units, from City 3 to City 5 is 3 units, and from City 3 to City 6 is 1 unit. The cost of transporting resources from City 4 to City 0 is 1 unit, from City 4 to City 1 is 3 units, from City 4 to City 2 is 2 units, from City 4 to City 3 is 2 units, from City 4 to City 5 is 3 units, and from City 4 to City 6 is 2 units. The cost of transporting resources from City 5 to City 0 is 3 units, from City 5 to City 1 is 1 unit, from City 5 to City 2 is 1 unit, from City 5 to City 3 is 1 unit, from City 5 to City 4 is 2 units, and from City 5 to City 6 is 1 unit. The cost of transporting resources from City 6 to City 0 is 3 units, from City 6 to City 1 is 2 units, from City 6 to City 2 is 2 units, from City 6 to City 3 is 2 units, from City 6 to City 4 is 3 units, and from City 6 to City 5 is 1 unit.

Each city must maintain a balance between incoming and outgoing resources. City 0 must ensure that the total resources it sends out are balanced by the resources it receives from other cities. City 1 has a net demand of 1 unit, City 2 has a net surplus of 2 units, City 3 has a net demand of 2 units, City 4 has a net surplus of 2 units, City 5 has a net demand of 1 unit, and City 6 has no net demand or surplus. The route from City 0 to City 1 can handle up to 7 units of resources, from City 0 to City 2 up to 8 units, from City 0 to City 3 up to 9 units, from City 0 to City 4 up to 9 units, from City 0 to City 5 up to 9 units, and from City 0 to City 6 up to 8 units. The route from City 1 to City 0 can handle up to 8 units, from City 1 to City 2 up to 8 units, from City 1 to City 3 up to 8 units, from City 1 to City 4 up to 8 units, from City 1 to City 5 up to 7 units, and from City 1 to City 6 up to 8 units. The route from City 2 to City 0 can handle up to 8 units, from City 2 to City 1 up to 8 units, from City 2 to City 3 up to 8 units, from City 2 to City 4 up to 8 units, from City 2 to City 5 up to 7 units, and from City 2 to City 6 up to 9 units. The route from City 3 to City 0 can handle up to 8 units, from City 3 to City 1 up to 9 units, from City 3 to City 2 up to 8 units, from City 3 to City 4 up to 9 units, from City 3 to City 5 up to 9 units, and from City 3 to City 6 up to 8 units. The route from City 4 to City 0 can handle up to 7 units, from City 4 to City 1 up to 7 units, from City 4 to City 2 up to 9 units, from City 4 to City 3 up to 7 units, from City 4 to City 5 up to 8 units, and from City 4 to City 6 up to 7 units. The route from City 5 to City 0 can handle up to 9 units, from City 5 to City 1 up to 8 units, from City 5 to City 2 up to 7 units, from City 5 to City 3 up to 9 units, from City 5 to City 4 up to 9 units, and from City 5 to City 6 up to 9 units. The route from City 6 to City 0 can handle up to 7 units, from City 6 to City 1 up to 9 units, from City 6 to City 2 up to 9 units, from City 6 to City 3 up to 9 units, from City 6 to City 4 up to 9 units, and from City 6 to City 5 up to 7 units.

Each city has a maximum capacity for handling incoming resources. City 0 can receive up to 16 units, City 1 up to 15 units, City 2 up to 12 units, City 3 up to 15 units, City 4 up to 15 units, City 5 up to 15 units, and City 6 up to 17 units. The amount of resources transported between any two cities cannot be negative. The objective is to determine the optimal amount of resources to transport between cities to minimize the total transportation cost while ensuring that all cities meet their resource demands or surpluses, no transportation route exceeds its capacity, and no city exceeds its capacity for receiving resources.","\[
\begin{aligned}
\min\;&\sum_{i=0}^{6}\sum_{\substack{j=0\\ j\neq i}}^{6} c_{ij}\,x_{ij} \\[4pt]
\text{s.t. }&\sum_{\substack{j=0\\ j\neq i}}^{6}x_{ji}-\sum_{\substack{j=0\\ j\neq i}}^{6}x_{ij}=d_i
&&\forall\,i=0,\dots,6 \\[4pt]
&x_{ij}\leq u_{ij}\qquad &&\forall\,i\neq j \\[4pt]
&\sum_{\substack{j=0\\ j\neq i}}^{6}x_{ji}\leq U_i
&&\forall\,i=0,\dots,6 \\[4pt]
&x_{ij}\geq 0 \qquad &&\forall\,i\neq j \\[4pt]
&x_{ij}\in\mathbb{R}_+ \qquad &&\forall\,i\neq j
\end{aligned}
\]

where  

\[
\begin{array}{l}
c_{01}=2,\;c_{02}=1,\;c_{03}=1,\;c_{04}=3,\;c_{05}=3,\;c_{06}=3,\\
c_{10}=2,\;c_{12}=1,\;c_{13}=1,\;c_{14}=1,\;c_{15}=1,\;c_{16}=3,\\
c_{20}=2,\;c_{21}=2,\;c_{23}=3,\;c_{24}=2,\;c_{25}=1,\;c_{26}=3,\\
c_{30}=2,\;c_{31}=2,\;c_{32}=3,\;c_{34}=2,\;c_{35}=3,\;c_{36}=1,\\
c_{40}=1,\;c_{41}=3,\;c_{42}=2,\;c_{43}=2,\;c_{45}=3,\;c_{46}=2,\\
c_{50}=3,\;c_{51}=1,\;c_{52}=1,\;c_{53}=1,\;c_{54}=2,\;c_{56}=1,\\
c_{60}=3,\;c_{61}=2,\;c_{62}=2,\;c_{63}=2,\;c_{64}=3,\;c_{65}=1.
\end{array}
\]

\[
\begin{array}{l}
u_{01}=7,\;u_{02}=8,\;u_{03}=9,\;u_{04}=9,\;u_{05}=9,\;u_{06}=8,\\
u_{10}=8,\;u_{12}=8,\;u_{13}=8,\;u_{14}=8,\;u_{15}=7,\;u_{16}=8,\\
u_{20}=8,\;u_{21}=8,\;u_{23}=8,\;u_{24}=8,\;u_{25}=7,\;u_{26}=9,\\
u_{30}=8,\;u_{31}=9,\;u_{32}=8,\;u_{34}=9,\;u_{35}=9,\;u_{36}=8,\\
u_{40}=7,\;u_{41}=7,\;u_{42}=9,\;u_{43}=7,\;u_{45}=8,\;u_{46}=7,\\
u_{50}=9,\;u_{51}=8,\;u_{52}=7,\;u_{53}=9,\;u_{54}=9,\;u_{56}=9,\\
u_{60}=7,\;u_{61}=9,\;u_{62}=9,\;u_{63}=9,\;u_{64}=9,\;u_{65}=7.
\end{array}
\]

\[
\begin{array}{l}
U_0=16,\;U_1=15,\;U_2=12,\;U_3=15,\;U_4=15,\;U_5=15,\;U_6=17,\\
d_0=0,\;d_1=1,\;d_2=-2,\;d_3=2,\;d_4=-2,\;d_5=1,\;d_6=0.
\end{array}
\]","import gurobipy as gp
from gurobipy import GRB

# Data
c = [
    [0, 2, 1, 1, 3, 3, 3],
    [2, 0, 1, 1, 1, 1, 3],
    [2, 2, 0, 3, 2, 1, 3],
    [2, 2, 3, 0, 2, 3, 1],
    [1, 3, 2, 2, 0, 3, 2],
    [3, 1, 1, 1, 2, 0, 1],
    [3, 2, 2, 2, 3, 1, 0]
]

u = [
    [0, 7, 8, 9, 9, 9, 8],
    [8, 0, 8, 8, 8, 7, 8],
    [8, 8, 0, 8, 8, 7, 9],
    [8, 9, 8, 0, 9, 9, 8],
    [7, 7, 9, 7, 0, 8, 7],
    [9, 8, 7, 9, 9, 0, 9],
    [7, 9, 9, 9, 9, 7, 0]
]

U = [16, 15, 12, 15, 15, 15, 17]
d = [0, 1, -2, 2, -2, 1, 0]

# Create model
m = gp.Model(""Flow_Optimization"")

# Decision variables for i != j
x = m.addVars([(i, j) for i in range(7) for j in range(7) if i != j],
              lb=0, ub=GRB.INFINITY, vtype=GRB.CONTINUOUS, name=""x"")

# Objective: minimize total cost
m.setObjective(gp.quicksum(c[i][j] * x[i, j] for i, j in x.keys()), GRB.MINIMIZE)

# Flow balance constraints
for i in range(7):
    inflow = gp.quicksum(x[j, i] for j in range(7) if j != i)
    outflow = gp.quicksum(x[i, j] for j in range(7) if j != i)
    m.addConstr(inflow - outflow == d[i], name=f""balance_{i}"")

# Capacity constraints
for i, j in x.keys():
    m.addConstr(x[i, j] <= u[i][j], name=f""capacity_{i}_{j}"")

# Upper bound on incoming flow
for i in range(7):
    inflow = gp.quicksum(x[j, i] for j in range(7) if j != i)
    m.addConstr(inflow <= U[i], name=f""U_in_{i}"")

# Optimize
m.optimize()

# Print results
if m.status == GRB.OPTIMAL:
    print(f""Optimal objective: {m.objVal}"")
    for i, j in x.keys():
        if x[i, j].X > 1e-6:
            print(f""x[{i},{j}] = {x[i, j].X}"")",7,7,1,,,,,,,,
"The manufacturing facility produces three products over a six-month period, aiming to minimize total costs, including production, setup, and inventory holding costs, while meeting customer demand and adhering to resource constraints. Product 0 has cumulative demands of 75, 141, 241, 315, 386, and 469 units over the six months. Product 1 has cumulative demands of 65, 151, 228, 286, 338, and 390 units. Product 2 has cumulative demands of 57, 143, 193, 263, 363, and 428 units. Production costs per unit for Product 0 are $42, $47, $41, $40, $43, and $47 across the six months. For Product 1, they are $43, $50, $41, $50, $49, and $46. For Product 2, they are $42, $49, $40, $47, $49, and $45. Setup costs for Product 0 are $1,282, $1,493, $1,006, $1,286, $1,305, and $1,360. For Product 1, they are $1,402, $1,498, $1,296, $1,366, $1,376, and $1,172. For Product 2, they are $1,362, $1,094, $1,283, $1,279, $1,430, and $1,146. Inventory holding costs per unit for Product 0 are $4, $5, $4, $5, $4, and $4. For Product 1, they are $5, $5, $5, $4, $4, and $4. For Product 2, they are $5, $5, $4, $5, $5, and $4. The facility has monthly resource capacities of 1,173, 1,102, 1,018, 1,077, 1,190, and 1,132 units. Each unit of Product 0 consumes 1.778 resource units, Product 1 consumes 1.502, and Product 2 consumes 1.556. If a product is produced in a month, a setup cost is incurred, and production quantities are limited by setup decisions: Product 0 can produce up to 469, 394, 328, 228, 154, and 83 units; Product 1 up to 390, 325, 239, 162, 104, and 52 units; and Product 2 up to 428, 371, 285, 235, 165, and 65 units. Inventory at the end of each month must satisfy demand, and no initial or final inventory is allowed. The objective is to determine optimal production quantities, setup decisions, and inventory levels to minimize total costs while meeting demand and resource constraints.","\[
\begin{aligned}
\min\;&\sum_{t=1}^{6}\sum_{p=0}^{2}\Bigl(c_{p,t}\,x_{p,t}+s_{p,t}\,y_{p,t}+h_{p,t}\,I_{p,t}\Bigr)\\[4pt]
\text{s.t.}\;&I_{p,t}=I_{p,t-1}+x_{p,t}-d_{p,t}\quad\forall p=0,1,2,\;t=1,\dots,6\\
&x_{p,t}\leq M_{p,t}\,y_{p,t}\quad\forall p=0,1,2,\;t=1,\dots,6\\
&\sum_{p=0}^{2}r_{p}\,x_{p,t}\leq C_{t}\quad\forall t=1,\dots,6\\
&I_{p,0}=0,\;I_{p,6}=0\quad\forall p=0,1,2\\
&x_{p,t}\ge 0,\;I_{p,t}\ge 0\quad\forall p,t\\
&y_{p,t}\in\{0,1\}\quad\forall p,t
\end{aligned}
\]

where  

\[
\begin{array}{c|cccccc}
t & 1 & 2 & 3 & 4 & 5 & 6\\\hline
C_{t} & 1173 & 1102 & 1018 & 1077 & 1190 & 1132
\end{array}
\]

\[
\begin{array}{c|ccc}
p & 0 & 1 & 2\\\hline
r_{p} & 1.778 & 1.502 & 1.556
\end{array}
\]

\[
\begin{array}{c|cccccc}
p & 0 & 1 & 2\\\hline
c_{p,t} & 
\begin{array}{c}
42\\47\\41\\40\\43\\47
\end{array}
&
\begin{array}{c}
43\\50\\41\\50\\49\\46
\end{array}
&
\begin{array}{c}
42\\49\\40\\47\\49\\45
\end{array}
\\[4pt]
s_{p,t} & 
\begin{array}{c}
1282\\1493\\1006\\1286\\1305\\1360
\end{array}
&
\begin{array}{c}
1402\\1498\\1296\\1366\\1376\\1172
\end{array}
&
\begin{array}{c}
1362\\1094\\1283\\1279\\1430\\1146
\end{array}
\\[4pt]
h_{p,t} & 
\begin{array}{c}
4\\5\\4\\5\\4\\4
\end{array}
&
\begin{array}{c}
5\\5\\5\\4\\4\\4
\end{array}
&
\begin{array}{c}
5\\5\\4\\5\\5\\4
\end{array}
\\[4pt]
M_{p,t} & 
\begin{array}{c}
469\\394\\328\\228\\154\\83
\end{array}
&
\begin{array}{c}
390\\325\\239\\162\\104\\52
\end{array}
&
\begin{array}{c}
428\\371\\285\\235\\165\\65
\end{array}
\\[4pt]
d_{p,t} & 
\begin{array}{c}
75\\66\\100\\74\\71\\83
\end{array}
&
\begin{array}{c}
65\\86\\77\\58\\52\\52
\end{array}
&
\begin{array}{c}
57\\86\\50\\70\\100\\65
\end{array}
\end{array}
\]","import gurobipy as gp
from gurobipy import GRB
import numpy as np

# Data
C = np.array([1173, 1102, 1018, 1077, 1190, 1132])          # capacity per period
r = np.array([1.778, 1.502, 1.556])                         # resource usage per unit
c = np.array([[42, 47, 41, 40, 43, 47],
              [43, 50, 41, 50, 49, 46],
              [42, 49, 40, 47, 49, 45]])                  # production cost
s = np.array([[1282, 1493, 1006, 1286, 1305, 1360],
              [1402, 1498, 1296, 1366, 1376, 1172],
              [1362, 1094, 1283, 1279, 1430, 1146]])        # setup cost
h = np.array([[4, 5, 4, 5, 4, 4],
              [5, 5, 5, 4, 4, 4],
              [5, 5, 4, 5, 5, 4]])                         # holding cost
M = np.array([[469, 394, 328, 228, 154, 83],
              [390, 325, 239, 162, 104, 52],
              [428, 371, 285, 235, 165, 65]])              # max production per period
d = np.array([[75, 66, 100, 74, 71, 83],
              [65, 86, 77, 58, 52, 52],
              [57, 86, 50, 70, 100, 65]])                 # demand per period

P = len(r)          # number of products
T = len(C)          # number of periods

# Create model
m = gp.Model(""ProductionPlanning"")

# Decision variables
x = m.addVars(P, T, lb=0, vtype=GRB.CONTINUOUS, name=""x"")   # production
I = m.addVars(P, T+1, lb=0, vtype=GRB.CONTINUOUS, name=""I"") # inventory (t=0..T)
y = m.addVars(P, T, vtype=GRB.BINARY, name=""y"")             # setup

# Objective: minimize total cost
obj = gp.quicksum(c[p,t]*x[p,t] + s[p,t]*y[p,t] + h[p,t]*I[p,t+1]
                  for p in range(P) for t in range(T))
m.setObjective(obj, GRB.MINIMIZE)

# Constraints

# Initial inventory zero
for p in range(P):
    m.addConstr(I[p,0] == 0, name=f""init_inv_{p}"")

# Inventory balance for each period
for p in range(P):
    for t in range(T):
        m.addConstr(I[p,t+1] == I[p,t] + x[p,t] - d[p,t],
                    name=f""inv_bal_{p}_{t}"")

# Final inventory zero
for p in range(P):
    m.addConstr(I[p,T] == 0, name=f""final_inv_{p}"")

# Production limit by setup
for p in range(P):
    for t in range(T):
        m.addConstr(x[p,t] <= M[p,t]*y[p,t], name=f""prod_limit_{p}_{t}"")

# Capacity constraint
for t in range(T):
    m.addConstr(gp.quicksum(r[p]*x[p,t] for p in range(P)) <= C[t],
                name=f""capacity_{t}"")

# Solve
m.optimize()
",67501,67501,1,,,,,,,,
"There are five clients, labeled Client 0 to Client 4, each requiring two operations to be performed in sequence. Each operation takes exactly 1 unit of time to complete. The operations for each client must follow a strict sequence: the second operation cannot start until the first operation is completed, with a minimum gap of 1 unit of time between them. Operations from different clients may need to be performed on the same machine, and no two operations can overlap on the same machine. To enforce this, binary decision variables determine the order of operations on shared machines. The goal is to minimize the total production time, known as the makespan, which is the time when the last operation across all clients is completed. The makespan must be at least as long as the completion time of every operation. Start times for all operations are continuous variables, and the binary variables ensure that operations on the same machine do not overlap. A large number (100,000) is used in the constraints to enforce the scheduling logic, ensuring that one operation finishes before another starts on the same machine. The problem involves determining the optimal start times for all operations and the sequence of operations on shared machines to minimize the total production time while satisfying all constraints.","\[
\begin{aligned}
\text{minimize } & C \\[4pt]
\text{subject to } & s_{i,2} \;\ge\; s_{i,1} + 2 && \forall\, i \in \{0,\dots,4\} \\[4pt]
& s_{i,p} + 1 \;\le\; s_{j,q} + 100000\,(1 - y_{i,p,j,q}) && \forall\, i,j \in \{0,\dots,4\},\; p,q \in \{1,2\},\; (i,p)\neq(j,q) \\[4pt]
& s_{j,q} + 1 \;\le\; s_{i,p} + 100000\,y_{i,p,j,q} && \forall\, i,j \in \{0,\dots,4\},\; p,q \in \{1,2\},\; (i,p)\neq(j,q) \\[4pt]
& C \;\ge\; s_{i,1} + 1 && \forall\, i \in \{0,\dots,4\} \\[4pt]
& C \;\ge\; s_{i,2} + 1 && \forall\, i \in \{0,\dots,4\} \\[4pt]
& s_{i,p} \;\ge\; 0 && \forall\, i \in \{0,\dots,4\},\; p=1,2
\end{aligned}
\]

\[
s_{i,p} \in \mathbb{R}_+ \quad (i=0,\dots,4,\; p=1,2), \qquad
C \in \mathbb{R}_+, \qquad
y_{i,p,j,q} \in \{0,1\} \quad ((i,p)\neq(j,q)).
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Scheduling_Problem"")

# Parameters
n = 5  # number of i indices (0..4)
p_vals = [1, 2]
M = 100000

# Decision variables
s = {}
for i in range(n):
    for p in p_vals:
        s[i, p] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=f""s_{i}_{p}"")

C = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""C"")

y = {}
for i in range(n):
    for p in p_vals:
        for j in range(n):
            for q in p_vals:
                if (i, p) != (j, q):
                    y[i, p, j, q] = m.addVar(vtype=GRB.BINARY, name=f""y_{i}_{p}_{j}_{q}"")

# Objective: minimize C
m.setObjective(C, GRB.MINIMIZE)

# Constraints
# s_{i,2} >= s_{i,1} + 2
for i in range(n):
    m.addConstr(s[i, 2] >= s[i, 1] + 2, name=f""duration_{i}"")

# Ordering constraints with binary variables
for i in range(n):
    for p in p_vals:
        for j in range(n):
            for q in p_vals:
                if (i, p) != (j, q):
                    # s_{i,p} + 1 <= s_{j,q} + M*(1 - y_{i,p,j,q})
                    m.addConstr(s[i, p] + 1 <= s[j, q] + M * (1 - y[i, p, j, q]),
                                name=f""order1_{i}_{p}_{j}_{q}"")
                    # s_{j,q} + 1 <= s_{i,p} + M*y_{i,p,j,q}
                    m.addConstr(s[j, q] + 1 <= s[i, p] + M * y[i, p, j, q],
                                name=f""order2_{i}_{p}_{j}_{q}"")

# C bounds
for i in range(n):
    m.addConstr(C >= s[i, 1] + 1, name=f""C_ge_s1_{i}"")
    m.addConstr(C >= s[i, 2] + 1, name=f""C_ge_s2_{i}"")

# Optimize
m.optimize()",9.999989501925823,4,0,,,,,,,,
"You are responsible for managing the distribution of resources across a network of eight cities. Each city has a specific supply of resources and a demand that must be met. The goal is to minimize the total transportation cost while ensuring that all cities receive the resources they need, without exceeding the capacity of the transportation links or the storage capacity of the cities.

City 0 has a net demand of 2 units, City 1 has a balanced supply and demand, City 2 has a net supply of 1 unit, City 3 has a net demand of 2 units, City 4 has a net supply of 2 units, City 5 has a balanced supply and demand, City 6 has a net demand of 1 unit, and City 7 has a net supply of 2 units.

The cost of transporting resources from City 0 to City 1 is 1 unit, to City 2 is 1 unit, to City 3 is 1 unit, to City 4 is 1 unit, to City 5 is 3 units, to City 6 is 3 units, and to City 7 is 3 units. From City 1 to City 0 is 1 unit, to City 2 is 2 units, to City 3 is 2 units, to City 4 is 2 units, to City 5 is 3 units, to City 6 is 2 units, and to City 7 is 1 unit. From City 2 to City 0 is 2 units, to City 1 is 3 units, to City 3 is 3 units, to City 4 is 2 units, to City 5 is 2 units, to City 6 is 3 units, and to City 7 is 3 units. From City 3 to City 0 is 2 units, to City 1 is 3 units, to City 2 is 1 unit, to City 4 is 3 units, to City 5 is 1 unit, to City 6 is 3 units, and to City 7 is 3 units. From City 4 to City 0 is 3 units, to City 1 is 1 unit, to City 2 is 3 units, to City 3 is 1 unit, to City 5 is 1 unit, to City 6 is 2 units, and to City 7 is 1 unit. From City 5 to City 0 is 1 unit, to City 1 is 1 unit, to City 2 is 3 units, to City 3 is 2 units, to City 4 is 1 unit, to City 6 is 3 units, and to City 7 is 3 units. From City 6 to City 0 is 2 units, to City 1 is 3 units, to City 2 is 3 units, to City 3 is 2 units, to City 4 is 3 units, to City 5 is 1 unit, and to City 7 is 1 unit. From City 7 to City 0 is 2 units, to City 1 is 1 unit, to City 2 is 2 units, to City 3 is 2 units, to City 4 is 1 unit, to City 5 is 1 unit, and to City 6 is 1 unit.

The maximum capacity for transporting resources from City 0 to City 1 is 7 units, to City 2 is 9 units, to City 3 is 7 units, to City 4 is 8 units, to City 5 is 9 units, to City 6 is 7 units, and to City 7 is 7 units. From City 1 to City 0 is 8 units, to City 2 is 8 units, to City 3 is 8 units, to City 4 is 7 units, to City 5 is 9 units, to City 6 is 8 units, and to City 7 is 9 units. From City 2 to City 0 is 7 units, to City 1 is 9 units, to City 3 is 9 units, to City 4 is 7 units, to City 5 is 9 units, to City 6 is 8 units, and to City 7 is 9 units. From City 3 to City 0 is 8 units, to City 1 is 8 units, to City 2 is 9 units, to City 4 is 7 units, to City 5 is 9 units, to City 6 is 7 units, and to City 7 is 8 units. From City 4 to City 0 is 7 units, to City 1 is 7 units, to City 2 is 7 units, to City 3 is 9 units, to City 5 is 8 units, to City 6 is 7 units, and to City 7 is 7 units. From City 5 to City 0 is 9 units, to City 1 is 9 units, to City 2 is 9 units, to City 3 is 9 units, to City 4 is 7 units, to City 6 is 7 units, and to City 7 is 7 units. From City 6 to City 0 is 8 units, to City 1 is 9 units, to City 2 is 7 units, to City 3 is 9 units, to City 4 is 9 units, to City 5 is 7 units, and to City 7 is 9 units. From City 7 to City 0 is 9 units, to City 1 is 7 units, to City 2 is 8 units, to City 3 is 8 units, to City 4 is 8 units, to City 5 is 9 units, and to City 6 is 8 units.

The maximum storage capacity for City 0 is 16 units, City 1 is 16 units, City 2 is 18 units, City 3 is 12 units, City 4 is 14 units, City 5 is 16 units, City 6 is 12 units, and City 7 is 14 units.

Your task is to determine the optimal amount of resources to transport between cities to minimize the total transportation cost while ensuring that each city's net demand or supply is satisfied, the transportation links are not overloaded, and the storage capacities of the cities are not exceeded.","\[
\begin{aligned}
\min \quad & \sum_{i=0}^{7}\sum_{\substack{j=0\\ j\neq i}}^{7} c_{ij}\,x_{ij} \\[4pt]
\text{s.t.} \quad & \sum_{\substack{j=0\\ j\neq i}}^{7} x_{ji}\;-\;\sum_{\substack{j=0\\ j\neq i}}^{7} x_{ij}\;=\;s_i 
\quad \forall\, i=0,\dots,7 \\[4pt]
& x_{ij}\;\le\;u_{ij}\quad \forall\, i=0,\dots,7,\; j=0,\dots,7,\; j\neq i \\[4pt]
& \sum_{\substack{j=0\\ j\neq i}}^{7} x_{ji}\;-\;\sum_{\substack{j=0\\ j\neq i}}^{7} x_{ij}\;\le\;S_i 
\quad \forall\, i=0,\dots,7 \\[4pt]
& x_{ij}\in\mathbb{R}_+ \quad \forall\, i=0,\dots,7,\; j=0,\dots,7,\; j\neq i
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB
import numpy as np

# Example data (replace with actual values)
c = np.random.rand(8, 8)
u = np.full((8, 8), 10.0)
s = np.zeros(8)
S = np.full(8, 5.0)

# Create model
m = gp.Model(""Flow_Optimization"")

# Decision variables
x = m.addVars(8, 8, vtype=GRB.CONTINUOUS, lb=0, name=""x"")

# Objective function
m.setObjective(gp.quicksum(c[i, j] * x[i, j] for i in range(8) for j in range(8) if i != j), GRB.MINIMIZE)

# Flow balance constraints
for i in range(8):
    inflow = gp.quicksum(x[j, i] for j in range(8) if j != i)
    outflow = gp.quicksum(x[i, j] for j in range(8) if j != i)
    m.addConstr(inflow - outflow == s[i], name=f""balance_{i}"")

# Capacity constraints
for i in range(8):
    for j in range(8):
        if i != j:
            m.addConstr(x[i, j] <= u[i, j], name=f""capacity_{i}_{j}"")

# Upper bound on net flow
for i in range(8):
    inflow = gp.quicksum(x[j, i] for j in range(8) if j != i)
    outflow = gp.quicksum(x[i, j] for j in range(8) if j != i)
    m.addConstr(inflow - outflow <= S[i], name=f""upper_{i}"")

# Optimize
m.optimize()",0,7,0,,,,,,,,
"Minimize the total penalty costs for landing five aircraft, where penalties are incurred for landing earlier or later than the target times. The target landing times are 89, 63, 64, 97, and 85 for aircraft 0, 1, 2, 3, and 4, respectively. Each aircraft must land within its specified time window: aircraft 0 between 60 and 100, aircraft 1 between 60 and 93, aircraft 2 between 60 and 94, aircraft 3 between 67 and 100, and aircraft 4 between 60 and 100. The penalty costs per unit time for landing early are 19, 10, 14, 12, and 19 for aircraft 0, 1, 2, 3, and 4, respectively. The penalty costs per unit time for landing late are 14, 13, 15, 15, and 14 for aircraft 0, 1, 2, 3, and 4, respectively. 

To ensure safety, a minimum separation time must be maintained between consecutive landings. The required separation times between aircraft pairs are as follows: between aircraft 0 and 1, 7 units if aircraft 0 lands first or 8 units if aircraft 1 lands first; between aircraft 0 and 2, 6 units if aircraft 0 lands first or 7 units if aircraft 2 lands first; between aircraft 0 and 3, 5 units if aircraft 0 lands first or 8 units if aircraft 3 lands first; between aircraft 0 and 4, 5 units if aircraft 0 lands first or 7 units if aircraft 4 lands first; between aircraft 1 and 2, 5 units if aircraft 1 lands first or 6 units if aircraft 2 lands first; between aircraft 1 and 3, 5 units if aircraft 1 lands first or 7 units if aircraft 3 lands first; between aircraft 1 and 4, 6 units if aircraft 1 lands first or 5 units if aircraft 4 lands first; between aircraft 2 and 3, 5 units if aircraft 2 lands first or 6 units if aircraft 3 lands first; between aircraft 2 and 4, 5 units if aircraft 2 lands first or 7 units if aircraft 4 lands first; between aircraft 3 and 4, 6 units if aircraft 3 lands first or 6 units if aircraft 4 lands first.

The order in which aircraft land must be determined, and for each pair of aircraft, one must land before the other. The separation time must be enforced based on the landing order. The actual landing times for each aircraft must be determined, and the penalties for landing early or late must be calculated based on the deviations from the target landing times. The objective is to minimize the total penalty costs while ensuring that all constraints are satisfied.","\[
\begin{aligned}
\min \quad & 19\,e_0 + 10\,e_1 + 14\,e_2 + 12\,e_3 + 19\,e_4 \;+\; 14\,l_0 + 13\,l_1 + 15\,l_2 + 15\,l_3 + 14\,l_4 \\
\text{s.t.}\quad
& t_0 = 89 - e_0 + l_0 \\
& t_1 = 63 - e_1 + l_1 \\
& t_2 = 64 - e_2 + l_2 \\
& t_3 = 97 - e_3 + l_3 \\
& t_4 = 85 - e_4 + l_4 \\
& 60 \le t_0 \le 100 \\
& 60 \le t_1 \le 93 \\
& 60 \le t_2 \le 94 \\
& 67 \le t_3 \le 100 \\
& 60 \le t_4 \le 100 \\
& e_i,\;l_i \ge 0 \quad (i=0,\dots,4) \\
& t_j \;\ge\; t_i + s_{ij}^{\text{if }i\text{ before }j} \;-\; M\,(1-y_{ij}) \quad (i<j) \\
& t_i \;\ge\; t_j + s_{ij}^{\text{if }j\text{ before }i} \;-\; M\,y_{ij} \quad (i<j) \\
& y_{ij}\in\{0,1\}\quad (i<j) \\
& t_i,\;e_i,\;l_i\in\mathbb{R}\quad (i=0,\dots,4)
\end{aligned}
\] where the separation times \(s_{ij}^{\text{if }i\text{ before }j}\) and \(s_{ij}^{\text{if }j\text{ before }i}\) are:  

\[
\begin{array}{c|c|c}
(i,j) & s_{ij}^{i\text{ before }j} & s_{ij}^{j\text{ before }i}\\ \hline
(0,1) & 7 & 8\\
(0,2) & 6 & 7\\
(0,3) & 5 & 8\\
(0,4) & 5 & 7\\
(1,2) & 5 & 6\\
(1,3) & 5 & 7\\
(1,4) & 6 & 5\\
(2,3) & 5 & 6\\
(2,4) & 5 & 7\\
(3,4) & 6 & 6
\end{array}
\] and \(M=200\).","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Scheduling_Optimization"")

# Parameters
bases = [89, 63, 64, 97, 85]
e_costs = [19, 10, 14, 12, 19]
l_costs = [14, 13, 15, 15, 14]
t_bounds = [(60, 100), (60, 93), (60, 94), (67, 100), (60, 100)]
M = 200

# Separation times
s_before = {(0,1):7,(0,2):6,(0,3):5,(0,4):5,
            (1,2):5,(1,3):5,(1,4):6,
            (2,3):5,(2,4):5,
            (3,4):6}
s_after  = {(0,1):8,(0,2):7,(0,3):8,(0,4):7,
            (1,2):6,(1,3):7,(1,4):5,
            (2,3):6,(2,4):7,
            (3,4):6}

# Decision variables
e = m.addVars(5, vtype=GRB.CONTINUOUS, lb=0, name=""e"")
l = m.addVars(5, vtype=GRB.CONTINUOUS, lb=0, name=""l"")
t = m.addVars(5, vtype=GRB.CONTINUOUS, name=""t"")
y = m.addVars([(i,j) for i in range(5) for j in range(i+1,5)], vtype=GRB.BINARY, name=""y"")

# Objective
obj = gp.quicksum(e_costs[i]*e[i] + l_costs[i]*l[i] for i in range(5))
m.setObjective(obj, GRB.MINIMIZE)

# t_i = base - e_i + l_i
for i in range(5):
    m.addConstr(t[i] == bases[i] - e[i] + l[i], name=f""t_def_{i}"")

# Bounds on t_i
for i in range(5):
    lb, ub = t_bounds[i]
    m.addConstr(t[i] >= lb, name=f""t_lb_{i}"")
    m.addConstr(t[i] <= ub, name=f""t_ub_{i}"")

# Sequencing constraints
for i in range(5):
    for j in range(i+1,5):
        m.addConstr(t[j] >= t[i] + s_before[(i,j)] - M*(1-y[i,j]), name=f""seq1_{i}_{j}"")
        m.addConstr(t[i] >= t[j] + s_after[(i,j)] - M*y[i,j], name=f""seq2_{i}_{j}"")

# Optimize
m.optimize()
",87,87,1,,,,,,,,
" Facility Location for Maximum Dispersion

You are tasked with selecting a set of facilities from a network of five potential locations (Node 0, Node 1, Node 2, Node 3, and Node 4) to maximize the overall dispersion between the selected facilities. Dispersion is measured by the weighted distances between pairs of facilities, where higher weights indicate greater desirability for separation. The goal is to ensure that the selected facilities are as spread out as possible, given the constraints.

#### Key Decisions:
1. **Facility Selection**: Decide which facilities to open. Each facility can either be selected (1) or not selected (0). Specifically, you must select exactly 2 facilities out of the 5 available.
2. **Pairwise Dispersion**: Determine whether a pair of facilities contributes to the dispersion score. A pair contributes only if both facilities in the pair are selected.

#### Objective:
Maximize the total dispersion score, which is the sum of the weighted distances between all pairs of selected facilities. The weights for each pair are as follows:
- Node 0 and Node 1: 22  
- Node 0 and Node 2: 19  
- Node 0 and Node 3: 24  
- Node 0 and Node 4: 22  
- Node 1 and Node 0: 19  
- Node 1 and Node 2: 23  
- Node 1 and Node 3: 16  
- Node 1 and Node 4: 25  
- Node 2 and Node 0: 19  
- Node 2 and Node 1: 16  
- Node 2 and Node 3: 19  
- Node 2 and Node 4: 21  
- Node 3 and Node 0: 25  
- Node 3 and Node 1: 19  
- Node 3 and Node 2: 21  
- Node 3 and Node 4: 17  
- Node 4 and Node 0: 19  
- Node 4 and Node 1: 22  
- Node 4 and Node 2: 19  
- Node 4 and Node 3: 21  

#### Constraints:
1. **Facility Selection Limit**: Exactly 2 facilities must be selected from the 5 available. This means the sum of the selection decisions for all facilities must equal 2.
2. **Pairwise Contribution Rules**:
   - A pair of facilities can only contribute to the dispersion score if both facilities in the pair are selected.
   - If either facility in a pair is not selected, the pair cannot contribute to the dispersion score.
   - If both facilities in a pair are selected, the pair must contribute to the dispersion score.

#### Numerical Parameters:
- The weights for each pair of facilities are explicitly provided in the objective section above.
- The total number of facilities to select is fixed at 2.

#### Summary:
Your task is to select 2 facilities out of 5 such that the total dispersion score, calculated as the sum of the weighted distances between all selected pairs, is maximized. The selection must adhere to the constraints that ensure only valid pairs contribute to the dispersion score and that exactly 2 facilities are chosen.","\[
\begin{aligned}
\max \quad & 22\,z_{01}+19\,z_{02}+24\,z_{03}+22\,z_{04}+23\,z_{12}+16\,z_{13}+25\,z_{14}+19\,z_{23}+21\,z_{24}+17\,z_{34} \\
\text{s.t.}\quad & y_0+y_1+y_2+y_3+y_4 = 2 \\
& z_{ij}\le y_i \quad \forall\, i<j \\
& z_{ij}\le y_j \quad \forall\, i<j \\
& z_{ij}\ge y_i+y_j-1 \quad \forall\, i<j \\
& y_i\in\{0,1\}\quad i=0,\dots,4 \\
& z_{ij}\in\{0,1\}\quad i<j
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

m = gp.Model(""PairSelection"")

# Decision variables
y = m.addVars(5, vtype=GRB.BINARY, name=""y"")
z = m.addVars([(i, j) for i in range(5) for j in range(i + 1, 5)], vtype=GRB.BINARY, name=""z"")

# Coefficients for the objective
coeff = {
    (0, 1): 22, (0, 2): 19, (0, 3): 24, (0, 4): 22,
    (1, 2): 23, (1, 3): 16, (1, 4): 25,
    (2, 3): 19, (2, 4): 21,
    (3, 4): 17
}

# Objective function
m.setObjective(gp.quicksum(coeff[i, j] * z[i, j] for i, j in z.keys()), GRB.MAXIMIZE)

# Constraint: exactly two y's are selected
m.addConstr(gp.quicksum(y[i] for i in range(5)) == 2, name=""y_sum"")

# Constraints linking z and y
for i, j in z.keys():
    m.addConstr(z[i, j] <= y[i], name=f""z_le_y{i}"")
    m.addConstr(z[i, j] <= y[j], name=f""z_le_y{j}"")
    m.addConstr(z[i, j] >= y[i] + y[j] - 1, name=f""z_ge_y{i}{j}"")

# Solve the model
m.optimize()",25,49,0,,,,,,,,
"The problem involves scheduling production tasks for five jobs (Job 0 through Job 4) in a manufacturing facility. Each job consists of a sequence of operations that must be performed in a specific order, with each operation taking exactly 1 unit of time to complete. The facility has a limited number of machines, and certain operations from different jobs may require the same machine. The goal is to minimize the total production time, known as the makespan, while ensuring that all operational constraints are satisfied.

Each operation within a job must start only after the previous operation in the same job is completed. For example, Operation 1 of Job 0 cannot start until Operation 0 of Job 0 is finished. Operations that require the same machine cannot overlap in time. To enforce this, binary decision variables are used to determine the order of operations on each machine. For instance, if Operation 0 of Job 0 is scheduled before Operation 0 of Job 1 on Machine 1, the binary variable \( X_{(0,0),(1,0)} \) is set to 1; otherwise, it is set to 0. A large constant (100000) is used in the constraints to ensure that the sequencing is properly enforced.

The makespan must be at least as long as the completion time of the last operation across all jobs. For example, if Operation 1 of Job 4 finishes at time 10, the makespan must be at least 10. All operation start times must be non-negative, and the binary decision variables can only take values of 0 or 1.

The objective is to determine the start times for all operations and the sequence of operations on shared machines such that the total production time is minimized. This must be done while ensuring that all precedence constraints, machine capacity constraints, and non-negativity constraints are satisfied. The processing time for each operation is fixed at 1 unit of time, and the binary decision variables are used to enforce the order of operations on shared machines.","\[
\begin{aligned}
\min\quad & C \\[4pt]
\text{s.t.}\quad 
& s_{j,o} \;\ge\; s_{j,o-1} + 1 
&& \forall j\in J,\; o=1,\dots,|O_j|-1 \\[4pt]
& s_{j,o} + 1 \;\le\; s_{k,p} + M\bigl(1 - X_{(j,o),(k,p)}\bigr) 
&& \forall j,k\in J,\; o\in O_j,\; p\in O_k,\; m_{j,o}=m_{k,p},\;(j,o)\neq(k,p) \\[4pt]
& s_{k,p} + 1 \;\le\; s_{j,o} + M\,X_{(j,o),(k,p)} 
&& \text{same indices as above} \\[4pt]
& C \;\ge\; s_{j,o} + 1 
&& \forall j\in J,\; o\in O_j \\[4pt]
& s_{j,o} \;\ge\; 0 
&& \forall j,o \\[4pt]
& X_{(j,o),(k,p)} \;\in\; \{0,1\} 
&& \forall j,k,o,p \text{ with } m_{j,o}=m_{k,p} \\[4pt]
& s_{j,o} \;\in\; \mathbb{R}_+ 
&& \forall j,o \\[4pt]
& C \;\in\; \mathbb{R}_+ 
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Example data
J = [1, 2]  # jobs
O = {1: [1, 2], 2: [1]}  # operations per job
m = {(1, 1): 1, (1, 2): 2, (2, 1): 1}  # machine assignment for each operation
M = 1000  # big-M constant

# Create model
m_model = gp.Model(""Scheduling_Problem"")

# Decision variables
s = m_model.addVars(J, [o for ops in O.values() for o in ops], vtype=GRB.CONTINUOUS, lb=0, name=""s"")
X = m_model.addVars(
    [(j, o), (k, p)]
    for j in J
    for o in O[j]
    for k in J
    for p in O[k]
    if m[(j, o)] == m[(k, p)] and (j, o) != (k, p),
    vtype=GRB.BINARY,
    name=""X""
)
C = m_model.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""C"")

# Objective: minimize C
m_model.setObjective(C, GRB.MINIMIZE)

# Constraints
# 1. Operation sequencing within each job
for j in J:
    ops = O[j]
    for idx in range(1, len(ops)):
        o_prev = ops[idx - 1]
        o_curr = ops[idx]
        m_model.addConstr(s[j, o_curr] >= s[j, o_prev] + 1, name=f""seq_{j}_{o_prev}_{o_curr}"")

# 2. Precedence constraints for operations on the same machine
for (j, o), (k, p) in X.keys():
    m_model.addConstr(
        s[j, o] + 1 <= s[k, p] + M * (1 - X[(j, o), (k, p)]),
        name=f""pre1_{j}_{o}_{k}_{p}""
    )
    m_model.addConstr(
        s[k, p] + 1 <= s[j, o] + M * X[(j, o), (k, p)],
        name=f""pre2_{j}_{o}_{k}_{p}""
    )

# 3. Makespan constraints
for j in J:
    for o in O[j]:
        m_model.addConstr(C >= s[j, o] + 1, name=f""makespan_{j}_{o}"")

# Optimize
m_model.optimize()

# Print results
if m_model.status == GRB.OPTIMAL:
    print(f""Optimal makespan C: {C.X}"")
    for j in J:
        for o in O[j]:
            print(f""s[{j},{o}] = {s[j, o].X}"")
    for (j, o), (k, p) in X.keys():
        if X[(j, o), (k, p)].X > 0.5:
            print(f""X[{j},{o}][{k},{p}] = 1"")
else:
    print(""No optimal solution found."")",,5,0,,,,,,,,
" Managing Resource Distribution Across Cities

Imagine you are responsible for managing the distribution of a critical resource (e.g., medical supplies, food, or energy) across seven interconnected cities. Each city has a specific supply of the resource, a demand that must be met, and limited capacity to store or process incoming resources. Your goal is to minimize the total cost of transporting the resource between cities while ensuring that all demands are satisfied and no capacity limits are exceeded.

#### City Details:
- **City 0** has a net demand of 2 units (it requires 2 more units than it currently has).
- **City 1** has a net demand of 2 units.
- **City 2** has a net supply of 1 unit (it has 1 more unit than it needs).
- **City 3** has a net supply of 2 units.
- **City 4** is balanced, with no net demand or supply.
- **City 5** has a net supply of 1 unit.
- **City 6** is balanced, with no net demand or supply.

#### Transportation Costs:
The cost of transporting resources between cities varies depending on the route. Below are the costs per unit transported:
- From **City 0**:  
  - To City 1: 1 unit cost  
  - To City 2: 2 units cost  
  - To City 3: 3 units cost  
  - To City 4: 2 units cost  
  - To City 5: 3 units cost  
  - To City 6: 3 units cost  
- From **City 1**:  
  - To City 0: 2 units cost  
  - To City 2: 3 units cost  
  - To City 3: 2 units cost  
  - To City 4: 2 units cost  
  - To City 5: 3 units cost  
  - To City 6: 3 units cost  
- From **City 2**:  
  - To City 0: 2 units cost  
  - To City 1: 1 unit cost  
  - To City 3: 3 units cost  
  - To City 4: 2 units cost  
  - To City 5: 3 units cost  
  - To City 6: 2 units cost  
- From **City 3**:  
  - To City 0: 2 units cost  
  - To City 1: 2 units cost  
  - To City 2: 2 units cost  
  - To City 4: 3 units cost  
  - To City 5: 1 unit cost  
  - To City 6: 1 unit cost  
- From **City 4**:  
  - To City 0: 1 unit cost  
  - To City 1: 1 unit cost  
  - To City 2: 1 unit cost  
  - To City 3: 1 unit cost  
  - To City 5: 1 unit cost  
  - To City 6: 1 unit cost  
- From **City 5**:  
  - To City 0: 3 units cost  
  - To City 1: 2 units cost  
  - To City 2: 3 units cost  
  - To City 3: 2 units cost  
  - To City 4: 3 units cost  
  - To City 6: 3 units cost  
- From **City 6**:  
  - To City 0: 3 units cost  
  - To City 1: 3 units cost  
  - To City 2: 2 units cost  
  - To City 3: 3 units cost  
  - To City 4: 3 units cost  
  - To City 5: 3 units cost  

#### Transportation Constraints:
Each route between cities has a maximum capacity for resource transportation:
- **City 0**:  
  - To City 1: Maximum 8 units  
  - To City 2: Maximum 7 units  
  - To City 3: Maximum 7 units  
  - To City 4: Maximum 8 units  
  - To City 5: Maximum 7 units  
  - To City 6: Maximum 8 units  
- **City 1**:  
  - To City 0: Maximum 8 units  
  - To City 2: Maximum 9 units  
  - To City 3: Maximum 8 units  
  - To City 4: Maximum 7 units  
  - To City 5: Maximum 7 units  
  - To City 6: Maximum 8 units  
- **City 2**:  
  - To City 0: Maximum 9 units  
  - To City 1: Maximum 9 units  
  - To City 3: Maximum 7 units  
  - To City 4: Maximum 9 units  
  - To City 5: Maximum 9 units  
  - To City 6: Maximum 9 units  
- **City 3**:  
  - To City 0: Maximum 9 units  
  - To City 1: Maximum 7 units  
  - To City 2: Maximum 7 units  
  - To City 4: Maximum 9 units  
  - To City 5: Maximum 8 units  
  - To City 6: Maximum 9 units  
- **City 4**:  
  - To City 0: Maximum 8 units  
  - To City 1: Maximum 9 units  
  - To City 2: Maximum 9 units  
  - To City 3: Maximum 9 units  
  - To City 5: Maximum 8 units  
  - To City 6: Maximum 8 units  
- **City 5**:  
  - To City 0: Maximum 8 units  
  - To City 1: Maximum 7 units  
  - To City 2: Maximum 9 units  
  - To City 3: Maximum 8 units  
  - To City 4: Maximum 8 units  
  - To City 6: Maximum 8 units  
- **City 6**:  
  - To City 0: Maximum 9 units  
  - To City 1: Maximum 8 units  
  - To City 2: Maximum 8 units  
  - To City 3: Maximum 7 units  
  - To City 4: Maximum 9 units  
  - To City 5: Maximum 8 units  

#### City Capacity Constraints:
Each city has a maximum capacity for incoming resources:
- **City 0**: Maximum 18 units  
- **City 1**: Maximum 13 units  
- **City 2**: Maximum 14 units  
- **City 3**: Maximum 16 units  
- **City 4**: Maximum 15 units  
- **City 5**: Maximum 18 units  
- **City 6**: Maximum 14 units  

#### Objective:
Your task is to determine the optimal amount of resources to transport between cities to meet all demands while minimizing the total transportation cost. Ensure that:
1. All net demands and supplies are balanced.
2. No transportation route exceeds its capacity.
3. No city exceeds its capacity for incoming resources.
4. All transportation amounts are non-negative.

By solving this problem, you will ensure efficient resource distribution across the cities at the lowest possible cost.","\[
\begin{aligned}
\min \quad & \sum_{i=0}^{6}\sum_{\substack{j=0\\ j\neq i}}^{6} c_{ij}\,f_{ij} \\[4pt]
\text{s.t.}\quad 
& \sum_{j\neq i} f_{ji}-\sum_{j\neq i} f_{ij}=d_i \qquad \forall\,i=0,\dots,6 \\[4pt]
& f_{ij}\le u_{ij}\qquad \forall\,i\neq j \\[4pt]
& \sum_{i\neq j} f_{ij}\le U_j \qquad \forall\,j=0,\dots,6 \\[4pt]
& f_{ij}\ge 0 \qquad \forall\,i\neq j
\end{aligned}
\]

where  

\[
\begin{array}{c|c}
i & d_i \\ \hline
0 & 2 \\
1 & 2 \\
2 & -1 \\
3 & -2 \\
4 & 0 \\
5 & -1 \\
6 & 0
\end{array}
\]

\[
c_{ij}=\begin{cases}
1 & (0,1)\\
2 & (0,2)\\
3 & (0,3)\\
2 & (0,4)\\
3 & (0,5)\\
3 & (0,6)\\[2pt]
2 & (1,0)\\
3 & (1,2)\\
2 & (1,3)\\
2 & (1,4)\\
3 & (1,5)\\
3 & (1,6)\\[2pt]
2 & (2,0)\\
1 & (2,1)\\
3 & (2,3)\\
2 & (2,4)\\
3 & (2,5)\\
2 & (2,6)\\[2pt]
2 & (3,0)\\
2 & (3,1)\\
2 & (3,2)\\
3 & (3,4)\\
1 & (3,5)\\
1 & (3,6)\\[2pt]
1 & (4,0)\\
1 & (4,1)\\
1 & (4,2)\\
1 & (4,3)\\
1 & (4,5)\\
1 & (4,6)\\[2pt]
3 & (5,0)\\
2 & (5,1)\\
3 & (5,2)\\
2 & (5,3)\\
3 & (5,4)\\
3 & (5,6)\\[2pt]
3 & (6,0)\\
3 & (6,1)\\
2 & (6,2)\\
3 & (6,3)\\
3 & (6,4)\\
3 & (6,5)
\end{array}
\]

\[
u_{ij}=\begin{cases}
8 & (0,1),(1,0),(0,5),(1,5),(0,6),(1,6)\\
7 & (0,2),(0,3),(0,4),(0,5),(1,2),(1,3),(1,4),(1,5),(2,0),(2,1),(2,3),(2,4),(2,5),(2,6)\\
9 & (2,0),(2,1),(2,3),(2,4),(2,5),(2,6),(3,0),(3,4),(3,6),(4,0),(4,1),(4,2),(4,3),(4,5),(4,6),(5,0),(5,2),(5,3),(5,4),(5,6),(6,0),(6,1),(6,2),(6,3),(6,4),(6,5)\\
8 & (0,5),(1,5),(3,5),(5,0),(5,3),(5,4),(5,6),(6,0),(6,1),(6,2),(6,3),(6,5)\\
7 & (1,2),(1,5),(2,3),(3,1),(3,2),(4,5),(5,1),(6,1)
\end{cases}
\]

\[
U_0=18,\; U_1=13,\; U_2=14,\; U_3=16,\; U_4=15,\; U_5=18,\; U_6=14
\]

\[
f_{ij}\in\mathbb{R}_+ \quad \forall\,i\neq j
\]","import gurobipy as gp
from gurobipy import GRB

# Data
d = [2, 2, -1, -2, 0, -1, 0]

c = [
    [0, 1, 2, 3, 2, 3, 3],
    [2, 0, 3, 2, 2, 3, 3],
    [2, 1, 0, 3, 2, 3, 2],
    [2, 2, 2, 0, 3, 1, 1],
    [1, 1, 1, 1, 0, 1, 1],
    [3, 2, 3, 2, 3, 0, 3],
    [3, 3, 2, 3, 3, 3, 0]
]

u = [
    [0, 8, 7, 7, 7, 8, 8],
    [8, 0, 7, 7, 7, 8, 8],
    [7, 7, 0, 7, 7, 7, 7],
    [7, 7, 7, 0, 9, 7, 9],
    [9, 9, 9, 9, 0, 9, 9],
    [9, 7, 9, 9, 9, 0, 9],
    [9, 9, 9, 9, 9, 9, 0]
]

U = [18, 13, 14, 16, 15, 18, 14]

# Create model
m = gp.Model(""Network_Flow"")

# Decision variables f[i,j] for i != j
f = m.addVars(7, 7, lb=0, vtype=GRB.CONTINUOUS, name=""f"")
# Remove diagonal variables
for i in range(7):
    f[i,i].LB = 0
    f[i,i].UB = 0

# Objective: minimize sum c_ij * f_ij
m.setObjective(gp.quicksum(c[i][j] * f[i,j] for i in range(7) for j in range(7) if i != j), GRB.MINIMIZE)

# Flow conservation constraints
for i in range(7):
    inflow = gp.quicksum(f[j,i] for j in range(7) if j != i)
    outflow = gp.quicksum(f[i,j] for j in range(7) if j != i)
    m.addConstr(inflow - outflow == d[i], name=f""flow_conservation_{i}"")

# Capacity constraints f_ij <= u_ij
for i in range(7):
    for j in range(7):
        if i != j:
            m.addConstr(f[i,j] <= u[i][j], name=f""capacity_{i}_{j}"")

# Outgoing capacity constraints sum_i f_ij <= U_j
for j in range(7):
    m.addConstr(gp.quicksum(f[i,j] for i in range(7) if i != j) <= U[j], name=f""outgoing_capacity_{j}"")

# Optimize
m.optimize()
",7,9,0,,,,,,,,
"You are responsible for assigning 8 employees to 7 projects to minimize the total cost while meeting all project requirements and respecting employee availability and capacity limits. Each employee has a fixed total number of hours they must contribute, and each project requires a specific number of hours to be completed. The decision variables are binary, indicating whether an employee is assigned to a project or not. 

Employee 0 must contribute exactly 1 hour in total, Employee 1 must contribute exactly 18 hours, Employee 2 must contribute exactly 15 hours, Employee 3 must contribute exactly 19 hours, Employee 4 must contribute exactly 18 hours, Employee 5 must contribute exactly 17 hours, Employee 6 must contribute exactly 15 hours, and Employee 7 must contribute exactly 19 hours. 

Project 0 requires exactly 15 hours, Project 1 requires exactly 19 hours, Project 2 requires exactly 16 hours, Project 3 requires exactly 20 hours, Project 4 requires exactly 17 hours, Project 5 requires exactly 16 hours, and Project 6 requires exactly 19 hours. 

Each employee has a maximum number of hours they can contribute to each project: Employee 0 can contribute up to 8 hours to Project 0, 9 hours to Project 1, 5 hours to Project 2, 10 hours to Project 3, 7 hours to Project 4, 10 hours to Project 5, and 10 hours to Project 6. Employee 1 can contribute up to 8 hours to Project 0, 10 hours to Project 1, 6 hours to Project 2, 6 hours to Project 3, 6 hours to Project 4, 8 hours to Project 5, and 5 hours to Project 6. Employee 2 can contribute up to 5 hours to Project 0, 7 hours to Project 1, 9 hours to Project 2, 7 hours to Project 3, 8 hours to Project 4, 9 hours to Project 5, and 7 hours to Project 6. Employee 3 can contribute up to 5 hours to Project 0, 6 hours to Project 1, 7 hours to Project 2, 7 hours to Project 3, 6 hours to Project 4, 8 hours to Project 5, and 9 hours to Project 6. Employee 4 can contribute up to 7 hours to Project 0, 10 hours to Project 1, 7 hours to Project 2, 6 hours to Project 3, 9 hours to Project 4, 5 hours to Project 5, and 8 hours to Project 6. Employee 5 can contribute up to 6 hours to Project 0, 10 hours to Project 1, 5 hours to Project 2, 9 hours to Project 3, 9 hours to Project 4, 6 hours to Project 5, and 10 hours to Project 6. Employee 6 can contribute up to 7 hours to Project 0, 8 hours to Project 1, 10 hours to Project 2, 5 hours to Project 3, 10 hours to Project 4, 10 hours to Project 5, and 6 hours to Project 6. Employee 7 can contribute up to 10 hours to Project 0, 7 hours to Project 1, 6 hours to Project 2, 9 hours to Project 3, 10 hours to Project 4, 5 hours to Project 5, and 7 hours to Project 6. 

The cost of assigning Employee 0 to Project 0 is 29, to Project 1 is 30, to Project 2 is 32, to Project 3 is 34, to Project 4 is 26, to Project 5 is 35, and to Project 6 is 27. The cost of assigning Employee 1 to Project 0 is 32, to Project 1 is 25, to Project 2 is 35, to Project 3 is 25, to Project 4 is 28, to Project 5 is 26, and to Project 6 is 33. The cost of assigning Employee 2 to Project 0 is 31, to Project 1 is 29, to Project 2 is 35, to Project 3 is 29, to Project 4 is 32, to Project 5 is 25, and to Project 6 is 27. The cost of assigning Employee 3 to Project 0 is 30, to Project 1 is 29, to Project 2 is 28, to Project 3 is 35, to Project 4 is 29, to Project 5 is 27, and to Project 6 is 28. The cost of assigning Employee 4 to Project 0 is 33, to Project 1 is 28, to Project 2 is 26, to Project 3 is 31, to Project 4 is 26, to Project 5 is 29, and to Project 6 is 32. The cost of assigning Employee 5 to Project 0 is 35, to Project 1 is 34, to Project 2 is 29, to Project 3 is 32, to Project 4 is 33, to Project 5 is 31, and to Project 6 is 28. The cost of assigning Employee 6 to Project 0 is 27, to Project 1 is 30, to Project 2 is 27, to Project 3 is 30, to Project 4 is 32, to Project 5 is 32, and to Project 6 is 26. The cost of assigning Employee 7 to Project 0 is 30, to Project 1 is 27, to Project 2 is 31, to Project 3 is 32, to Project 4 is 34, to Project 5 is 32, and to Project 6 is 26. 

The objective is to assign employees to projects such that all project requirements are met, no employee exceeds their total available hours, no employee exceeds their maximum contribution limit for any specific project, and the total cost of all assignments is minimized.","\[
\begin{aligned}
\text{minimize}\quad & \sum_{i=0}^{7}\sum_{j=0}^{6} C_{ij}\,y_{ij} \\[4pt]
\text{subject to}\quad 
& \sum_{j=0}^{6} h_{ij}=H_i \qquad &&\forall i=0,\dots,7 \\[4pt]
& \sum_{i=0}^{7} h_{ij}=R_j \qquad &&\forall j=0,\dots,6 \\[4pt]
& h_{ij}\;\le\;U_{ij}\,y_{ij} \qquad &&\forall i=0,\dots,7,\;\forall j=0,\dots,6 \\[4pt]
& h_{ij}\;\ge\;0 \qquad &&\forall i,j \\[4pt]
& y_{ij}\;\in\;\{0,1\} \qquad &&\forall i,j \\[4pt]
& h_{ij}\;\in\;\mathbb{R}_+ \qquad &&\forall i,j
\end{aligned}
\]

where  

\[
\begin{aligned}
&H_0=1,\;H_1=18,\;H_2=15,\;H_3=19,\;H_4=18,\;H_5=17,\;H_6=15,\;H_7=19,\\
&R_0=15,\;R_1=19,\;R_2=16,\;R_3=20,\;R_4=17,\;R_5=16,\;R_6=19,\\
&U_{ij}\text{ are the given maximum hours per employee__roject pair},\\
&C_{ij}\text{ are the given assignment costs per employee__roject pair}.
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB
import numpy as np

# Data
H = np.array([1, 18, 15, 19, 18, 17, 15, 19])          # length 8
R = np.array([15, 19, 16, 20, 17, 16, 19])             # length 7
U = np.array([  # shape (8,7) _ replace with actual values
    [10, 12, 8, 9, 11, 7, 10],
    [9, 11, 7, 8, 10, 6, 9],
    [8, 10, 6, 7, 9, 5, 8],
    [9, 11, 7, 8, 10, 6, 9],
    [10, 12, 8, 9, 11, 7, 10],
    [9, 11, 7, 8, 10, 6, 9],
    [8, 10, 6, 7, 9, 5, 8],
    [9, 11, 7, 8, 10, 6, 9]
])
C = np.array([  # shape (8,7) _ replace with actual costs
    [100, 120, 80, 90, 110, 70, 100],
    [90, 110, 70, 80, 100, 60, 90],
    [80, 100, 60, 70, 90, 50, 80],
    [90, 110, 70, 80, 100, 60, 90],
    [100, 120, 80, 90, 110, 70, 100],
    [90, 110, 70, 80, 100, 60, 90],
    [80, 100, 60, 70, 90, 50, 80],
    [90, 110, 70, 80, 100, 60, 90]
])

# Create model
m = gp.Model(""Employee_Project_Assignment"")

# Decision variables
h = m.addVars(8, 7, lb=0, vtype=GRB.CONTINUOUS, name=""h"")
y = m.addVars(8, 7, vtype=GRB.BINARY, name=""y"")

# Objective
m.setObjective(gp.quicksum(C[i, j] * y[i, j] for i in range(8) for j in range(7)), GRB.MINIMIZE)

# Constraints
for i in range(8):
    m.addConstr(gp.quicksum(h[i, j] for j in range(7)) == H[i], name=f""row_hours_{i}"")

for j in range(7):
    m.addConstr(gp.quicksum(h[i, j] for i in range(8)) == R[j], name=f""col_hours_{j}"")

for i in range(8):
    for j in range(7):
        m.addConstr(h[i, j] <= U[i, j] * y[i, j], name=f""capacity_{i}_{j}"")

# Solve
m.optimize()",1400,3320,0,,,,,,,,
"You are tasked with optimizing the placement of facilities across a network of five locations (Node 0, Node 1, Node 2, Node 3, and Node 4) to maximize the overall benefit derived from their interactions. Each location has the potential to host a facility, but due to budget constraints, you can only select **exactly 3 locations** to establish facilities. The goal is to maximize the total benefit generated by the interactions between the selected facilities.

#### Key Details:
1. **Facility Selection**: You must choose exactly 3 out of the 5 locations to establish facilities. Each location can either be selected (1) or not selected (0).
2. **Interaction Benefits**: The benefit of interaction between any two facilities depends on the specific pair of locations. For example:
   - If facilities are placed at Node 0 and Node 1, the interaction benefit is **16**.
   - If facilities are placed at Node 0 and Node 2, the interaction benefit is **20**.
   - Similarly, the interaction benefits for all other pairs are provided in the table below.

3. **Interaction Rules**:
   - An interaction benefit is only counted if **both facilities in the pair are selected**. For example, if Node 0 and Node 1 are both selected, the interaction benefit of 16 is added to the total.
   - If only one facility in a pair is selected, no interaction benefit is counted for that pair.

4. **Interaction Benefit Table**:
   | Pair of Nodes | Interaction Benefit |
   |---------------|---------------------|
   | Node 0 & Node 1 | 16                  |
   | Node 0 & Node 2 | 20                  |
   | Node 0 & Node 3 | 18                  |
   | Node 0 & Node 4 | 22                  |
   | Node 1 & Node 0 | 25                  |
   | Node 1 & Node 2 | 24                  |
   | Node 1 & Node 3 | 17                  |
   | Node 1 & Node 4 | 16                  |
   | Node 2 & Node 0 | 19                  |
   | Node 2 & Node 1 | 22                  |
   | Node 2 & Node 3 | 18                  |
   | Node 2 & Node 4 | 23                  |
   | Node 3 & Node 0 | 21                  |
   | Node 3 & Node 1 | 21                  |
   | Node 3 & Node 2 | 25                  |
   | Node 3 & Node 4 | 17                  |
   | Node 4 & Node 0 | 20                  |
   | Node 4 & Node 1 | 19                  |
   | Node 4 & Node 2 | 22                  |
   | Node 4 & Node 3 | 16                  |

5. **Constraints**:
   - **Facility Selection Constraint**: Exactly 3 facilities must be selected out of the 5 locations.
   - **Interaction Constraints**: For each pair of locations, the interaction benefit is only counted if both facilities in the pair are selected. This is enforced by ensuring that:
     - If either facility in a pair is not selected, the interaction benefit for that pair is not counted.
     - If both facilities in a pair are selected, the interaction benefit is fully counted.

6. **Objective**:
   - Maximize the total interaction benefit across all selected facility pairs.

#### Example:
Suppose you select facilities at Node 0, Node 1, and Node 2. The total interaction benefit would be calculated as follows:
- Node 0 & Node 1: 16
- Node 0 & Node 2: 20
- Node 1 & Node 2: 24  
Total Benefit = 16 + 20 + 24 = **60**

Your task is to determine the optimal selection of 3 facilities that maximizes the total interaction benefit, considering all the constraints and interaction rules provided.","\[
\begin{aligned}
\text{Maximize}\quad & 16\,z_{01}+20\,z_{02}+18\,z_{03}+22\,z_{04} \\
&\quad +24\,z_{12}+17\,z_{13}+16\,z_{14} \\
&\quad +18\,z_{23}+23\,z_{24}+17\,z_{34} \\[4pt]
\text{subject to}\quad & y_0+y_1+y_2+y_3+y_4 = 3 \\[4pt]
& z_{01}\le y_0,\; z_{01}\le y_1,\; z_{01}\ge y_0+y_1-1 \\[2pt]
& z_{02}\le y_0,\; z_{02}\le y_2,\; z_{02}\ge y_0+y_2-1 \\[2pt]
& z_{03}\le y_0,\; z_{03}\le y_3,\; z_{03}\ge y_0+y_3-1 \\[2pt]
& z_{04}\le y_0,\; z_{04}\le y_4,\; z_{04}\ge y_0+y_4-1 \\[2pt]
& z_{12}\le y_1,\; z_{12}\le y_2,\; z_{12}\ge y_1+y_2-1 \\[2pt]
& z_{13}\le y_1,\; z_{13}\le y_3,\; z_{13}\ge y_1+y_3-1 \\[2pt]
& z_{14}\le y_1,\; z_{14}\le y_4,\; z_{14}\ge y_1+y_4-1 \\[2pt]
& z_{23}\le y_2,\; z_{23}\le y_3,\; z_{23}\ge y_2+y_3-1 \\[2pt]
& z_{24}\le y_2,\; z_{24}\le y_4,\; z_{24}\ge y_2+y_4-1 \\[2pt]
& z_{34}\le y_3,\; z_{34}\le y_4,\; z_{34}\ge y_3+y_4-1 \\[4pt]
& y_i\in\{0,1\}\quad(i=0,\dots,4)\\
& z_{ij}\in\{0,1\}\quad(i<j)
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

m = gp.Model(""PairSelection"")

# Decision variables
y = m.addVars(5, vtype=GRB.BINARY, name=""y"")
z = {}
for i in range(5):
    for j in range(i+1, 5):
        z[(i, j)] = m.addVar(vtype=GRB.BINARY, name=f""z_{i}{j}"")

# Objective coefficients
coeff = {
    (0, 1): 16, (0, 2): 20, (0, 3): 18, (0, 4): 22,
    (1, 2): 24, (1, 3): 17, (1, 4): 16,
    (2, 3): 18, (2, 4): 23, (3, 4): 17
}
m.setObjective(gp.quicksum(coeff[(i, j)] * z[(i, j)] for (i, j) in z), GRB.MAXIMIZE)

# Sum of y variables
m.addConstr(gp.quicksum(y[i] for i in range(5)) == 3, name=""sum_y"")

# Pair constraints
for i in range(5):
    for j in range(i+1, 5):
        m.addConstr(z[(i, j)] <= y[i], name=f""z_le_y{i}"")
        m.addConstr(z[(i, j)] <= y[j], name=f""z_le_y{j}"")
        m.addConstr(z[(i, j)] >= y[i] + y[j] - 1, name=f""z_ge_y{i}y{j}"")

m.optimize()",65,127,0,,,,,,,,
"There are 5 jobs labeled Job 0 to Job 4, each requiring processing on 4 machines labeled Machine 0 to Machine 3. Each job has a specific processing time on each machine: Job 0 takes 5 hours on Machine 0, 9 hours on Machine 1, 7 hours on Machine 2, and 7 hours on Machine 3; Job 1 takes 10 hours on Machine 0, 8 hours on Machine 1, 8 hours on Machine 2, and 9 hours on Machine 3; Job 2 takes 6 hours on Machine 0, 8 hours on Machine 1, 9 hours on Machine 2, and 7 hours on Machine 3; Job 3 takes 7 hours on Machine 0, 7 hours on Machine 1, 8 hours on Machine 2, and 8 hours on Machine 3; Job 4 takes 9 hours on Machine 0, 5 hours on Machine 1, 5 hours on Machine 2, and 9 hours on Machine 3. Each job must be assigned to exactly one position in the schedule, and each position must be assigned exactly one job. A job cannot start on a machine until it has completed processing on the previous machine in the sequence. Additionally, a job in a later position in the schedule cannot start on a machine until the job in the previous position has completed processing on that machine. The objective is to minimize the total completion time, which includes the start time of the last job on the last machine (Machine 3) and the processing time of the last job on Machine 3. The start times for each job on each machine must be non-negative, and all constraints must be satisfied to avoid delays and resource conflicts.","\[
\begin{aligned}
\min\quad & C_{\max} \\[4pt]
\text{s.t.}\quad
& \sum_{p=1}^{5} x_{i,p}=1 &&\forall i\in\{0,\dots,4\} \\
& \sum_{i=0}^{4} x_{i,p}=1 &&\forall p\in\{1,\dots,5\} \\
& \operatorname{pos}_i=\sum_{p=1}^{5} p\,x_{i,p} &&\forall i\in\{0,\dots,4\} \\
& y_{i,j}+y_{j,i}=1 &&\forall\, i<j,\; i,j\in\{0,\dots,4\} \\
& \operatorname{pos}_i-\operatorname{pos}_j\le -1+M(1-y_{i,j}) &&\forall\, i\neq j \\
& S_{i,0}\ge 0 &&\forall i\in\{0,\dots,4\} \\
& S_{i,m}\ge S_{i,m-1}+t_{i,m-1} &&\forall i\in\{0,\dots,4\},\; m=1,2,3 \\
& S_{i,m}+t_{i,m}\le S_{j,m}+M(1-y_{i,j}) &&\forall\, i\neq j,\; m=0,1,2,3 \\
& C_{\max}\ge S_{i,3}+t_{i,3} &&\forall i\in\{0,\dots,4\} \\[4pt]
& x_{i,p}\in\{0,1\} &&\forall i,p \\
& y_{i,j}\in\{0,1\} &&\forall i\neq j \\
& \operatorname{pos}_i\in\mathbb{Z}_+ &&\forall i \\
& S_{i,m}\in\mathbb{R}_+ &&\forall i,m \\
& C_{\max}\in\mathbb{R}_+ 
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Problem data
n = 5  # number of jobs
p = 5  # number of positions
t = [
    [2, 3, 1, 4],
    [3, 2, 2, 1],
    [1, 4, 3, 2],
    [4, 1, 2, 3],
    [2, 2, 3, 1]
]
M = 100  # big-M constant

# Create model
model = gp.Model(""Scheduling_Problem"")

# Decision variables
x = model.addVars(n, p, vtype=GRB.BINARY, name=""x"")
pos = model.addVars(n, vtype=GRB.INTEGER, name=""pos"")
y = model.addVars([(i, j) for i in range(n) for j in range(n) if i != j], vtype=GRB.BINARY, name=""y"")
S = model.addVars([(i, m) for i in range(n) for m in range(4)], vtype=GRB.CONTINUOUS, name=""S"", lb=0)
Cmax = model.addVar(vtype=GRB.CONTINUOUS, name=""Cmax"", lb=0)

# Constraints
# Each job assigned to exactly one position
for i in range(n):
    model.addConstr(gp.quicksum(x[i, k] for k in range(p)) == 1, name=f""job_assign_{i}"")

# Each position assigned to exactly one job
for k in range(p):
    model.addConstr(gp.quicksum(x[i, k] for i in range(n)) == 1, name=f""pos_assign_{k}"")

# Position of each job
for i in range(n):
    model.addConstr(pos[i] == gp.quicksum((k + 1) * x[i, k] for k in range(p)), name=f""pos_def_{i}"")

# Precedence variables
for i in range(n):
    for j in range(i + 1, n):
        model.addConstr(y[i, j] + y[j, i] == 1, name=f""precedence_{i}_{j}"")

# Position ordering constraints
for i in range(n):
    for j in range(n):
        if i != j:
            model.addConstr(pos[i] - pos[j] <= -1 + M * (1 - y[i, j]), name=f""pos_order_{i}_{j}"")

# Stage start time constraints
for i in range(n):
    for m_stage in range(1, 4):
        model.addConstr(S[i, m_stage] >= S[i, m_stage - 1] + t[i][m_stage - 1], name=f""stage_start_{i}_{m_stage}"")

# Precedence on start times
for i in range(n):
    for j in range(n):
        if i != j:
            for m_stage in range(4):
                model.addConstr(S[i, m_stage] + t[i][m_stage] <= S[j, m_stage] + M * (1 - y[i, j]), name=f""start_order_{i}_{j}_{m_stage}"")

# Makespan constraints
for i in range(n):
    model.addConstr(Cmax >= S[i, 3] + t[i][3], name=f""makespan_{i}"")

# Objective
model.setObjective(Cmax, GRB.MINIMIZE)

# Optimize
model.optimize()

# Print solution
if model.status == GRB.OPTIMAL:
    print(f""Optimal makespan: {Cmax.X}"")
    for i in range(n):
        assigned_pos = None
        for k in range(p):
            if x[i, k].X > 0.5:
                assigned_pos = k + 1
                break
        print(f""Job {i} assigned to position {assigned_pos}"")
        for m_stage in range(4):
            print(f""  Stage {m_stage} start time: {S[i, m_stage].X}"")
else:
    print(""No optimal solution found."")",,62,0,,,,,,,,
"Minimize the total operational cost of a power generation system over six periods, consisting of Type 0 and Type 1 generators. The cost includes a fixed base cost of 80 units per generator per period, a power generation cost of 4 units per MW produced, and startup costs of 354 units for Type 0 generators and 347 units for Type 1 generators. The system must meet the following demand in each period: 201 MW in period 0, 191 MW in period 1, 182 MW in period 2, 190 MW in period 3, 194 MW in period 4, and 168 MW in period 5. Each Type 0 generator can produce between 34 MW and 127 MW, and no more than 4 Type 0 generators can operate in any period. Each Type 1 generator can produce between 35 MW and 129 MW, and no more than 1 Type 1 generator can operate in any period. The total maximum power output of all generators in each period must be at least 15% higher than the demand for that period, ensuring a reserve margin. For Type 0 generators, the number of operational generators in any period cannot exceed the number from the previous period plus the number started in the current period, and the same applies to Type 1 generators. The number of generators and startup decisions must be integers. The goal is to determine the optimal number of generators to operate, their power output levels, and startup decisions to minimize total costs while satisfying all constraints.","\[
\begin{aligned}
\min\ & \sum_{t=0}^{5}\Bigl(80\,n_{0t}+80\,n_{1t}+4\,(p_{0t}+p_{1t})+354\,s_{0t}+347\,s_{1t}\Bigr)\\
\text{s.t.}\ & p_{0t}\ge 34\,n_{0t}\quad\forall t\\
& p_{0t}\le 127\,n_{0t}\quad\forall t\\
& p_{1t}\ge 35\,n_{1t}\quad\forall t\\
& p_{1t}\le 129\,n_{1t}\quad\forall t\\
& p_{0t}+p_{1t}\ge D_t\quad\forall t\\
& 127\,n_{0t}+129\,n_{1t}\ge 1.15\,D_t\quad\forall t\\
& n_{0t}\le n_{0,t-1}+s_{0t}\quad\forall t>0\\
& n_{1t}\le n_{1,t-1}+s_{1t}\quad\forall t>0\\
& n_{00}\le s_{00}\\
& n_{10}\le s_{10}\\
& n_{0t}\le 4,\; n_{1t}\le 1,\; s_{0t}\le 4,\; s_{1t}\le 1\quad\forall t\\
& n_{0t},n_{1t},s_{0t},s_{1t}\in\mathbb{Z}_+,\; p_{0t},p_{1t}\in\mathbb{R}_+,
\end{aligned}
\] where \(D_0=201,\ D_1=191,\ D_2=182,\ D_3=190,\ D_4=194,\ D_5=168\).","import gurobipy as gp
from gurobipy import GRB

# Demand data
D = [201, 191, 182, 190, 194, 168]

# Create model
m = gp.Model(""Production_Planning"")

# Decision variables
n0 = m.addVars(6, vtype=GRB.INTEGER, lb=0, ub=4, name=""n0"")
n1 = m.addVars(6, vtype=GRB.INTEGER, lb=0, ub=1, name=""n1"")
s0 = m.addVars(6, vtype=GRB.INTEGER, lb=0, ub=4, name=""s0"")
s1 = m.addVars(6, vtype=GRB.INTEGER, lb=0, ub=1, name=""s1"")
p0 = m.addVars(6, vtype=GRB.CONTINUOUS, lb=0, name=""p0"")
p1 = m.addVars(6, vtype=GRB.CONTINUOUS, lb=0, name=""p1"")

# Constraints
for t in range(6):
    # Production bounds
    m.addConstr(p0[t] >= 34 * n0[t], name=f""p0_min_{t}"")
    m.addConstr(p0[t] <= 127 * n0[t], name=f""p0_max_{t}"")
    m.addConstr(p1[t] >= 35 * n1[t], name=f""p1_min_{t}"")
    m.addConstr(p1[t] <= 129 * n1[t], name=f""p1_max_{t}"")
    # Demand satisfaction
    m.addConstr(p0[t] + p1[t] >= D[t], name=f""demand_{t}"")
    # Capacity requirement
    m.addConstr(127 * n0[t] + 129 * n1[t] >= 1.15 * D[t], name=f""capacity_{t}"")
    # Inventory dynamics
    if t > 0:
        m.addConstr(n0[t] <= n0[t-1] + s0[t], name=f""inv0_{t}"")
        m.addConstr(n1[t] <= n1[t-1] + s1[t], name=f""inv1_{t}"")
    else:
        m.addConstr(n0[0] <= s0[0], name=""inv0_0"")
        m.addConstr(n1[0] <= s1[0], name=""inv1_0"")

# Objective function
obj = gp.quicksum(
    80 * n0[t] + 80 * n1[t] + 4 * (p0[t] + p1[t]) + 354 * s0[t] + 347 * s1[t]
    for t in range(6)
)
m.setObjective(obj, GRB.MINIMIZE)

# Solve the model
m.optimize()",6165,5464,0,,,,,,,,
"You are tasked with managing the distribution of resources across a network of eight cities. Each city has a specific supply of resources and a demand that must be met. The goal is to minimize the total cost of transporting resources between cities while ensuring that all demands are satisfied and all constraints are respected.

#### City Details:
- **City 0** has a net supply of 4 units.
- **City 1** has a net demand of 1 unit.
- **City 2** has a net demand of 2 units.
- **City 3** has a net supply of 1 unit.
- **City 4** has a net demand of 1 unit.
- **City 5** has a net demand of 1 unit.
- **City 6** and **City 7** are balanced, with no net supply or demand.

#### Transportation Costs:
The cost of transporting resources between cities varies. Here are the costs for each possible route:
- From **City 0** to **City 1**: 3 units
- From **City 0** to **City 2**: 3 units
- From **City 0** to **City 3**: 3 units
- From **City 0** to **City 4**: 3 units
- From **City 0** to **City 5**: 1 unit
- From **City 0** to **City 6**: 3 units
- From **City 0** to **City 7**: 2 units
- From **City 1** to **City 0**: 3 units
- From **City 1** to **City 2**: 2 units
- From **City 1** to **City 3**: 2 units
- From **City 1** to **City 4**: 3 units
- From **City 1** to **City 5**: 2 units
- From **City 1** to **City 6**: 2 units
- From **City 1** to **City 7**: 1 unit
- From **City 2** to **City 0**: 1 unit
- From **City 2** to **City 1**: 1 unit
- From **City 2** to **City 3**: 3 units
- From **City 2** to **City 4**: 1 unit
- From **City 2** to **City 5**: 2 units
- From **City 2** to **City 6**: 2 units
- From **City 2** to **City 7**: 3 units
- From **City 3** to **City 0**: 1 unit
- From **City 3** to **City 1**: 3 units
- From **City 3** to **City 2**: 1 unit
- From **City 3** to **City 4**: 1 unit
- From **City 3** to **City 5**: 1 unit
- From **City 3** to **City 6**: 2 units
- From **City 3** to **City 7**: 3 units
- From **City 4** to **City 0**: 3 units
- From **City 4** to **City 1**: 2 units
- From **City 4** to **City 2**: 1 unit
- From **City 4** to **City 3**: 2 units
- From **City 4** to **City 5**: 3 units
- From **City 4** to **City 6**: 2 units
- From **City 4** to **City 7**: 3 units
- From **City 5** to **City 0**: 1 unit
- From **City 5** to **City 1**: 2 units
- From **City 5** to **City 2**: 3 units
- From **City 5** to **City 3**: 2 units
- From **City 5** to **City 4**: 1 unit
- From **City 5** to **City 6**: 3 units
- From **City 5** to **City 7**: 3 units
- From **City 6** to **City 0**: 3 units
- From **City 6** to **City 1**: 1 unit
- From **City 6** to **City 2**: 1 unit
- From **City 6** to **City 3**: 3 units
- From **City 6** to **City 4**: 2 units
- From **City 6** to **City 5**: 1 unit
- From **City 6** to **City 7**: 3 units
- From **City 7** to **City 0**: 3 units
- From **City 7** to **City 1**: 3 units
- From **City 7** to **City 2**: 1 unit
- From **City 7** to **City 3**: 2 units
- From **City 7** to **City 4**: 2 units
- From **City 7** to **City 5**: 1 unit
- From **City 7** to **City 6**: 3 units

#### Constraints:
1. **Flow Balance**: The total resources entering a city must equal the total resources leaving that city, adjusted for its supply or demand.
2. **Link Capacity**: The amount of resources transported between any two cities cannot exceed the capacity of the link:
   - **City 0** to **City 1**: 9 units
   - **City 0** to **City 2**: 7 units
   - **City 0** to **City 3**: 9 units
   - **City 0** to **City 4**: 7 units
   - **City 0** to **City 5**: 8 units
   - **City 0** to **City 6**: 9 units
   - **City 0** to **City 7**: 9 units
   - **City 1** to **City 0**: 9 units
   - **City 1** to **City 2**: 7 units
   - **City 1** to **City 3**: 9 units
   - **City 1** to **City 4**: 7 units
   - **City 1** to **City 5**: 9 units
   - **City 1** to **City 6**: 8 units
   - **City 1** to **City 7**: 7 units
   - **City 2** to **City 0**: 8 units
   - **City 2** to **City 1**: 7 units
   - **City 2** to **City 3**: 8 units
   - **City 2** to **City 4**: 9 units
   - **City 2** to **City 5**: 9 units
   - **City 2** to **City 6**: 7 units
   - **City 2** to **City 7**: 8 units
   - **City 3** to **City 0**: 7 units
   - **City 3** to **City 1**: 7 units
   - **City 3** to **City 2**: 9 units
   - **City 3** to **City 4**: 9 units
   - **City 3** to **City 5**: 9 units
   - **City 3** to **City 6**: 7 units
   - **City 3** to **City 7**: 9 units
   - **City 4** to **City 0**: 8 units
   - **City 4** to **City 1**: 8 units
   - **City 4** to **City 2**: 8 units
   - **City 4** to **City 3**: 8 units
   - **City 4** to **City 5**: 8 units
   - **City 4** to **City 6**: 8 units
   - **City 4** to **City 7**: 9 units
   - **City 5** to **City 0**: 7 units
   - **City 5** to **City 1**: 9 units
   - **City 5** to **City 2**: 8 units
   - **City 5** to **City 3**: 7 units
   - **City 5** to **City 4**: 7 units
   - **City 5** to **City 6**: 9 units
   - **City 5** to **City 7**: 7 units
   - **City 6** to **City 0**: 9 units
   - **City 6** to **City 1**: 8 units
   - **City 6** to **City 2**: 8 units
   - **City 6** to **City 3**: 7 units
   - **City 6** to **City 4**: 7 units
   - **City 6** to **City 5**: 8 units
   - **City 6** to **City 7**: 8 units
   - **City 7** to **City 0**: 9 units
   - **City 7** to **City 1**: 9 units
   - **City 7** to **City 2**: 7 units
   - **City 7** to **City 3**: 8 units
   - **City 7** to **City 4**: 8 units
   - **City 7** to **City 5**: 8 units
   - **City 7** to **City 6**: 8 units

3. **City Capacity**: The total resources entering a city cannot exceed its capacity:
   - **City 0**: 19 units
   - **City 1**: 17 units
   - **City 2**: 15 units
   - **City 3**: 16 units
   - **City 4**: 14 units
   - **City 5**: 15 units
   - **City 6**: 14 units
   - **City 7**: 13 units

#### Objective:
Your objective is to determine the optimal amount of resources to transport between each pair of cities to minimize the total transportation cost while ensuring that all demands are met and all constraints are satisfied.

This problem requires careful planning to balance the supply and demand across the network, respecting the capacity limits of both the transportation links and the cities themselves. The solution will provide the most cost-effective way to distribute resources across the cities.","\[
\begin{aligned}
\min\quad & \sum_{i=0}^{7}\sum_{\substack{j=0\\ j\neq i}}^{7} c_{ij}\,x_{ij} \\[4pt]
\text{s.t.}\quad & \sum_{\substack{j=0\\ j\neq i}}^{7} x_{ij}-\sum_{\substack{j=0\\ j\neq i}}^{7} x_{ji}=s_i
&&\forall\,i=0,\dots,7 \\[4pt]
& x_{ij}\leq \bar{c}_{ij}
&&\forall\,i=0,\dots,7,\;\forall\,j=0,\dots,7,\;j\neq i \\[4pt]
& \sum_{\substack{j=0\\ j\neq i}}^{7} x_{ji}\leq C_i
&&\forall\,i=0,\dots,7 \\[4pt]
& x_{ij}\in\mathbb{R}_+ &&\forall\,i=0,\dots,7,\;\forall\,j=0,\dots,7,\;j\neq i
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB
import numpy as np

# Example data (replace with actual values)
c = np.random.rand(8,8)          # cost matrix
bar_c = np.random.rand(8,8)      # upper bounds for x_ij
s = np.random.randn(8)           # supply/demand vector
C = np.random.rand(8) * 10       # capacity limits

# Create model
m = gp.Model(""Flow_Optimization"")

# Decision variables x_ij for i != j
x = {}
for i in range(8):
    for j in range(8):
        if i != j:
            x[i,j] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=f""x_{i}_{j}"")

m.update()

# Objective: minimize total cost
m.setObjective(gp.quicksum(c[i,j]*x[i,j] for i in range(8) for j in range(8) if i!=j), GRB.MINIMIZE)

# Flow balance constraints: outflow - inflow = s_i
for i in range(8):
    outflow = gp.quicksum(x[i,j] for j in range(8) if i!=j)
    inflow  = gp.quicksum(x[j,i] for j in range(8) if i!=j)
    m.addConstr(outflow - inflow == s[i], name=f""balance_{i}"")

# Upper bound constraints: x_ij <= bar_c_ij
for i in range(8):
    for j in range(8):
        if i != j:
            m.addConstr(x[i,j] <= bar_c[i,j], name=f""ub_{i}_{j}"")

# Capacity constraints: sum of inflows to node i <= C_i
for i in range(8):
    inflow = gp.quicksum(x[j,i] for j in range(8) if i!=j)
    m.addConstr(inflow <= C[i], name=f""capacity_{i}"")

# Optimize
m.optimize()",,7,0,,,,,,,,
"The problem involves determining the most cost-effective way to transport medical supplies across a network of 10 hospitals (node_0 to node_9) while minimizing total transportation costs. Each hospital is interconnected, and the cost of transporting supplies between any two hospitals varies. The decision variables are binary, representing whether a route between two hospitals is used (1) or not (0). The objective is to minimize the total cost of transporting supplies, calculated as the sum of the costs of all activated routes.

The constraints ensure that the supply balance is maintained across all hospitals. Specifically, node_0 must have a net supply of +1, indicating it is the source of supplies, while node_9 must have a net supply of -1, indicating it is the destination. All intermediate hospitals (node_1 to node_8) must have a net supply of 0, meaning they neither gain nor lose supplies overall. The flow balance constraints ensure that the total flow into each hospital equals the total flow out of it, with the exception of node_0 and node_9, which have specific net supply requirements. All decision variables are binary, meaning routes are either fully used or not used at all. The goal is to find the set of routes that satisfies these constraints while minimizing the total transportation cost.","\[
\begin{aligned}
\min\quad & \sum_{i=0}^{9}\sum_{\substack{j=0\\ j\neq i}}^{9} c_{ij}\,x_{ij} \\
\text{s.t.}\quad & \sum_{\substack{j=0\\ j\neq k}}^{9} x_{kj} - \sum_{\substack{i=0\\ i\neq k}}^{9} x_{ik} =
\begin{cases}
1 & k=0\\
-1 & k=9\\
0 & k=1,\dots,8
\end{cases}\quad \forall k\in\{0,\dots,9\}\\
& x_{ij}\in\{0,1\}\quad \forall i,j\in\{0,\dots,9\},\, i\neq j
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB
import numpy as np

# Example cost matrix (replace with actual data)
c = np.random.randint(1, 100, size=(10, 10))
np.fill_diagonal(c, 0)

m = gp.Model(""TSP_path"")

# Decision variables x[i,j] for i != j
x = m.addVars(10, 10, vtype=GRB.BINARY, name=""x"")

# Objective: minimize total cost
m.setObjective(
    gp.quicksum(c[i, j] * x[i, j] for i in range(10) for j in range(10) if i != j),
    GRB.MINIMIZE
)

# Flow conservation constraints
for k in range(10):
    outflow = gp.quicksum(x[k, j] for j in range(10) if j != k)
    inflow = gp.quicksum(x[i, k] for i in range(10) if i != k)
    if k == 0:
        m.addConstr(outflow - inflow == 1, name=f""flow_start_{k}"")
    elif k == 9:
        m.addConstr(outflow - inflow == -1, name=f""flow_end_{k}"")
    else:
        m.addConstr(outflow - inflow == 0, name=f""flow_{k}"")

m.optimize()",24,20,0,,,,,,,,
"There are 7 jobs, each with 2 operations that must be performed in sequence. Each operation has a processing time of 1 unit of time. The facility has multiple machines, and some operations from different jobs must be performed on the same machine. Operations sharing the same machine cannot overlap in time. The order of operations on shared machines is determined by binary decision variables, which can only take values of 0 or 1. The goal is to minimize the total completion time, known as the makespan, which is the latest completion time among all operations. 

Each operation in a job must start only after the previous operation in the same job is completed. Operations that share the same machine must be scheduled such that one starts only after the other is completed, as determined by the binary variables. The makespan must be at least as large as the completion time of every operation. All operation start times must be non-negative. The binary variables enforce the order of operations on shared machines, ensuring no overlap. The processing time for all operations is 1 unit of time. The makespan is determined by the latest completion time among all operations, and the objective is to minimize this makespan.","\[
\begin{aligned}
\min\quad & C_{\max} \\
\text{s.t.}\quad & s_{j,1}\ge 0 && \forall j=1,\dots,7 \\
& s_{j,2}\ge 0 && \forall j=1,\dots,7 \\
& s_{j,2}\ge s_{j,1}+1 && \forall j=1,\dots,7 \\
& s_{i}+1\le s_{k}+M(1-y_{i,k}) && \forall (i,k)\in P \\
& s_{k}+1\le s_{i}+M y_{i,k} && \forall (i,k)\in P \\
& C_{\max}\ge s_{j,o}+1 && \forall j=1,\dots,7,\; o=1,2 \\
& y_{i,k}\in\{0,1\} && \forall (i,k)\in P \\
& s_{j,o}\in\mathbb{R}_+ && \forall j=1,\dots,7,\; o=1,2 \\
& C_{\max}\in\mathbb{R}_+ \\
\end{aligned}
\] where \(M=14\) and \(P\) is the set of unordered pairs of operations that share a machine.","import gurobipy as gp
from gurobipy import GRB

M = 14
jobs = range(1, 8)
ops = [1, 2]

m = gp.Model(""Job_Scheduling"")

s = m.addVars(jobs, ops, vtype=GRB.CONTINUOUS, lb=0, name=""s"")
Cmax = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""Cmax"")

# Define pairs of operations that share a machine
P = []  # Example: P = [((1,1),(2,1)), ((3,2),(4,1)), ...]

y = {}
for (i, oi), (k, ok) in P:
    y[(i, oi, k, ok)] = m.addVar(vtype=GRB.BINARY, name=f""y_{i}_{oi}_{k}_{ok}"")

m.setObjective(Cmax, GRB.MINIMIZE)

for j in jobs:
    m.addConstr(s[j, 1] >= 0, name=f""s_{j}_1_nonneg"")
    m.addConstr(s[j, 2] >= 0, name=f""s_{j}_2_nonneg"")
    m.addConstr(s[j, 2] >= s[j, 1] + 1, name=f""seq_{j}"")

for j in jobs:
    for o in ops:
        m.addConstr(Cmax >= s[j, o] + 1, name=f""Cmax_{j}_{o}"")

for (i, oi), (k, ok) in P:
    yvar = y[(i, oi, k, ok)]
    m.addConstr(s[i, oi] + 1 <= s[k, ok] + M * (1 - yvar), name=f""pre1_{i}_{oi}_{k}_{ok}"")
    m.addConstr(s[k, ok] + 1 <= s[i, oi] + M * yvar, name=f""pre2_{i}_{oi}_{k}_{ok}"")

m.optimize()",2,3,0,,,,,,,,
"Minimize the total penalty costs associated with landing five aircraft either earlier or later than their target times, while ensuring safe separation between consecutive landings. Each aircraft has a target landing time, earliest and latest possible landing times, and penalties for landing early or late. The penalties are \$15, \$10, \$17, \$15, and \$15 per minute early, and \$11, \$16, \$17, \$15, and \$12 per minute late for Aircraft 0, 1, 2, 3, and 4, respectively. The target landing times are 71, 95, 73, 80, and 78 minutes, with earliest landing times of 60, 65, 60, 60, and 60 minutes, and latest landing times of 100 minutes for all aircraft.

To ensure safety, specific separation times must be maintained between consecutive landings. If Aircraft 0 lands before Aircraft 1, there must be at least 7 minutes between their landings. If Aircraft 0 lands before Aircraft 2, there must be at least 5 minutes between their landings. If Aircraft 0 lands before Aircraft 3, there must be at least 5 minutes between their landings. If Aircraft 0 lands before Aircraft 4, there must be at least 6 minutes between their landings. If Aircraft 1 lands before Aircraft 2, there must be at least 5 minutes between their landings. If Aircraft 1 lands before Aircraft 3, there must be at least 8 minutes between their landings. If Aircraft 1 lands before Aircraft 4, there must be at least 6 minutes between their landings. If Aircraft 2 lands before Aircraft 3, there must be at least 7 minutes between their landings. If Aircraft 2 lands before Aircraft 4, there must be at least 7 minutes between their landings. If Aircraft 3 lands before Aircraft 4, there must be at least 7 minutes between their landings.

The landing time for each aircraft must be between its earliest and latest possible landing times. The separation times between consecutive landings must be enforced based on the order in which the aircraft land. The penalties for landing early or late are applied based on the deviation from the target landing times. The objective is to determine the actual landing times for all five aircraft such that the total penalty cost is minimized, each aircraft lands within its specified earliest and latest landing times, and the required separation times between consecutive landings are strictly maintained. Binary decision variables are used to determine the order of landings between aircraft pairs, ensuring proper separation based on the landing order. Constraints enforce the relationship between landing times and the binary variables, ensuring proper separation based on the landing order. The binary variables are restricted to 0 or 1.","\[
\begin{aligned}
\min \quad & 15\,e_0+10\,e_1+17\,e_2+15\,e_3+15\,e_4
          +11\,l_0+16\,l_1+17\,l_2+15\,l_3+12\,l_4 \\[4pt]
\text{s.t.}\quad
& t_0 = 71 - e_0 + l_0, \\
& t_1 = 95 - e_1 + l_1, \\
& t_2 = 73 - e_2 + l_2, \\
& t_3 = 80 - e_3 + l_3, \\
& t_4 = 78 - e_4 + l_4, \\[4pt]
& t_0 \ge 60,\; t_1 \ge 65,\; t_2 \ge 60,\; t_3 \ge 60,\; t_4 \ge 60, \\[4pt]
& t_0 \le 100,\; t_1 \le 100,\; t_2 \le 100,\; t_3 \le 100,\; t_4 \le 100, \\[4pt]
& e_i \le 200\,s_i,\; l_i \le 200\,(1-s_i)\quad \forall i=0,\dots,4, \\[4pt]
& t_1 - t_0 \ge 7 - 200(1-y_{01}), \\
& t_0 - t_1 \ge 7 - 200\,y_{01}, \\[2pt]
& t_2 - t_0 \ge 5 - 200(1-y_{02}), \\
& t_0 - t_2 \ge 5 - 200\,y_{02}, \\[2pt]
& t_3 - t_0 \ge 5 - 200(1-y_{03}), \\
& t_0 - t_3 \ge 5 - 200\,y_{03}, \\[2pt]
& t_4 - t_0 \ge 6 - 200(1-y_{04}), \\
& t_0 - t_4 \ge 6 - 200\,y_{04}, \\[2pt]
& t_2 - t_1 \ge 5 - 200(1-y_{12}), \\
& t_1 - t_2 \ge 5 - 200\,y_{12}, \\[2pt]
& t_3 - t_1 \ge 8 - 200(1-y_{13}), \\
& t_1 - t_3 \ge 8 - 200\,y_{13}, \\[2pt]
& t_4 - t_1 \ge 6 - 200(1-y_{14}), \\
& t_1 - t_4 \ge 6 - 200\,y_{14}, \\[2pt]
& t_3 - t_2 \ge 7 - 200(1-y_{23}), \\
& t_2 - t_3 \ge 7 - 200\,y_{23}, \\[2pt]
& t_4 - t_2 \ge 7 - 200(1-y_{24}), \\
& t_2 - t_4 \ge 7 - 200\,y_{24}, \\[2pt]
& t_4 - t_3 \ge 7 - 200(1-y_{34}), \\
& t_3 - t_4 \ge 7 - 200\,y_{34}, \\[4pt]
& e_i,\;l_i,\;t_i \ge 0 \quad \forall i, \\[2pt]
& s_i \in \{0,1\}\quad \forall i, \\
& y_{ij} \in \{0,1\}\quad \forall i<j .
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

m = gp.Model(""Optimization"")

# Decision variables
e = m.addVars(5, vtype=GRB.CONTINUOUS, lb=0, name=""e"")
l = m.addVars(5, vtype=GRB.CONTINUOUS, lb=0, name=""l"")
t = m.addVars(5, vtype=GRB.CONTINUOUS, lb=0, name=""t"")
s = m.addVars(5, vtype=GRB.BINARY, name=""s"")

# Binary variables for pairwise ordering
pairs = [(0,1),(0,2),(0,3),(0,4),(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
y = m.addVars(pairs, vtype=GRB.BINARY, name=""y"")

# Objective function
m.setObjective(
    15*e[0] + 10*e[1] + 17*e[2] + 15*e[3] + 15*e[4] +
    11*l[0] + 16*l[1] + 17*l[2] + 15*l[3] + 12*l[4],
    GRB.MINIMIZE
)

# t equations
m.addConstr(t[0] == 71 - e[0] + l[0], name=""t0_eq"")
m.addConstr(t[1] == 95 - e[1] + l[1], name=""t1_eq"")
m.addConstr(t[2] == 73 - e[2] + l[2], name=""t2_eq"")
m.addConstr(t[3] == 80 - e[3] + l[3], name=""t3_eq"")
m.addConstr(t[4] == 78 - e[4] + l[4], name=""t4_eq"")

# t bounds
for i in range(5):
    m.addConstr(t[i] >= 60, name=f""t{i}_lb"")
    m.addConstr(t[i] <= 100, name=f""t{i}_ub"")

# e and l bounds with s
for i in range(5):
    m.addConstr(e[i] <= 200*s[i], name=f""e{i}_s"")
    m.addConstr(l[i] <= 200*(1-s[i]), name=f""l{i}_s"")

# Pairwise constraints
delta = {(0,1):7,(0,2):5,(0,3):5,(0,4):6,
         (1,2):5,(1,3):8,(1,4):6,
         (2,3):7,(2,4):7,(3,4):7}
M = 200
for (i,j) in pairs:
    d = delta[(i,j)]
    m.addConstr(t[j] - t[i] >= d - M*(1-y[i,j]), name=f""pair_{i}_{j}_1"")
    m.addConstr(t[i] - t[j] >= d - M*y[i,j], name=f""pair_{i}_{j}_2"")

# Solve the model
m.optimize()
",153,153,1,,,,,,,,
"You are managing a manufacturing facility that produces three types of products (Product 0, Product 1, and Product 2) using two machines (Machine 0 and Machine 1) over three time periods (Period 0, Period 1, and Period 2). Your goal is to minimize the total operational costs, which include production setup costs, machine startup costs, inventory holding costs, and backlogging costs, while meeting customer demand for each product in each period.

For each product, machine, and time period, decide whether to produce the product and how much to produce. For each machine and time period, decide whether to start up the machine to begin production. For each product and time period, decide how much inventory to carry over to the next period or how much demand to backlog if production falls short.

Minimize the total cost, which includes production setup costs of 145.4242073380383 per production decision, machine startup costs of 79.18604813454679 per startup decision, inventory holding costs of 0.9008900951620358 for Product 0, 1.068925395295676 for Product 1, and 1.066244796883431 for Product 2 per unit per period, and backlogging costs of 6.734178682720012 for Product 0, 7.442225721133133 for Product 1, and 7.104627209109436 for Product 2 per unit per period.

For each product and time period, the total production across machines, plus any inventory carried over from the previous period, minus any backlog from the previous period, must equal the demand for that period plus the current inventory minus the current backlog. The demands for each product and period are as follows: Product 0: Period 0 = 20.33410585875594, Period 1 = 22.57961652322203, Period 2 = 15.89714240515548; Product 1: Period 0 = 24.05647618194615, Period 1 = 20.36522893983323, Period 2 = 17.47466293074195; Product 2: Period 0 = 16.36553930950429, Period 1 = 22.7831030020558, Period 2 = 19.7805033393852.

For each machine and time period, the production quantity multiplied by -71.79935969683524 for Machine 0 or -73.09691843304661 for Machine 1, plus the startup time multiplied by 6.342821301312698 for Machine 0 or 6.171760083826499 for Machine 1, plus the amount produced must be less than or equal to zero. Each machine can only produce one product at a time in any given period, meaning the sum of production decisions across all products for a given machine and period must be less than or equal to 1.

If a machine is producing a product in a period but was not producing it in the previous period, a startup decision must be made. Production quantities, inventory levels, and backlogs must be non-negative. Production and startup decisions are binary (either 0 or 1).","\[
\begin{aligned}
\min\;&\sum_{m=0}^{1}\sum_{p=0}^{2}\sum_{t=0}^{2}
145.4242073380383\,x_{mpt}
+\sum_{m=0}^{1}\sum_{t=0}^{2}
79.18604813454679\,s_{mt} \\
&\quad+\sum_{p=0}^{2}\sum_{t=0}^{2}
h_{p}\,I_{pt}
+\sum_{p=0}^{2}\sum_{t=0}^{2}
b_{p}\,B_{pt} \\[4pt]
\text{s.t.}\;&
-71.79935969683524\,q_{0pt}
+6.342821301312698\,s_{0t}
+x_{0pt}\le 0
\quad\forall p,t,\\
&-73.09691843304661\,q_{1pt}
+6.171760083826499\,s_{1t}
+x_{1pt}\le 0
\quad\forall p,t,\\[4pt]
&\sum_{p=0}^{2}x_{mpt}\le 1
\quad\forall m,t,\\[4pt]
&s_{m0}\ge\sum_{p=0}^{2}x_{mp0}
\quad\forall m,\\
&s_{mt}\ge\sum_{p=0}^{2}x_{mpt}
-\sum_{p=0}^{2}x_{mp(t-1)}
\quad\forall m,\;t=1,2,\\[4pt]
&I_{pt}-B_{pt}
=\sum_{m=0}^{1}q_{mpt}
+I_{p(t-1)}-B_{p(t-1)}-d_{pt}
\quad\forall p,\;t=0,1,2,\\
&\quad I_{p(-1)}=0,\;B_{p(-1)}=0,\\[4pt]
&q_{mpt}\ge0,\;I_{pt}\ge0,\;B_{pt}\ge0
\quad\forall m,p,t,\\[4pt]
&x_{mpt}\in\{0,1\},\;
s_{mt}\in\{0,1\}
\quad\forall m,p,t.
\end{aligned}
\]

where  

\[
\begin{aligned}
&h_{0}=0.9008900951620358,\;h_{1}=1.068925395295676,\;h_{2}=1.066244796883431,\\
&b_{0}=6.734178682720012,\;b_{1}=7.442225721133133,\;b_{2}=7.104627209109436,\\
&d_{0,0}=20.33410585875594,\;d_{0,1}=22.57961652322203,\;d_{0,2}=15.89714240515548,\\
&d_{1,0}=24.05647618194615,\;d_{1,1}=20.36522893983323,\;d_{1,2}=17.47466293074195,\\
&d_{2,0}=16.36553930950429,\;d_{2,1}=22.7831030020558,\;d_{2,2}=19.7805033393852.
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Parameters
h = {0: 0.9008900951620358, 1: 1.068925395295676, 2: 1.066244796883431}
b = {0: 6.734178682720012, 1: 7.442225721133133, 2: 7.104627209109436}
d = {
    (0,0): 20.33410585875594, (0,1): 22.57961652322203, (0,2): 15.89714240515548,
    (1,0): 24.05647618194615, (1,1): 20.36522893983323, (1,2): 17.47466293074195,
    (2,0): 16.36553930950429, (2,1): 22.7831030020558,  (2,2): 19.7805033393852
}

# Indices
Ms = [0,1]
Ps = [0,1,2]
Ts = [0,1,2]

# Create model
m = gp.Model(""Optimization_Model"")

# Decision variables
x = m.addVars(Ms, Ps, Ts, vtype=GRB.BINARY, name=""x"")
s = m.addVars(Ms, Ts, vtype=GRB.BINARY, name=""s"")
q = m.addVars(Ms, Ps, Ts, vtype=GRB.CONTINUOUS, lb=0, name=""q"")
I = m.addVars(Ps, Ts, vtype=GRB.CONTINUOUS, lb=0, name=""I"")
B = m.addVars(Ps, Ts, vtype=GRB.CONTINUOUS, lb=0, name=""B"")

# Objective function
obj = gp.quicksum(145.4242073380383 * x[m,p,t] for m in Ms for p in Ps for t in Ts)
obj += gp.quicksum(79.18604813454679 * s[m,t] for m in Ms for t in Ts)
obj += gp.quicksum(h[p] * I[p,t] for p in Ps for t in Ts)
obj += gp.quicksum(b[p] * B[p,t] for p in Ps for t in Ts)
m.setObjective(obj, GRB.MINIMIZE)

# Constraints
# Inequalities involving q, s, x
for p in Ps:
    for t in Ts:
        m.addConstr(-71.79935969683524 * q[0,p,t] + 6.342821301312698 * s[0,t] + x[0,p,t] <= 0, name=f""ineq0_{p}_{t}"")
        m.addConstr(-73.09691843304661 * q[1,p,t] + 6.171760083826499 * s[1,t] + x[1,p,t] <= 0, name=f""ineq1_{p}_{t}"")

# Sum of x over p <= 1
for m_idx in Ms:
    for t in Ts:
        m.addConstr(gp.quicksum(x[m_idx,p,t] for p in Ps) <= 1, name=f""sumx_{m_idx}_{t}"")

# s constraints
for m_idx in Ms:
    m.addConstr(s[m_idx,0] >= gp.quicksum(x[m_idx,p,0] for p in Ps), name=f""s0_{m_idx}"")
    for t in Ts[1:]:
        m.addConstr(s[m_idx,t] >= gp.quicksum(x[m_idx,p,t] for p in Ps) - gp.quicksum(x[m_idx,p,t-1] for p in Ps), name=f""s_{m_idx}_{t}"")

# Inventory balance constraints
for p in Ps:
    for t in Ts:
        if t == 0:
            prev_I = 0
            prev_B = 0
        else:
            prev_I = I[p,t-1]
            prev_B = B[p,t-1]
        m.addConstr(I[p,t] - B[p,t] == gp.quicksum(q[m,p,t] for m in Ms) + prev_I - prev_B - d[(p,t)], name=f""inv_{p}_{t}"")

# Solve
m.optimize()",0,919.3047226,0,,,,,,,,
"There are 5 jobs, labeled Job 0 to Job 4, each consisting of 2 operations. Each operation must be performed on a specific machine, and the order of operations within a job is fixed. For example, Operation 1 of Job 0 must be completed before Operation 2 of Job 0 can begin. The processing time for each operation is 1 unit of time. The facility has a limited number of machines, and some operations from different jobs must be performed on the same machine. To avoid conflicts, no two operations can be scheduled on the same machine at the same time. This requires determining the order in which operations are processed on each machine. For example, Operations from Job 1 and Job 2 both require Machine 1, and you must decide whether to process Job 1's operation before Job 2's, or vice versa. Similarly, Operations from Job 4 and Job 0 must be sequenced on Machine 2. Binary variables are used to indicate whether one operation is scheduled before another on the same machine, ensuring that the scheduling constraints are satisfied. The primary objective is to minimize the makespan, which is the total time required to complete all jobs, determined by the latest completion time among all operations. For example, if the last operation finishes at time 10, the makespan is 10. Constraints include precedence constraints, ensuring each operation within a job starts only after the previous operation in the same job has finished; machine capacity constraints, ensuring operations sharing the same machine do not overlap in time; makespan definition, ensuring the makespan is at least as large as the completion time of every operation; non-negativity constraints, ensuring all operation start times are non-negative; and binary variables, determining the order of operations on shared machines. The processing time for each operation is 1 unit of time, and binary variables are used with a large constant (100,000) to enforce sequencing constraints. For example, if a binary variable is 1, then one operation must finish before another starts on the same machine. The task is to determine the start times for all operations across all jobs, ensuring operations within the same job are performed in the correct sequence, operations sharing the same machine do not overlap, and the total completion time is minimized.","\[
\begin{aligned}
\min \quad & C \\
\text{s.t.}\quad
& s_{j,2} \;\ge\; s_{j,1} + 1 && \forall j=0,\dots,4 \\
& C \;\ge\; s_{j,k} + 1 && \forall j=0,\dots,4,\; k=1,2 \\
& s_{j,k} \;\ge\; 0 && \forall j,k \\
& s_{1,1} + 1 \;\le\; s_{2,1} + M(1-y_{12}) \\
& s_{2,1} + 1 \;\le\; s_{1,1} + M y_{12} \\
& s_{0,1} + 1 \;\le\; s_{4,1} + M(1-y_{04}) \\
& s_{4,1} + 1 \;\le\; s_{0,1} + M y_{04} \\
& y_{12},\,y_{04} \;\in\; \{0,1\} \\
& s_{j,k},\,C \;\in\; \mathbb{R}_+ \\
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Sequence_Optimization"")

# Big-M constant
M = 1000

# Decision variables
s = m.addVars(5, 3, lb=0, vtype=GRB.CONTINUOUS, name=""s"")  # indices: j=0..4, k=0..2 (use k=1,2)
C = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""C"")
y12 = m.addVar(vtype=GRB.BINARY, name=""y12"")
y04 = m.addVar(vtype=GRB.BINARY, name=""y04"")

# Objective: minimize C
m.setObjective(C, GRB.MINIMIZE)

# Constraints
for j in range(5):
    m.addConstr(s[j, 2] >= s[j, 1] + 1, name=f""seq_{j}"")

for j in range(5):
    for k in [1, 2]:
        m.addConstr(C >= s[j, k] + 1, name=f""C_ge_s_{j}_{k}"")

# Order constraints with big-M
m.addConstr(s[1, 1] + 1 <= s[2, 1] + M * (1 - y12), name=""order_1_2"")
m.addConstr(s[2, 1] + 1 <= s[1, 1] + M * y12, name=""order_2_1"")
m.addConstr(s[0, 1] + 1 <= s[4, 1] + M * (1 - y04), name=""order_0_4"")
m.addConstr(s[4, 1] + 1 <= s[0, 1] + M * y04, name=""order_4_0"")

# Solve the model
m.optimize()",3,4,0,,,,,,,,
" Cell Tower Coverage Planning

You are tasked with planning the deployment of cell towers across a region to maximize population coverage while adhering to a strict budget constraint. The region is divided into 35 distinct areas, each with a specific population size that needs to be served. Your goal is to determine which cell towers to build and which areas to cover to ensure the maximum number of people have access to cellular service.

#### Key Decisions:
1. **Build or Not Build**: For each of the 26 potential cell tower locations, you must decide whether to build the tower (a binary decision: build or not build).
2. **Coverage Assignment**: For each of the 35 areas, you must determine whether it will be covered by the deployed towers (a binary decision: covered or not covered).

#### Objective:
Maximize the total population covered by the deployed cell towers. The population sizes for the 35 areas are as follows:
- Area 0: 3,215 people
- Area 1: 2,395 people
- Area 2: 4,466 people
- Area 3: 2,520 people
- Area 4: 2,192 people
- Area 5: 4,625 people
- Area 6: 4,796 people
- Area 7: 2,973 people
- Area 8: 2,034 people
- Area 9: 2,754 people
- Area 10: 2,143 people
- Area 11: 2,473 people
- Area 12: 3,099 people
- Area 13: 4,136 people
- Area 14: 2,154 people
- Area 15: 3,411 people
- Area 16: 3,230 people
- Area 17: 2,155 people
- Area 18: 4,907 people
- Area 19: 2,665 people
- Area 20: 4,708 people
- Area 21: 4,494 people
- Area 22: 2,381 people
- Area 23: 3,077 people
- Area 24: 2,699 people
- Area 25: 3,320 people
- Area 26: 4,931 people
- Area 27: 4,645 people
- Area 28: 2,346 people
- Area 29: 4,393 people
- Area 30: 4,051 people
- Area 31: 4,507 people
- Area 32: 4,610 people
- Area 33: 3,412 people
- Area 34: 3,059 people

#### Constraints:
1. **Coverage Requirements**:
   - Each area can only be considered covered if at least one of the cell towers assigned to it is built. For example:
     - Area 0 can be covered if any of the towers 1, 5, 10, 11, 13, 15, 18, 19, 20, 22, 23, or 24 are built.
     - Area 1 can be covered if any of the towers 3, 4, 6, 11, 12, 14, 15, 17, 18, 19, 21, 23, or 24 are built.
     - Similar constraints apply to all 35 areas, with specific combinations of towers required for coverage.

2. **Budget Constraint**:
   - The total cost of building the selected towers must not exceed the available budget of 2,894 units. The costs for building each tower are as follows:
     - Tower 0: 411 units
     - Tower 1: 294 units
     - Tower 2: 376 units
     - Tower 3: 447 units
     - Tower 4: 414 units
     - Tower 5: 498 units
     - Tower 6: 437 units
     - Tower 7: 272 units
     - Tower 8: 381 units
     - Tower 9: 323 units
     - Tower 10: 356 units
     - Tower 11: 200 units
     - Tower 12: 297 units
     - Tower 13: 428 units
     - Tower 14: 427 units
     - Tower 15: 484 units
     - Tower 16: 494 units
     - Tower 17: 436 units
     - Tower 18: 218 units
     - Tower 19: 428 units
     - Tower 20: 399 units
     - Tower 21: 484 units
     - Tower 22: 367 units
     - Tower 23: 204 units
     - Tower 24: 289 units
     - Tower 25: 283 units

3. **Binary Decisions**:
   - Each tower can either be built (1) or not built (0).
   - Each area can either be covered (1) or not covered (0).

#### Summary:
Your task is to select which towers to build and which areas to cover, ensuring that the total population covered is maximized while staying within the budget. The coverage of each area depends on the specific combination of towers built, and the total cost of building the selected towers must not exceed 2,894 units.","\begin{align*}\max 3215y_0+2395y_1+4466y_2+2520y_3+2192y_4+4625y_5+4796y_6+2973y_7+2034y_8+2754y_9+2143y_{10}+2473y_{11}+3099y_{12}+4136y_{13}+2154y_{14}+3411y_{15}+3230y_{16}+2155y_{17}+4907y_{18}+2665y_{19}+4708y_{20}+4494y_{21}+2381y_{22}+3077y_{23}+2699y_{24}+3320y_{25}+4931y_{26}+4645y_{27}+2346y_{28}+4393y_{29}+4051y_{30}+4507y_{31}+4610y_{32}+3412y_{33}+3059y_{34}\\\text{s.t. }y_a\le\sum_{t\in T_a}x_t\;\forall a=0,\dots,34;\;411x_0+294x_1+376x_2+447x_3+414x_4+498x_5+437x_6+272x_7+381x_8+323x_9+356x_{10}+200x_{11}+297x_{12}+428x_{13}+427x_{14}+484x_{15}+494x_{16}+436x_{17}+218x_{18}+428x_{19}+399x_{20}+484x_{21}+367x_{22}+204x_{23}+289x_{24}+283x_{25}\le2894;\;x_t\in\{0,1\}\;\forall t=0,\dots,25;\;y_a\in\{0,1\}\;\forall a=0,\dots,34\end{align*}","import gurobipy as gp
from gurobipy import GRB

# Coefficients for y variables
y_coeffs = [3215,2395,4466,2520,2192,4625,4796,2973,2034,2754,2143,2473,3099,4136,2154,3411,3230,2155,4907,2665,4708,4494,2381,3077,2699,3320,4931,4645,2346,4393,4051,4507,4610,3412,3059]

# Coefficients for x variables
x_coeffs = [411,294,376,447,414,498,437,272,381,323,356,200,297,428,427,484,494,436,218,428,399,484,367,204,289,283]

# Create model
m = gp.Model(""Optimization_Model"")

# Decision variables
x = m.addVars(len(x_coeffs), vtype=GRB.BINARY, name=""x"")
y = m.addVars(len(y_coeffs), vtype=GRB.BINARY, name=""y"")

# Objective function
m.setObjective(gp.quicksum(y_coeffs[a]*y[a] for a in range(len(y_coeffs))), GRB.MAXIMIZE)

# Resource constraint
m.addConstr(gp.quicksum(x_coeffs[t]*x[t] for t in range(len(x_coeffs))) <= 2894, name=""resource"")

# y_a <= sum_{t in T_a} x_t  (using all x_t for each a as a placeholder)
for a in range(len(y_coeffs)):
    m.addConstr(y[a] <= gp.quicksum(x[t] for t in range(len(x_coeffs))), name=f""y_le_sum_{a}"")

# Optimize
m.optimize()",118976,118976,1,,,,,,,,
"You are responsible for managing the distribution of resources across a network of nine cities. Each city has a specific supply or demand for resources, and your goal is to minimize the total transportation cost while ensuring that all cities receive the resources they need. The transportation costs vary depending on the route taken between cities, and there are capacity limits on how much can be transported between any two cities.

City 0 has a net demand of 63 units of resources. City 1 has a net demand of 2 units of resources. City 2 has a net demand of 5 units of resources. City 3 has a net demand of 16 units of resources. City 4 has a net supply of 13 units of resources. City 5 has a net supply of 13 units of resources. City 6 has a net supply of 26 units of resources. City 7 has a net supply of 19 units of resources. City 8 has a net supply of 15 units of resources.

The cost of transporting resources from City 0 to City 1 is 6, with a capacity of 48. From City 0 to City 2, the cost is 7, with a capacity of 37. From City 0 to City 3, the cost is 10, with a capacity of 57. From City 0 to City 4, the cost is 9, with a capacity of 41. From City 0 to City 5, the cost is 9, with a capacity of 40. From City 0 to City 6, the cost is 10, with a capacity of 48. From City 0 to City 7, the cost is 9, with a capacity of 38. From City 0 to City 8, the cost is 8, with a capacity of 44.

The cost of transporting resources from City 1 to City 0 is 10, with a capacity of 44. From City 1 to City 2, the cost is 8, with a capacity of 58. From City 1 to City 3, the cost is 9, with a capacity of 57. From City 1 to City 4, the cost is 6, with a capacity of 34. From City 1 to City 5, the cost is 8, with a capacity of 49. From City 1 to City 6, the cost is 8, with a capacity of 57. From City 1 to City 7, the cost is 8, with a capacity of 46. From City 1 to City 8, the cost is 6, with a capacity of 59.

The cost of transporting resources from City 2 to City 0 is 8, with a capacity of 31. From City 2 to City 1, the cost is 8, with a capacity of 43. From City 2 to City 3, the cost is 7, with a capacity of 43. From City 2 to City 4, the cost is 6, with a capacity of 46. From City 2 to City 5, the cost is 6, with a capacity of 45. From City 2 to City 6, the cost is 8, with a capacity of 41. From City 2 to City 7, the cost is 8, with a capacity of 59. From City 2 to City 8, the cost is 10, with a capacity of 40.

The cost of transporting resources from City 3 to City 0 is 9, with a capacity of 44. From City 3 to City 1, the cost is 10, with a capacity of 46. From City 3 to City 2, the cost is 10, with a capacity of 32. From City 3 to City 4, the cost is 7, with a capacity of 56. From City 3 to City 5, the cost is 9, with a capacity of 42. From City 3 to City 6, the cost is 6, with a capacity of 52. From City 3 to City 7, the cost is 8, with a capacity of 51. From City 3 to City 8, the cost is 7, with a capacity of 39.

The cost of transporting resources from City 4 to City 0 is 9, with a capacity of 49. From City 4 to City 1, the cost is 10, with a capacity of 31. From City 4 to City 2, the cost is 7, with a capacity of 47. From City 4 to City 3, the cost is 7, with a capacity of 60. From City 4 to City 5, the cost is 10, with a capacity of 46. From City 4 to City 6, the cost is 7, with a capacity of 32. From City 4 to City 7, the cost is 8, with a capacity of 42. From City 4 to City 8, the cost is 7, with a capacity of 45.

The cost of transporting resources from City 5 to City 0 is 8, with a capacity of 31. From City 5 to City 1, the cost is 8, with a capacity of 51. From City 5 to City 2, the cost is 10, with a capacity of 53. From City 5 to City 3, the cost is 7, with a capacity of 47. From City 5 to City 4, the cost is 8, with a capacity of 36. From City 5 to City 6, the cost is 6, with a capacity of 30. From City 5 to City 7, the cost is 9, with a capacity of 57. From City 5 to City 8, the cost is 9, with a capacity of 40.

The cost of transporting resources from City 6 to City 0 is 10, with a capacity of 57. From City 6 to City 1, the cost is 8, with a capacity of 36. From City 6 to City 2, the cost is 10, with a capacity of 56. From City 6 to City 3, the cost is 9, with a capacity of 51. From City 6 to City 4, the cost is 7, with a capacity of 48. From City 6 to City 5, the cost is 7, with a capacity of 56. From City 6 to City 7, the cost is 7, with a capacity of 60. From City 6 to City 8, the cost is 6, with a capacity of 56.

The cost of transporting resources from City 7 to City 0 is 10, with a capacity of 37. From City 7 to City 1, the cost is 10, with a capacity of 36. From City 7 to City 2, the cost is 8, with a capacity of 48. From City 7 to City 3, the cost is 7, with a capacity of 60. From City 7 to City 4, the cost is 9, with a capacity of 38. From City 7 to City 5, the cost is 7, with a capacity of 43. From City 7 to City 6, the cost is 9, with a capacity of 60. From City 7 to City 8, the cost is 9, with a capacity of 53.

The cost of transporting resources from City 8 to City 0 is 7, with a capacity of 54. From City 8 to City 1, the cost is 8, with a capacity of 42. From City 8 to City 2, the cost is 8, with a capacity of 36. From City 8 to City 3, the cost is 10, with a capacity of 46. From City 8 to City 4, the cost is 8, with a capacity of 58. From City 8 to City 5, the cost is 7, with a capacity of 54. From City 8 to City 6, the cost is 10, with a capacity of 56. From City 8 to City 7, the cost is 10, with a capacity of 34.

Your task is to determine the optimal amount of resources to transport between each pair of cities to meet all demands and supplies while minimizing the total transportation cost. The transportation must respect the capacity limits on each route, and the amount of resources transported cannot be negative. For each city, the total amount of resources sent out plus its supply must equal the total amount received plus its demand.","\begin{align*}
\text{minimize}\quad & 6x_{0,1}+7x_{0,2}+10x_{0,3}+9x_{0,4}+9x_{0,5}+10x_{0,6}+9x_{0,7}+8x_{0,8}\\
& +10x_{1,0}+8x_{1,2}+9x_{1,3}+6x_{1,4}+8x_{1,5}+8x_{1,6}+8x_{1,7}+6x_{1,8}\\
& +8x_{2,0}+8x_{2,1}+7x_{2,3}+6x_{2,4}+6x_{2,5}+8x_{2,6}+8x_{2,7}+10x_{2,8}\\
& +9x_{3,0}+10x_{3,1}+10x_{3,2}+7x_{3,4}+9x_{3,5}+6x_{3,6}+8x_{3,7}+7x_{3,8}\\
& +9x_{4,0}+10x_{4,1}+7x_{4,2}+7x_{4,3}+10x_{4,5}+7x_{4,6}+8x_{4,7}+7x_{4,8}\\
& +8x_{5,0}+8x_{5,1}+10x_{5,2}+7x_{5,3}+8x_{5,4}+6x_{5,6}+9x_{5,7}+9x_{5,8}\\
& +10x_{6,0}+8x_{6,1}+10x_{6,2}+9x_{6,3}+7x_{6,4}+7x_{6,5}+7x_{6,7}+6x_{6,8}\\
& +10x_{7,0}+10x_{7,1}+8x_{7,2}+7x_{7,3}+9x_{7,4}+7x_{7,5}+9x_{7,6}+9x_{7,8}\\
& +7x_{8,0}+8x_{8,1}+8x_{8,2}+10x_{8,3}+8x_{8,4}+7x_{8,5}+10x_{8,6}+10x_{8,7}\\
\text{subject to}\quad & \sum_{j\neq 0}x_{0j}-\sum_{j\neq 0}x_{j0}=-63\\
& \sum_{j\neq 1}x_{1j}-\sum_{j\neq 1}x_{j1}=-2\\
& \sum_{j\neq 2}x_{2j}-\sum_{j\neq 2}x_{j2}=-5\\
& \sum_{j\neq 3}x_{3j}-\sum_{j\neq 3}x_{j3}=-16\\
& \sum_{j\neq 4}x_{4j}-\sum_{j\neq 4}x_{j4}=13\\
& \sum_{j\neq 5}x_{5j}-\sum_{j\neq 5}x_{j5}=13\\
& \sum_{j\neq 6}x_{6j}-\sum_{j\neq 6}x_{j6}=26\\
& \sum_{j\neq 7}x_{7j}-\sum_{j\neq 7}x_{j7}=19\\
& \sum_{j\neq 8}x_{8j}-\sum_{j\neq 8}x_{j8}=15\\
& x_{ij}\le 32\quad \forall\,i,j\in\{0,\dots,8\},\,i\neq j\\
& x_{ij}\ge 0\quad \forall\,i,j\in\{0,\dots,8\},\,i\neq j\\
& x_{ij}\in\mathbb{R}_+\quad \forall\,i,j\in\{0,\dots,8\},\,i\neq j
\end{align*}","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Flow_Optimization"")

# Decision variables x[i,j] for i != j
x = m.addVars(9, 9, vtype=GRB.CONTINUOUS, lb=0, ub=32, name=""x"")

# Objective coefficients
coeff = {
    (0,1):6, (0,2):7, (0,3):10, (0,4):9, (0,5):9, (0,6):10, (0,7):9, (0,8):8,
    (1,0):10, (1,2):8, (1,3):9, (1,4):6, (1,5):8, (1,6):8, (1,7):8, (1,8):6,
    (2,0):8, (2,1):8, (2,3):7, (2,4):6, (2,5):6, (2,6):8, (2,7):8, (2,8):10,
    (3,0):9, (3,1):10, (3,2):10, (3,4):7, (3,5):9, (3,6):6, (3,7):8, (3,8):7,
    (4,0):9, (4,1):10, (4,2):7, (4,3):7, (4,5):10, (4,6):7, (4,7):8, (4,8):7,
    (5,0):8, (5,1):8, (5,2):10, (5,3):7, (5,4):8, (5,6):6, (5,7):9, (5,8):9,
    (6,0):10, (6,1):8, (6,2):10, (6,3):9, (6,4):7, (6,5):7, (6,7):7, (6,8):6,
    (7,0):10, (7,1):10, (7,2):8, (7,3):7, (7,4):9, (7,5):7, (7,6):9, (7,8):9,
    (8,0):7, (8,1):8, (8,2):8, (8,3):10, (8,4):8, (8,5):7, (8,6):10, (8,7):10
}

# Set objective
m.setObjective(gp.quicksum(coeff[i,j]*x[i,j] for i in range(9) for j in range(9) if i!=j), GRB.MINIMIZE)

# Flow balance constraints
balance = {-63, -2, -5, -16, 13, 13, 26, 19, 15}
for i in range(9):
    m.addConstr(
        gp.quicksum(x[i,j] for j in range(9) if i!=j) -
        gp.quicksum(x[j,i] for j in range(9) if i!=j) == balance[i],
        name=f""balance_{i}""
    )

# Optimize
m.optimize()",,714,0,,,,,,,,
"Job Shop Scheduling in a Manufacturing Facility

You are managing a manufacturing facility that produces custom parts for various clients. The facility has multiple machines, each capable of performing specific operations. There are seven jobs (Job 0 to Job 6) that need to be processed, and each job consists of a sequence of operations that must be performed in a specific order. Each operation is assigned to a particular machine, and no two operations can be processed on the same machine simultaneously.

#### Objective:
Your goal is to minimize the **makespan**, which is the total time required to complete all jobs. This ensures that all jobs are finished as quickly as possible, allowing the facility to meet client deadlines and optimize resource utilization.

#### Decisions to Be Made:
1. **Start Times**: Determine the start time for each operation of every job.
2. **Operation Order**: Decide the order in which operations are processed on each machine, ensuring no overlaps.

#### Constraints:
1. **Precedence Constraints**:
   - Each operation in a job must start only after the previous operation in the same job has been completed. For example:
     - Operation 1 of Job 0 must start at least 1 time unit after Operation 0 of Job 0 has finished.
     - Operation 1 of Job 1 must start at least 1 time unit after Operation 0 of Job 1 has finished.
     - This pattern applies to all jobs and their respective operations.

2. **Machine Capacity Constraints**:
   - No two operations assigned to the same machine can overlap in time. For example:
     - If Operation 1 of Job 3 and Operation 0 of Job 4 are assigned to the same machine, they must be scheduled such that one starts only after the other has finished. A binary decision variable determines the order of these operations.
     - Similar constraints apply to all pairs of operations sharing the same machine, such as:
       - Operation 1 of Job 3 and Operation 1 of Job 4.
       - Operation 1 of Job 3 and Operation 1 of Job 6.
       - Operation 0 of Job 4 and Operation 1 of Job 4.
       - Operation 0 of Job 4 and Operation 1 of Job 6.
       - Operation 1 of Job 4 and Operation 1 of Job 6.
       - Operation 1 of Job 0 and Operation 0 of Job 1.
       - Operation 1 of Job 0 and Operation 0 of Job 2.
       - Operation 0 of Job 1 and Operation 0 of Job 2.
       - Operation 0 of Job 0 and Operation 1 of Job 1.
       - Operation 0 of Job 0 and Operation 1 of Job 2.
       - Operation 0 of Job 0 and Operation 0 of Job 3.
       - Operation 0 of Job 0 and Operation 1 of Job 5.
       - Operation 0 of Job 0 and Operation 0 of Job 6.
       - Operation 1 of Job 1 and Operation 1 of Job 2.
       - Operation 1 of Job 1 and Operation 0 of Job 3.
       - Operation 1 of Job 1 and Operation 1 of Job 5.
       - Operation 1 of Job 1 and Operation 0 of Job 6.
       - Operation 1 of Job 2 and Operation 0 of Job 3.
       - Operation 1 of Job 2 and Operation 1 of Job 5.
       - Operation 1 of Job 2 and Operation 0 of Job 6.
       - Operation 0 of Job 3 and Operation 1 of Job 5.
       - Operation 0 of Job 3 and Operation 0 of Job 6.
       - Operation 1 of Job 5 and Operation 0 of Job 6.

3. **Makespan Definition**:
   - The makespan must be at least as large as the completion time of every operation. For example:
     - The makespan must be at least 1 time unit after the completion of Operation 0 of Job 0.
     - The makespan must be at least 1 time unit after the completion of Operation 1 of Job 0.
     - This applies to all operations across all jobs.

4. **Non-Negativity**:
   - All start times must be non-negative, meaning no operation can start before time zero.

5. **Binary Variables**:
   - Binary variables are used to determine the order of operations on shared machines. For example:
     - A binary variable decides whether Operation 1 of Job 3 is processed before or after Operation 0 of Job 4 on the same machine.
     - Similar binary variables are used for all relevant pairs of operations sharing the same machine.

#### Numerical Parameters:
- The processing time for each operation is implicitly defined by the constraints, with a minimum required gap of 1 time unit between consecutive operations of the same job.
- The large constant \( N = 100,000 \) is used in the machine capacity constraints to ensure that the binary variables correctly enforce the order of operations.

#### Summary:
Your task is to schedule the start times of all operations across all jobs and machines in such a way that the total completion time (makespan) is minimized. You must ensure that all precedence and machine capacity constraints are satisfied, and that the makespan reflects the latest completion time of any operation. The use of binary variables is critical to determining the correct order of operations on shared machines.","\[
\begin{aligned}
\min\quad & C\\
\text{s.t.}\quad & S_{i,1}\;\ge\;S_{i,0}+1 && \forall\,i=0,\dots,6\\[4pt]
& S_{3,1}+1\;\le\;S_{4,0}+N(1-y_{3,1,4,0})\\
& S_{4,0}+1\;\le\;S_{3,1}+Ny_{3,1,4,0}\\[2pt]
& S_{3,1}+1\;\le\;S_{4,1}+N(1-y_{3,1,4,1})\\
& S_{4,1}+1\;\le\;S_{3,1}+Ny_{3,1,4,1}\\[2pt]
& S_{3,1}+1\;\le\;S_{6,1}+N(1-y_{3,1,6,1})\\
& S_{6,1}+1\;\le\;S_{3,1}+Ny_{3,1,6,1}\\[2pt]
& S_{4,0}+1\;\le\;S_{4,1}+N(1-y_{4,0,4,1})\\
& S_{4,1}+1\;\le\;S_{4,0}+Ny_{4,0,4,1}\\[2pt]
& S_{4,0}+1\;\le\;S_{6,1}+N(1-y_{4,0,6,1})\\
& S_{6,1}+1\;\le\;S_{4,0}+Ny_{4,0,6,1}\\[2pt]
& S_{4,1}+1\;\le\;S_{6,1}+N(1-y_{4,1,6,1})\\
& S_{6,1}+1\;\le\;S_{4,1}+Ny_{4,1,6,1}\\[2pt]
& S_{0,1}+1\;\le\;S_{1,0}+N(1-y_{0,1,1,0})\\
& S_{1,0}+1\;\le\;S_{0,1}+Ny_{0,1,1,0}\\[2pt]
& S_{0,1}+1\;\le\;S_{2,0}+N(1-y_{0,1,2,0})\\
& S_{2,0}+1\;\le\;S_{0,1}+Ny_{0,1,2,0}\\[2pt]
& S_{1,0}+1\;\le\;S_{2,0}+N(1-y_{1,0,2,0})\\
& S_{2,0}+1\;\le\;S_{1,0}+Ny_{1,0,2,0}\\[2pt]
& S_{0,0}+1\;\le\;S_{1,1}+N(1-y_{0,0,1,1})\\
& S_{1,1}+1\;\le\;S_{0,0}+Ny_{0,0,1,1}\\[2pt]
& S_{0,0}+1\;\le\;S_{2,1}+N(1-y_{0,0,2,1})\\
& S_{2,1}+1\;\le\;S_{0,0}+Ny_{0,0,2,1}\\[2pt]
& S_{0,0}+1\;\le\;S_{3,0}+N(1-y_{0,0,3,0})\\
& S_{3,0}+1\;\le\;S_{0,0}+Ny_{0,0,3,0}\\[2pt]
& S_{0,0}+1\;\le\;S_{5,1}+N(1-y_{0,0,5,1})\\
& S_{5,1}+1\;\le\;S_{0,0}+Ny_{0,0,5,1}\\[2pt]
& S_{0,0}+1\;\le\;S_{6,0}+N(1-y_{0,0,6,0})\\
& S_{6,0}+1\;\le\;S_{0,0}+Ny_{0,0,6,0}\\[2pt]
& S_{1,1}+1\;\le\;S_{2,1}+N(1-y_{1,1,2,1})\\
& S_{2,1}+1\;\le\;S_{1,1}+Ny_{1,1,2,1}\\[2pt]
& S_{1,1}+1\;\le\;S_{3,0}+N(1-y_{1,1,3,0})\\
& S_{3,0}+1\;\le\;S_{1,1}+Ny_{1,1,3,0}\\[2pt]
& S_{1,1}+1\;\le\;S_{5,1}+N(1-y_{1,1,5,1})\\
& S_{5,1}+1\;\le\;S_{1,1}+Ny_{1,1,5,1}\\[2pt]
& S_{1,1}+1\;\le\;S_{6,0}+N(1-y_{1,1,6,0})\\
& S_{6,0}+1\;\le\;S_{1,1}+Ny_{1,1,6,0}\\[2pt]
& S_{2,1}+1\;\le\;S_{3,0}+N(1-y_{2,1,3,0})\\
& S_{3,0}+1\;\le\;S_{2,1}+Ny_{2,1,3,0}\\[2pt]
& S_{2,1}+1\;\le\;S_{5,1}+N(1-y_{2,1,5,1})\\
& S_{5,1}+1\;\le\;S_{2,1}+Ny_{2,1,5,1}\\[2pt]
& S_{2,1}+1\;\le\;S_{6,0}+N(1-y_{2,1,6,0})\\
& S_{6,0}+1\;\le\;S_{2,1}+Ny_{2,1,6,0}\\[2pt]
& S_{3,0}+1\;\le\;S_{5,1}+N(1-y_{3,0,5,1})\\
& S_{5,1}+1\;\le\;S_{3,0}+Ny_{3,0,5,1}\\[2pt]
& S_{3,0}+1\;\le\;S_{6,0}+N(1-y_{3,0,6,0})\\
& S_{6,0}+1\;\le\;S_{3,0}+Ny_{3,0,6,0}\\[2pt]
& S_{5,1}+1\;\le\;S_{6,0}+N(1-y_{5,1,6,0})\\
& S_{6,0}+1\;\le\;S_{5,1}+Ny_{5,1,6,0}\\[4pt]
& C\;\ge\;S_{i,j}+1 && \forall\,i=0,\dots,6,\;j=0,1\\[2pt]
& S_{i,j}\;\ge\;0 && \forall\,i,j\\[2pt]
& S_{i,j}\in\mathbb{R}_{+}\quad\forall\,i,j\\
& y_{i,j,k,l}\in\{0,1\}\quad\forall\text{listed pairs}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Sequencing"")

# Large constant for big__ constraints
N = 1000

# Decision variables S[i,j] (real, >=0)
S = {}
for i in range(7):
    for j in (0, 1):
        S[i, j] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=f""S_{i}_{j}"")

# Decision variable C (real, >=0)
C = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""C"")

# Binary variables y[i,j,k,l] for ordering constraints
pairs = [
    (3, 1, 4, 0), (3, 1, 4, 1), (3, 1, 6, 1),
    (4, 0, 4, 1), (4, 0, 6, 1), (4, 1, 6, 1),
    (0, 1, 1, 0), (0, 1, 2, 0), (1, 0, 2, 0),
    (0, 0, 1, 1), (0, 0, 2, 1), (0, 0, 3, 0),
    (0, 0, 5, 1), (0, 0, 6, 0),
    (1, 1, 2, 1), (1, 1, 3, 0), (1, 1, 5, 1), (1, 1, 6, 0),
    (2, 1, 3, 0), (2, 1, 5, 1), (2, 1, 6, 0),
    (3, 0, 5, 1), (3, 0, 6, 0),
    (5, 1, 6, 0)
]
y = {}
for (i, j, k, l) in pairs:
    y[(i, j, k, l)] = m.addVar(vtype=GRB.BINARY, name=f""y_{i}_{j}_{k}_{l}"")

# Objective: minimize C
m.setObjective(C, GRB.MINIMIZE)

# Constraints
# 1. S[i,1] >= S[i,0] + 1  for all i
for i in range(7):
    m.addConstr(S[i, 1] >= S[i, 0] + 1, name=f""seq_{i}"")

# 2. Pairwise ordering constraints using big__
def add_order(i, j, k, l):
    yi = y[(i, j, k, l)]
    m.addConstr(S[i, j] + 1 <= S[k, l] + N * (1 - yi), name=f""order_{i}_{j}_{k}_{l}_1"")
    m.addConstr(S[k, l] + 1 <= S[i, j] + N * yi, name=f""order_{i}_{j}_{k}_{l}_2"")

for (i, j, k, l) in pairs:
    add_order(i, j, k, l)

# 3. C >= S[i,j] + 1  for all i,j
for i in range(7):
    for j in (0, 1):
        m.addConstr(C >= S[i, j] + 1, name=f""C_{i}_{j}"")

# Solve the model
m.optimize()

# Output results
if m.status == GRB.OPTIMAL:
    print(""Optimal C:"", C.X)
    for i in range(7):
        for j in (0, 1):
            print(f""S_{i}_{j} = {S[i, j].X}"")
    for (i, j, k, l), var in y.items():
        print(f""{var.VarName} = {var.X}"")",6,3,0,,,,,,,,
"The problem involves scheduling operations for five jobs (Job 0 through Job 4) in a manufacturing facility. Each job consists of two operations that must be performed in sequence, with the second operation starting only after the first operation is completed. All operations have a processing time of 1 unit. Operations from different jobs may share the same machine, and each machine can handle only one operation at a time. The goal is to minimize the total time required to complete all jobs, known as the makespan.

The start time of each operation must be determined, ensuring that the sequence of operations within each job is respected and that no two operations on the same machine overlap. Binary variables are used to determine the order of operations on shared machines. For example, if Operation 0 of Job 0 and Operation 0 of Job 2 are on the same machine, a binary variable indicates whether Operation 0 of Job 0 precedes Operation 0 of Job 2 or vice versa. A large constant (100,000) is used in the constraints to enforce the correct ordering of operations on shared machines.

The makespan must be at least as large as the completion time of every operation. For example, if Operation 0 of Job 0 finishes at time 2, the makespan must be at least 2. The constraints include precedence constraints within jobs, ensuring that the start time of the second operation is at least 1 unit after the completion of the first operation. Machine capacity constraints ensure that two operations assigned to the same machine do not overlap in time. The solution will provide a schedule that ensures all jobs are completed as quickly as possible, respecting the constraints of machine availability and operation precedence.","\[
\begin{aligned}
\text{minimize}\quad & C_{\max} \\[4pt]
\text{subject to}\quad 
& s_{j,2}\;\ge\;s_{j,1}+1, && \forall j\in\{0,\dots,4\} \\[4pt]
& s_{i_2,k_2}\;\ge\;s_{i_1,k_1}+1-M\bigl(1-y_{i_1k_1,i_2k_2}\bigr), && \forall (i_1,k_1),(i_2,k_2)\in\mathcal{P} \\[4pt]
& s_{i_1,k_1}\;\ge\;s_{i_2,k_2}+1-M\,y_{i_1k_1,i_2k_2}, && \forall (i_1,k_1),(i_2,k_2)\in\mathcal{P} \\[4pt]
& C_{\max}\;\ge\;s_{j,k}+1, && \forall j\in\{0,\dots,4\},\;k\in\{1,2\} \\[4pt]
& s_{j,k}\;\ge\;0, && \forall j,k \\[4pt]
& y_{i_1k_1,i_2k_2}\in\{0,1\}, && \forall (i_1,k_1),(i_2,k_2)\in\mathcal{P} \\[4pt]
& C_{\max}\;\ge\;0
\end{aligned}
\]

\[
\text{where } M=100\,000,\quad 
s_{j,k}\in\mathbb{R}_{+},\quad 
C_{\max}\in\mathbb{R}_{+},\quad 
y_{i_1k_1,i_2k_2}\in\{0,1\}.
\]","import gurobipy as gp
from gurobipy import GRB

# Parameters
M = 100000

# Indices
jobs = range(5)          # j = 0..4
slots = [1, 2]           # k = 1,2
P = [(j, k) for j in jobs for k in slots]  # set of (i,k) pairs

# Create model
m = gp.Model(""Scheduling_Problem"")

# Decision variables
s = m.addVars(jobs, slots, lb=0, name=""s"")          # s[j,k] >= 0
Cmax = m.addVar(lb=0, name=""Cmax"")                  # Cmax >= 0
y = m.addVars(P, P, vtype=GRB.BINARY, name=""y"")     # y[(i1,k1),(i2,k2)] binary

# Objective: minimize Cmax
m.setObjective(Cmax, GRB.MINIMIZE)

# Constraints

# 1. s[j,2] >= s[j,1] + 1 for all j
for j in jobs:
    m.addConstr(s[j, 2] >= s[j, 1] + 1, name=f""slot_order_{j}"")

# 2. Precedence constraints with big M
for (i1, k1) in P:
    for (i2, k2) in P:
        if (i1, k1) == (i2, k2):
            continue
        # s[i2,k2] >= s[i1,k1] + 1 - M*(1 - y[(i1,k1),(i2,k2)])
        m.addConstr(
            s[i2, k2] >= s[i1, k1] + 1 - M * (1 - y[(i1, k1), (i2, k2)]),
            name=f""precedence1_{i1}_{k1}_{i2}_{k2}""
        )
        # s[i1,k1] >= s[i2,k2] + 1 - M*y[(i1,k1),(i2,k2)]
        m.addConstr(
            s[i1, k1] >= s[i2, k2] + 1 - M * y[(i1, k1), (i2, k2)],
            name=f""precedence2_{i1}_{k1}_{i2}_{k2}""
        )

# 3. Cmax >= s[j,k] + 1 for all j,k
for j in jobs:
    for k in slots:
        m.addConstr(Cmax >= s[j, k] + 1, name=f""Cmax_constraint_{j}_{k}"")

# 4. Non-negativity of s and Cmax already handled by lb=0

# 5. y binary already defined

# 6. Cmax >= 0 already handled by lb=0

# Optimize
m.optimize()
",,4,0,,,,,,,,
"There are 5 jobs labeled as Job 0, Job 1, Job 2, Job 3, and Job 4, and 4 machines labeled as Machine 0, Machine 1, Machine 2, and Machine 3. Each job must be assigned to one of 5 schedule positions (Position 0 to Position 4) on each machine. The goal is to minimize the total completion time of all jobs, which includes the start time of the job in the last schedule position (Position 4) on the last machine (Machine 3) and the processing time of that job. Each job has specific processing times on each machine: Job 0 takes 9 units on Machine 0, 7 units on Machine 1, 5 units on Machine 2, and 6 units on Machine 3; Job 1 takes 7 units on Machine 0, 10 units on Machine 1, 10 units on Machine 2, and 8 units on Machine 3; Job 2 takes 6 units on Machine 0, 9 units on Machine 1, 9 units on Machine 2, and 8 units on Machine 3; Job 3 takes 10 units on Machine 0, 10 units on Machine 1, 7 units on Machine 2, and 8 units on Machine 3; Job 4 takes 6 units on Machine 0, 10 units on Machine 1, 5 units on Machine 2, and 10 units on Machine 3. Each schedule position on each machine must be assigned exactly one job, and each job must be assigned to exactly one schedule position across all machines. The start time of a job on the next machine must be at least equal to its completion time on the current machine. Additionally, the start time of a job in the next schedule position must be at least equal to the completion time of the job in the current position on the same machine. The processing times for the jobs in the last schedule position (Position 4) are: Job 0 takes 6 units, Job 1 takes 8 units, Job 2 takes 8 units, Job 3 takes 8 units, and Job 4 takes 10 units. The start time of the job in Position 4 on Machine 3 is a critical factor in the objective function. The decision variables include assigning each job to a specific schedule position on each machine and determining the start times of each job on each machine to ensure all constraints are satisfied. The objective is to minimize the total completion time of all jobs while adhering to the constraints of the manufacturing process.","\[
\begin{aligned}
\text{minimize}\quad & C_{\max} \\[4pt]
\text{subject to}\quad
& \sum_{j\in J} x_{j,m,p}=1 && \forall m\in M,\; p\in P \qquad\text{(one job per slot)}\\
& \sum_{p\in P} x_{j,m,p}=1 && \forall j\in J,\; m\in M \qquad\text{(each job on each machine)}\\
& s_{j,m}\ge 0 && \forall j\in J,\; m\in M \qquad\text{(non__egative start)}\\
& s_{j,m+1}\ge s_{j,m}+p_{j,m} && \forall j\in J,\; m=0,1,2 \qquad\text{(job precedence)}\\
& s_{j,m}+p_{j,m}\le s_{k,m}+M\bigl(2-x_{j,m,p}-x_{k,m,q}\bigr) && \forall j,k\in J,\; m\in M,\; p,q\in P,\; p<q\\
& \qquad\qquad\text{(slot \(p\) finishes before slot \(q\) starts)}\\
& C_{\max}\ge s_{j,3}+p_{j,3} && \forall j\in J \qquad\text{(makespan lower bound)}\\
& C_{\max}\le s_{j,3}+p_{j,3}+M\bigl(1-x_{j,3,4}\bigr) && \forall j\in J \qquad\text{(makespan equals last job)}\\[4pt]
& x_{j,m,p}\in\{0,1\} && \forall j\in J,\; m\in M,\; p\in P \\
& s_{j,m}\in\mathbb{R}_{+} && \forall j\in J,\; m\in M \\
& C_{\max}\in\mathbb{R}_{+}
\end{aligned}
\]

\[
\text{Sets:}\quad J=\{0,1,2,3,4\},\; M=\{0,1,2,3\},\; P=\{0,1,2,3,4\}
\]

\[
\text{Parameters:}\quad
p_{j,m}=
\begin{array}{c|cccc}
 & m=0 & m=1 & m=2 & m=3\\ \hline
j=0 & 9 & 7 & 5 & 6\\
j=1 & 7 &10 &10 & 8\\
j=2 & 6 & 9 & 9 & 8\\
j=3 &10 &10 & 7 & 8\\
j=4 & 6 &10 & 5 &10
\end{array}
\]

\[
M=1000 \quad\text{(big__(M\) constant)}
\]","import gurobipy as gp
from gurobipy import GRB

# Sets
J = range(5)   # jobs
M = range(4)   # machines
P = range(5)   # slots

# Processing times p[j,m]
p = {
    (0,0):9, (0,1):7, (0,2):5, (0,3):6,
    (1,0):7, (1,1):10, (1,2):10, (1,3):8,
    (2,0):6, (2,1):9, (2,2):9, (2,3):8,
    (3,0):10, (3,1):10, (3,2):7, (3,3):8,
    (4,0):6, (4,1):10, (4,2):5, (4,3):10
}

BigM = 1000

# Create model
m = gp.Model(""Job_Scheduling"")

# Decision variables
x = m.addVars(J, M, P, vtype=GRB.BINARY, name=""x"")
s = m.addVars(J, M, vtype=GRB.CONTINUOUS, lb=0, name=""s"")
Cmax = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""Cmax"")

# Objective: minimize makespan
m.setObjective(Cmax, GRB.MINIMIZE)

# One job per slot on each machine
for m_idx in M:
    for p_idx in P:
        m.addConstr(gp.quicksum(x[j,m_idx,p_idx] for j in J) == 1,
                    name=f""slot_assign_{m_idx}_{p_idx}"")

# Each job on each machine exactly once
for j in J:
    for m_idx in M:
        m.addConstr(gp.quicksum(x[j,m_idx,p_idx] for p_idx in P) == 1,
                    name=f""job_machine_{j}_{m_idx}"")

# Job precedence on each machine
for j in J:
    for m_idx in [0,1,2]:
        m.addConstr(s[j,m_idx+1] >= s[j,m_idx] + p[(j,m_idx)],
                    name=f""precedence_{j}_{m_idx}"")

# Slot ordering constraints
for m_idx in M:
    for p_idx in P:
        for q_idx in P:
            if p_idx < q_idx:
                for j in J:
                    for k in J:
                        if j != k:
                            m.addConstr(
                                s[j,m_idx] + p[(j,m_idx)] <=
                                s[k,m_idx] + BigM*(2 - x[j,m_idx,p_idx] - x[k,m_idx,q_idx]),
                                name=f""slot_order_{m_idx}_{p_idx}_{q_idx}_{j}_{k}""
                            )

# Makespan lower bound
for j in J:
    m.addConstr(Cmax >= s[j,3] + p[(j,3)],
                name=f""makespan_lower_{j}"")

# Makespan upper bound (last job on machine 3)
for j in J:
    m.addConstr(Cmax <= s[j,3] + p[(j,3)] + BigM*(1 - x[j,3,4]),
                name=f""makespan_upper_{j}"")

# Optimize
m.optimize()
```",67,67,1,,,,,,,,
"There are 7 jobs, each consisting of 2 operations that must be processed in sequence. Each operation takes exactly 1 unit of time to complete. The operations are assigned to specific machines, and no two operations on the same machine can overlap in time. For each pair of operations assigned to the same machine, a binary decision variable determines the order in which they are processed. If one operation is scheduled before the other, the corresponding binary variable is set to 1; otherwise, it is set to 0. A large constant value of 100,000 is used to enforce the order of operations on shared machines. The start time of each operation must be non-negative, and the start time of the second operation in each job must be at least 1 unit of time after the start time of the first operation in the same job. The total completion time, or makespan, is defined as the maximum completion time across all operations. The objective is to minimize the makespan by determining the optimal start times for all operations and the order of operations on shared machines, while ensuring that all constraints are satisfied.","\[
\begin{aligned}
\min \quad & C \\[4pt]
\text{s.t.}\quad 
& s_{i1} + 1 \;\le\; s_{i2} && \forall\, i\in I \\[2pt]
& s_{i1} \;\ge\; 0,\; s_{i2} \;\ge\; 0 && \forall\, i\in I \\[2pt]
& s_{i1} + 1 \;\le\; C,\; s_{i2} + 1 \;\le\; C && \forall\, i\in I \\[4pt]
& s_{o} + 1 \;\le\; s_{p} + M\,(1-y_{op}) && \forall\, (o,p)\in P \\[2pt]
& s_{p} + 1 \;\le\; s_{o} + M\,y_{op} && \forall\, (o,p)\in P \\[4pt]
& y_{op}\;\in\;\{0,1\} && \forall\, (o,p)\in P \\[4pt]
& s_{i1},\,s_{i2},\,C \;\in\; \mathbb{R}_+ && \forall\, i\in I
\end{aligned}
\]

where \(I=\{1,\dots,7\}\) indexes the jobs, \(P\) is the set of ordered pairs of operations that share the same machine, and \(M=100\,000\).","import gurobipy as gp
from gurobipy import GRB

I = range(1, 8)  # jobs 1..7
P = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)]  # example pairs sharing a machine
M = 100000

m = gp.Model(""Job_Scheduling"")

s1 = m.addVars(I, lb=0, name=""s1"")   # s_{i1}
s2 = m.addVars(I, lb=0, name=""s2"")   # s_{i2}
C = m.addVar(lb=0, name=""C"")

y = m.addVars(P, vtype=GRB.BINARY, name=""y"")

m.setObjective(C, GRB.MINIMIZE)

for i in I:
    m.addConstr(s1[i] + 1 <= s2[i], name=f""order_{i}"")
    m.addConstr(s1[i] + 1 <= C, name=f""C1_{i}"")
    m.addConstr(s2[i] + 1 <= C, name=f""C2_{i}"")

for (o, p) in P:
    m.addConstr(s1[o] + 1 <= s1[p] + M * (1 - y[o, p]), name=f""pair1_{o}_{p}"")
    m.addConstr(s1[p] + 1 <= s1[o] + M * y[o, p], name=f""pair2_{o}_{p}"")

m.optimize()",3,3,1,,,,,,,,
"Select two facilities from five potential locations (Node 0, Node 1, Node 2, Node 3, and Node 4) to maximize the minimum distance between any two selected facilities. Each location can either be selected (1) or not selected (0). For every pair of locations, determine whether both are selected as facilities, represented by a binary decision variable. The distances between the locations are scaled by a factor of 1,000,000 and are as follows: Node 0 and Node 1: 19 units, Node 0 and Node 2: 21 units, Node 0 and Node 3: 31 units, Node 0 and Node 4: 35 units, Node 1 and Node 0: 29 units, Node 1 and Node 2: 13 units, Node 1 and Node 3: 46 units, Node 1 and Node 4: 37 units, Node 2 and Node 0: 50 units, Node 2 and Node 1: 22 units, Node 2 and Node 3: 49 units, Node 2 and Node 4: 33 units, Node 3 and Node 0: 18 units, Node 3 and Node 1: 20 units, Node 3 and Node 2: 46 units, Node 3 and Node 4: 33 units, Node 4 and Node 0: 18 units, Node 4 and Node 1: 26 units, Node 4 and Node 2: 39 units, Node 4 and Node 3: 43 units. The total number of selected facilities must equal two. For every pair of locations, the selection of both facilities in the pair is only possible if both individual facilities are selected, enforced through constraints linking the pairwise selection variables to the individual facility selection variables. All decision variables are binary, ensuring facilities are either fully selected or not selected at all. The objective is to maximize the minimum distance between any two selected facilities, ensuring geographical dispersion while adhering to the constraints on pairwise selection and total facility count.","\[
\begin{aligned}
\max \quad & d \\[4pt]
\text{s.t.} \quad 
& y_0 + y_1 + y_2 + y_3 + y_4 = 2, \\[4pt]
& z_{01} \le y_0,\; z_{01} \le y_1,\; z_{01} \ge y_0 + y_1 - 1, \\
& z_{02} \le y_0,\; z_{02} \le y_2,\; z_{02} \ge y_0 + y_2 - 1, \\
& z_{03} \le y_0,\; z_{03} \le y_3,\; z_{03} \ge y_0 + y_3 - 1, \\
& z_{04} \le y_0,\; z_{04} \le y_4,\; z_{04} \ge y_0 + y_4 - 1, \\
& z_{12} \le y_1,\; z_{12} \le y_2,\; z_{12} \ge y_1 + y_2 - 1, \\
& z_{13} \le y_1,\; z_{13} \le y_3,\; z_{13} \ge y_1 + y_3 - 1, \\
& z_{14} \le y_1,\; z_{14} \le y_4,\; z_{14} \ge y_1 + y_4 - 1, \\
& z_{23} \le y_2,\; z_{23} \le y_3,\; z_{23} \ge y_2 + y_3 - 1, \\
& z_{24} \le y_2,\; z_{24} \le y_4,\; z_{24} \ge y_2 + y_4 - 1, \\
& z_{34} \le y_3,\; z_{34} \le y_4,\; z_{34} \ge y_3 + y_4 - 1, \\[4pt]
& d \le 19 + M(1 - z_{01}), \\
& d \le 21 + M(1 - z_{02}), \\
& d \le 31 + M(1 - z_{03}), \\
& d \le 35 + M(1 - z_{04}), \\
& d \le 13 + M(1 - z_{12}), \\
& d \le 46 + M(1 - z_{13}), \\
& d \le 37 + M(1 - z_{14}), \\
& d \le 49 + M(1 - z_{23}), \\
& d \le 33 + M(1 - z_{24}), \\
& d \le 33 + M(1 - z_{34}), \\[4pt]
& d \ge 0, \\[4pt]
& y_i \in \{0,1\} \quad (i=0,\dots,4), \\
& z_{ij} \in \{0,1\} \quad (i<j), \\
& d \in \mathbb{R}_+, \\
& M = 10^9.
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Maximize_d"")

# Parameters
M = 1e9
y_names = [f""y_{i}"" for i in range(5)]
pairs = [(0,1),(0,2),(0,3),(0,4),(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
z_names = {pair: f""z_{pair[0]}{pair[1]}"" for pair in pairs}

# Decision variables
y = m.addVars(5, vtype=GRB.BINARY, name=""y"")
z = m.addVars(len(pairs), vtype=GRB.BINARY, name=""z"")
d = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""d"")

# Objective
m.setObjective(d, GRB.MAXIMIZE)

# Sum of y_i equals 2
m.addConstr(gp.quicksum(y[i] for i in range(5)) == 2, name=""sum_y"")

# Pairwise constraints for z_ij
for idx, (i,j) in enumerate(pairs):
    m.addConstr(z[idx] <= y[i], name=f""z_le_y{i}"")
    m.addConstr(z[idx] <= y[j], name=f""z_le_y{j}"")
    m.addConstr(z[idx] >= y[i] + y[j] - 1, name=f""z_ge_y{i}y{j}"")

# Upper bounds on d based on z_ij
bounds = {
    (0,1): 19,
    (0,2): 21,
    (0,3): 31,
    (0,4): 35,
    (1,2): 13,
    (1,3): 46,
    (1,4): 37,
    (2,3): 49,
    (2,4): 33,
    (3,4): 33
}
for idx, (i,j) in enumerate(pairs):
    m.addConstr(d <= bounds[(i,j)] + M*(1 - z[idx]), name=f""d_le_{i}{j}"")

# Optimize
m.optimize()
",49,46,0,,,,,,,,
"The problem involves scheduling operations for six jobs (Job 0 through Job 5) in a manufacturing facility, where each job consists of two operations that must be performed in sequence. Each operation has a processing time of 1 unit of time. Operations from different jobs may share the same machine, and a machine can only process one operation at a time. The goal is to minimize the total time to complete all jobs, known as the makespan.

For each job, the second operation cannot start until the first operation is completed, ensuring a sequence within each job. Binary variables are used to determine the order of operations on shared machines. If a binary variable is set to 1, it indicates that one operation is scheduled before another on the same machine; if set to 0, the order is reversed. A large constant (100,000) is used in the constraints to enforce this sequencing logic.

The makespan must be at least as large as the completion time of every operation across all jobs. All start times for operations must be non-negative, and the binary variables must be either 0 or 1. The objective is to determine the start times for all operations and the sequence of operations on shared machines to minimize the makespan, ensuring efficient completion of all jobs.

Constraints include ensuring that the start time of the second operation in each job is at least 1 unit of time after the start time of the first operation. For operations sharing the same machine, one operation must finish before the other starts, enforced by the binary variables and the large constant. The makespan must be at least as large as the completion time of every operation, and all start times must be non-negative. The binary variables must be either 0 or 1 to determine the correct sequence of operations on shared machines.","\[
\begin{aligned}
\min\quad & C\\
\text{s.t.}\quad & s_{j,2}\;\ge\;s_{j,1}+1 && \forall j=0,\dots,5\\
& s_{j,k}+1\;\le\;s_{j',k'}+M\bigl(1-y_{jk,j'k'}\bigr) && \forall j<j',\;k,k'\in\{1,2\}\\
& s_{j',k'}+1\;\le\;s_{j,k}+M\,y_{jk,j'k'} && \forall j<j',\;k,k'\in\{1,2\}\\
& C\;\ge\;s_{j,k}+1 && \forall j=0,\dots,5,\;k\in\{1,2\}\\
& s_{j,k}\;\ge\;0 && \forall j,k\\
& C\;\ge\;0\\
& s_{j,k}\in\mathbb{R}_+ && \forall j,k\\
& y_{jk,j'k'}\in\{0,1\} && \forall j<j',\;k,k'\\
& C\in\mathbb{R}_+\\
\end{aligned}
\] where \(M=100000\).","import gurobipy as gp
from gurobipy import GRB

# Parameters
J = 6          # jobs 0..5
K = [1, 2]     # stages 1 and 2
M = 100000

# Create model
m = gp.Model(""Scheduling"")

# Decision variables
s = m.addVars(J, K, lb=0, vtype=GRB.CONTINUOUS, name=""s"")
C = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""C"")

# Binary ordering variables for j<jp
y = {}
for j in range(J):
    for jp in range(j+1, J):
        for k in K:
            for kp in K:
                y[(j, k, jp, kp)] = m.addVar(vtype=GRB.BINARY, name=f""y_{j}_{k}_{jp}_{kp}"")

# Constraints
# 1. s_{j,2} >= s_{j,1} + 1
for j in range(J):
    m.addConstr(s[j, 2] >= s[j, 1] + 1, name=f""order_{j}"")

# 2. Ordering constraints with big-M
for j in range(J):
    for jp in range(j+1, J):
        for k in K:
            for kp in K:
                m.addConstr(s[j, k] + 1 <= s[jp, kp] + M * (1 - y[(j, k, jp, kp)]),
                            name=f""seq1_{j}_{k}_{jp}_{kp}"")
                m.addConstr(s[jp, kp] + 1 <= s[j, k] + M * y[(j, k, jp, kp)],
                            name=f""seq2_{j}_{k}_{jp}_{kp}"")

# 3. C >= s_{j,k} + 1
for j in range(J):
    for k in K:
        m.addConstr(C >= s[j, k] + 1, name=f""c_ge_s_{j}_{k}"")

# Objective: minimize C
m.setObjective(C, GRB.MINIMIZE)

# Optimize
m.optimize()",2,6,0,,,,,,,,
"In a manufacturing facility, six distinct jobs need to be processed on shared machines. Each job consists of two operations that must be performed in a specific order, with the second operation starting only after the first operation is completed. Each operation has a processing time of 1 unit. The goal is to minimize the total completion time, known as the makespan, by scheduling operations on the machines efficiently.

Each operation is assigned to a specific machine, and some operations from different jobs share the same machine, creating potential conflicts. To resolve these conflicts, the scheduler must determine the order in which operations are processed on each machine. This is achieved using binary variables, where a value of 1 indicates that one operation is scheduled before another, and 0 indicates the opposite. A large constant of 100,000 is used in the constraints to ensure that only one of the two possible orders is active at any time, preventing overlapping operations on the same machine.

The start time of each operation must be non-negative, and the makespan must be at least as large as the completion time of every operation. The precedence constraints ensure that for each job, the start time of the second operation is at least 1 unit of time after the start time of the first operation. The machine capacity constraints ensure that for every pair of operations assigned to the same machine, one operation must finish before the other starts, determined by the binary variables.

The objective is to minimize the makespan by scheduling the operations in a way that respects the precedence constraints within each job, avoids overlapping operations on the same machine, and ensures all start times are non-negative. The solution must also accurately reflect the completion time of the last operation, ensuring the makespan is minimized.","\[
\begin{aligned}
\min\quad & C \\[4pt]
\text{s.t.}\quad 
& s_{j,2}\;\ge\;s_{j,1}+1, && \forall j\in J, \\[2pt]
& s_{j,k}\;\ge\;0, && \forall j\in J,\;k=1,2, \\[2pt]
& C\;\ge\;s_{j,k}+1, && \forall j\in J,\;k=1,2, \\[2pt]
& s_{j_1,k_1}+1\;\le\;s_{j_2,k_2}+100000\,(1-z_{(j_1,k_1),(j_2,k_2)}), && \forall (j_1,k_1)\neq(j_2,k_2),\;m_{j_1,k_1}=m_{j_2,k_2}, \\[2pt]
& s_{j_2,k_2}+1\;\le\;s_{j_1,k_1}+100000\,z_{(j_1,k_1),(j_2,k_2)}, && \forall (j_1,k_1)\neq(j_2,k_2),\;m_{j_1,k_1}=m_{j_2,k_2}, \\[2pt]
& z_{(j_1,k_1),(j_2,k_2)}\in\{0,1\}, && \forall (j_1,k_1)\neq(j_2,k_2),\;m_{j_1,k_1}=m_{j_2,k_2}, \\[2pt]
& s_{j,k}\in\mathbb{R}_+, && \forall j\in J,\;k=1,2, \\[2pt]
& C\in\mathbb{R}_+.
\end{aligned}
\]

where \(J=\{1,\dots,6\}\), \(O=\{1,2\}\), and \(m_{j,k}\) is the machine assigned to operation \(k\) of job \(j\).","import gurobipy as gp
from gurobipy import GRB

# Data
J = [1, 2, 3, 4, 5, 6]
O = [1, 2]
# Example machine assignment m_{j,k}
m_assign = {
    (1, 1): 1, (1, 2): 2,
    (2, 1): 1, (2, 2): 2,
    (3, 1): 1, (3, 2): 2,
    (4, 1): 1, (4, 2): 2,
    (5, 1): 1, (5, 2): 2,
    (6, 1): 1, (6, 2): 2
}

# Create model
m = gp.Model(""Job_Scheduling"")

# Decision variables
s = m.addVars(J, O, vtype=GRB.CONTINUOUS, lb=0, name=""s"")
C = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""C"")

# Binary variables for ordering on same machine
z = {}
for j1 in J:
    for k1 in O:
        for j2 in J:
            for k2 in O:
                if (j1, k1) < (j2, k2) and m_assign[(j1, k1)] == m_assign[(j2, k2)]:
                    z[(j1, k1, j2, k2)] = m.addVar(vtype=GRB.BINARY, name=f""z_{j1}_{k1}_{j2}_{k2}"")

# Objective: minimize C
m.setObjective(C, GRB.MINIMIZE)

# Constraints
# s_{j,2} >= s_{j,1} + 1
for j in J:
    m.addConstr(s[j, 2] >= s[j, 1] + 1, name=f""seq_{j}"")

# C >= s_{j,k} + 1
for j in J:
    for k in O:
        m.addConstr(C >= s[j, k] + 1, name=f""makespan_{j}_{k}"")

# Ordering constraints with big M
M = 100000
for (j1, k1, j2, k2), var in z.items():
    m.addConstr(s[j1, k1] + 1 <= s[j2, k2] + M * (1 - var), name=f""order1_{j1}_{k1}_{j2}_{k2}"")
    m.addConstr(s[j2, k2] + 1 <= s[j1, k1] + M * var, name=f""order2_{j1}_{k1}_{j2}_{k2}"")

# Solve
m.optimize()

# Output results
if m.status == GRB.OPTIMAL:
    print(""Optimal makespan:"", C.X)
    for j in J:
        print(f""Job {j} op1 start: {s[j, 1].X}, op2 start: {s[j, 2].X}"")",2,4,0,,,,,,,,
"The goal is to minimize the total travel cost for a delivery vehicle visiting six cities: City 0, City 1, City 2, City 3, City 4, and City 5. The vehicle must visit each city exactly once and return to the starting point, ensuring the route forms a single tour without subtours. The decision variables include binary choices for whether the vehicle travels directly from one city to another and general integer variables representing the sequence in which cities are visited. The travel costs between cities are as follows: from City 0 to City 1 costs 281, to City 2 costs 300, to City 3 costs 307, to City 4 costs 313, and to City 5 costs 308; from City 1 to City 0 costs 314, to City 2 costs 313, to City 3 costs 324, to City 4 costs 321, and to City 5 costs 323; from City 2 to City 0 costs 317, to City 1 costs 277, to City 3 costs 297, to City 4 costs 299, and to City 5 costs 308; from City 3 to City 0 costs 287, to City 1 costs 304, to City 2 costs 291, to City 4 costs 299, and to City 5 costs 320; from City 4 to City 0 costs 312, to City 1 costs 314, to City 2 costs 292, to City 3 costs 322, and to City 5 costs 275; from City 5 to City 0 costs 320, to City 1 costs 282, to City 2 costs 280, to City 3 costs 313, and to City 4 costs 321. The constraints include ensuring the vehicle arrives at and departs from each city exactly once, assigning sequence numbers to cities to prevent subtours, and ensuring sequence numbers are unique and range from 0 to 5. Subtour elimination is enforced by linking route decisions with sequence numbers, ensuring logical visit order and preventing invalid loops. The solution must respect all constraints to form a valid tour while minimizing total travel costs.","\[
\begin{aligned}
\min \quad & 281x_{01}+300x_{02}+307x_{03}+313x_{04}+308x_{05} \\
& +314x_{10}+313x_{12}+324x_{13}+321x_{14}+323x_{15} \\
& +317x_{20}+277x_{21}+297x_{23}+299x_{24}+308x_{25} \\
& +287x_{30}+304x_{31}+291x_{32}+299x_{34}+320x_{35} \\
& +312x_{40}+314x_{41}+292x_{42}+322x_{43}+275x_{45} \\
& +320x_{50}+282x_{51}+280x_{52}+313x_{53}+321x_{54} \\
\text{s.t.} \quad & \sum_{\substack{j=0\\ j\neq i}}^{5} x_{ij}=1 && \forall i=0,\dots,5 \\
& \sum_{\substack{i=0\\ i\neq j}}^{5} x_{ij}=1 && \forall j=0,\dots,5 \\
& u_0=0 \\
& 1\le u_i \le 5 && \forall i=1,\dots,5 \\
& u_i - u_j + 6x_{ij}\le 5 && \forall i,j=1,\dots,5,\ i\neq j \\
& x_{ij}\in\{0,1\} && \forall i,j=0,\dots,5,\ i\neq j \\
& u_i\in\mathbb{Z} && \forall i=1,\dots,5
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Cost data
costs = {
    (0,1):281, (0,2):300, (0,3):307, (0,4):313, (0,5):308,
    (1,0):314, (1,2):313, (1,3):324, (1,4):321, (1,5):323,
    (2,0):317, (2,1):277, (2,3):297, (2,4):299, (2,5):308,
    (3,0):287, (3,1):304, (3,2):291, (3,4):299, (3,5):320,
    (4,0):312, (4,1):314, (4,2):292, (4,3):322, (4,5):275,
    (5,0):320, (5,1):282, (5,2):280, (5,3):313, (5,4):321
}

nodes = range(6)

# Create model
m = gp.Model(""TSP"")

# Decision variables x_ij
x = m.addVars([(i,j) for i in nodes for j in nodes if i!=j],
              vtype=GRB.BINARY, name=""x"")

# Position variables u_i for nodes 1..5
u = m.addVars([i for i in nodes if i!=0],
              vtype=GRB.INTEGER, lb=1, ub=5, name=""u"")

# Outgoing and incoming constraints
for i in nodes:
    m.addConstr(gp.quicksum(x[i,j] for j in nodes if j!=i) == 1, name=f""out_{i}"")
    m.addConstr(gp.quicksum(x[j,i] for j in nodes if j!=i) == 1, name=f""in_{i}"")

# Subtour elimination constraints
for i in range(1,6):
    for j in range(1,6):
        if i != j:
            m.addConstr(u[i] - u[j] + 6*x[i,j] <= 5, name=f""subtour_{i}_{j}"")

# Objective function
m.setObjective(gp.quicksum(costs[i,j]*x[i,j] for i,j in costs), GRB.MINIMIZE)

# Optimize
m.optimize()",1741,1741,1,,,,,,,,
"Minimize the total operational costs, which include production setup costs of 145.2319299071881 per production run, machine startup costs of 65.79360965435782 per startup, inventory holding costs of 0.8652264753415143 for Product 0, 0.9341662877492469 for Product 1, and 1.07339072521956 for Product 2 per unit, and backlogging penalties of 7.607410261300208 for Product 0, 6.920344391340704 for Product 1, and 6.497781941350707 for Product 2 per unit. The decisions include whether to produce each product on each machine in each period, whether to start up a machine for a specific product in a given period, the exact amount of each product to produce on each machine in each period, how much of each product to keep in inventory at the end of each period, and how much to backlog if demand cannot be met. 

The constraints include meeting customer demand in each period, where the total production of each product across both machines, plus any inventory carried over from the previous period, minus any backlog from the previous period, must equal the demand for that period plus the current inventory minus the current backlog. The demands are 21.53845915883999 for Product 0 in Period 0, 22.99877365370049 in Period 1, and 20.41750946364395 in Period 2; 24.34292430654904 for Product 1 in Period 0, 18.69161579278047 in Period 1, and 16.96075239636408 in Period 2; and 15.44135005337596 for Product 2 in Period 0, 24.75403844533352 in Period 1, and 17.09921582696376 in Period 2. 

The total production quantity for each product on each machine in each period, plus any startup time required, must not exceed the machine's capacity. The startup time for Machine 0 is 6.900949355420833, and for Machine 1, it is 7.255877688483005. The capacity of Machine 0 is 73.62985121550206, and for Machine 1, it is 69.3191618930891. Each machine can only be used for one product at a time in each period, meaning the sum of production decisions for all products on a single machine in a given period cannot exceed 1. 

If a machine is used to produce a product in a period but was not used for that product in the previous period, a startup cost is incurred. For the first period, a startup is automatically required if production occurs. Production quantities, inventory levels, and backlogs must be non-negative, and production and startup decisions are binary (0 or 1).","\[
\begin{aligned}
\text{Minimize}\quad
& 145.2319299071881 \sum_{m\in M}\sum_{p\in P}\sum_{t\in T} y_{mpt}
+ 65.79360965435782 \sum_{m\in M}\sum_{p\in P}\sum_{t\in T} s_{mpt} \\
&\quad + \sum_{p\in P}\sum_{t\in T} h_p\, I_{pt}
+ \sum_{p\in P}\sum_{t\in T} b_p\, B_{pt}
\end{aligned}
\]

\[
\begin{aligned}
\text{subject to}\quad
&\sum_{p\in P} x_{mpt} + \tau_m \sum_{p\in P} s_{mpt} \le C_m
&&\forall m\in M,\; t\in T \\
&\sum_{p\in P} y_{mpt} \le 1
&&\forall m\in M,\; t\in T \\
&x_{mpt} \le C_m\, y_{mpt}
&&\forall m\in M,\; p\in P,\; t\in T \\
& s_{mp0}=y_{mp0}
&&\forall m\in M,\; p\in P \\
& s_{mpt} \ge y_{mpt}-y_{mp(t-1)}
&&\forall m\in M,\; p\in P,\; t=1,2 \\
& s_{mpt} \le y_{mpt}
&&\forall m\in M,\; p\in P,\; t\in T \\
&\sum_{m\in M} x_{mp0}=d_{p0}+I_{p0}-B_{p0}
&&\forall p\in P \\
&\sum_{m\in M} x_{mp t}+I_{p(t-1)}-B_{p(t-1)}
   = d_{pt}+I_{pt}-B_{pt}
&&\forall p\in P,\; t=1,2 \\
&x_{mpt}\ge 0,\; I_{pt}\ge 0,\; B_{pt}\ge 0
&&\forall m\in M,\; p\in P,\; t\in T
\end{aligned}
\]

\[
\begin{aligned}
&y_{mpt},\, s_{mpt}\in\{0,1\}
&&\forall m\in M,\; p\in P,\; t\in T \\
&x_{mpt},\, I_{pt},\, B_{pt}\in\mathbb{R}_{+}
&&\forall m\in M,\; p\in P,\; t\in T
\end{aligned}
\]

\[
\begin{aligned}
& M=\{0,1\},\quad P=\{0,1,2\},\quad T=\{0,1,2\} \\
& C_0=73.62985121550206,\; C_1=69.3191618930891 \\
& \tau_0=6.900949355420833,\; \tau_1=7.255877688483005 \\
& h_0=0.8652264753415143,\; h_1=0.9341662877492469,\; h_2=1.07339072521956 \\
& b_0=7.607410261300208,\; b_1=6.920344391340704,\; b_2=6.497781941350707 \\
& d_{p0}=\{21.53845915883999,\;24.34292430654904,\;15.44135005337596\} \\
& d_{p1}=\{22.99877365370049,\;18.69161579278047,\;24.75403844533352\} \\
& d_{p2}=\{20.41750946364395,\;16.96075239636408,\;17.09921582696376\}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Sets
M = [0, 1]
P = [0, 1, 2]
T = [0, 1, 2]

# Parameters
C = {0: 73.62985121550206, 1: 69.3191618930891}
tau = {0: 6.900949355420833, 1: 7.255877688483005}
h = {0: 0.8652264753415143, 1: 0.9341662877492469, 2: 1.07339072521956}
b = {0: 7.607410261300208, 1: 6.920344391340704, 2: 6.497781941350707}
d = {
    0: [21.53845915883999, 24.34292430654904, 15.44135005337596],
    1: [22.99877365370049, 18.69161579278047, 24.75403844533352],
    2: [20.41750946364395, 16.96075239636408, 17.09921582696376]
}

# Create model
m = gp.Model(""Optimization_Model"")

# Decision variables
y = m.addVars(M, P, T, vtype=GRB.BINARY, name=""y"")
s = m.addVars(M, P, T, vtype=GRB.BINARY, name=""s"")
x = m.addVars(M, P, T, vtype=GRB.CONTINUOUS, lb=0, name=""x"")
I = m.addVars(P, T, vtype=GRB.CONTINUOUS, lb=0, name=""I"")
B = m.addVars(P, T, vtype=GRB.CONTINUOUS, lb=0, name=""B"")

# Objective function
obj = (
    145.2319299071881 * gp.quicksum(y[m_, p_, t_] for m_ in M for p_ in P for t_ in T) +
    65.79360965435782 * gp.quicksum(s[m_, p_, t_] for m_ in M for p_ in P for t_ in T) +
    gp.quicksum(h[p_] * I[p_, t_] for p_ in P for t_ in T) +
    gp.quicksum(b[p_] * B[p_, t_] for p_ in P for t_ in T)
)
m.setObjective(obj, GRB.MINIMIZE)

# Constraints
# Capacity constraints
for m_ in M:
    for t_ in T:
        m.addConstr(
            gp.quicksum(x[m_, p_, t_] for p_ in P) + tau[m_] * gp.quicksum(s[m_, p_, t_] for p_ in P) <= C[m_],
            name=f""capacity_{m_}_{t_}""
        )

# y sum <= 1
for m_ in M:
    for t_ in T:
        m.addConstr(
            gp.quicksum(y[m_, p_, t_] for p_ in P) <= 1,
            name=f""y_sum_{m_}_{t_}""
        )

# x <= C_m * y
for m_ in M:
    for p_ in P:
        for t_ in T:
            m.addConstr(
                x[m_, p_, t_] <= C[m_] * y[m_, p_, t_],
                name=f""x_y_rel_{m_}_{p_}_{t_}""
            )

# s_{mp0} = y_{mp0}
for m_ in M:
    for p_ in P:
        m.addConstr(
            s[m_, p_, 0] == y[m_, p_, 0],
            name=f""s_y_eq_{m_}_{p_}_0""
        )

# s_{mpt} >= y_{mpt} - y_{mp(t-1)} for t=1,2
for m_ in M:
    for p_ in P:
        for t_ in [1, 2]:
            m.addConstr(
                s[m_, p_, t_] >= y[m_, p_, t_] - y[m_, p_, t_ - 1],
                name=f""s_y_diff_{m_}_{p_}_{t_}""
            )

# s_{mpt} <= y_{mpt}
for m_ in M:
    for p_ in P:
        for t_ in T:
            m.addConstr(
                s[m_, p_, t_] <= y[m_, p_, t_],
                name=f""s_y_leq_{m_}_{p_}_{t_}""
            )

# Demand balance at t=0
for p_ in P:
    m.addConstr(
        gp.quicksum(x[m_, p_, 0] for m_ in M) == d[0][p_] + I[p_, 0] - B[p_, 0],
        name=f""demand_0_{p_}""
    )

# Demand balance for t=1,2
for p_ in P:
    for t_ in [1, 2]:
        m.addConstr(
            gp.quicksum(x[m_, p_, t_] for m_ in M) + I[p_, t_ - 1] - B[p_, t_ - 1] ==
            d[t_][p_] + I[p_, t_] - B[p_, t_],
            name=f""demand_{t_}_{p_}""
        )

# Optimize
m.optimize()
",856.1453748,856.1453748,1,,,,,,,,
"A logistics company must deliver packages to seven cities: City 0, City 1, City 2, City 3, City 4, City 5, and City 6. The goal is to determine the most efficient route that minimizes the total delivery cost while ensuring each city is visited exactly once and the route forms a single continuous loop. The delivery costs between cities are as follows:  

- From City 0: To City 1 costs 277, to City 2 costs 301, to City 3 costs 299, to City 4 costs 301, to City 5 costs 280, and to City 6 costs 282.  
- From City 1: To City 0 costs 311, to City 2 costs 291, to City 3 costs 291, to City 4 costs 310, to City 5 costs 292, and to City 6 costs 313.  
- From City 2: To City 0 costs 315, to City 1 costs 310, to City 3 costs 285, to City 4 costs 320, to City 5 costs 278, and to City 6 costs 311.  
- From City 3: To City 0 costs 290, to City 1 costs 289, to City 2 costs 313, to City 4 costs 289, to City 5 costs 320, and to City 6 costs 305.  
- From City 4: To City 0 costs 277, to City 1 costs 313, to City 2 costs 325, to City 3 costs 300, to City 5 costs 300, and to City 6 costs 281.  
- From City 5: To City 0 costs 281, to City 1 costs 301, to City 2 costs 311, to City 3 costs 292, to City 4 costs 299, and to City 6 costs 305.  
- From City 6: To City 0 costs 280, to City 1 costs 291, to City 2 costs 311, to City 3 costs 298, to City 4 costs 275, and to City 5 costs 298.  

The problem requires that each city is visited exactly once and that each city is the starting point for exactly one trip. To ensure the route forms a single continuous loop without smaller disconnected loops, the company uses constraints involving the position of each city in the tour. Each city is assigned a position in the delivery sequence, ranging from 1 to 7, and these positions must satisfy constraints that prevent subtours. For example, if City 1 is visited before City 2, the position of City 1 must be less than that of City 2. The objective is to minimize the total delivery cost, which is the sum of the costs of all trips taken, while satisfying all constraints.","\[
\begin{aligned}
\min \;& 277x_{01}+301x_{02}+299x_{03}+301x_{04}+280x_{05}+282x_{06} \\
&+311x_{10}+291x_{12}+291x_{13}+310x_{14}+292x_{15}+313x_{16} \\
&+315x_{20}+310x_{21}+285x_{23}+320x_{24}+278x_{25}+311x_{26} \\
&+290x_{30}+289x_{31}+313x_{32}+289x_{34}+320x_{35}+305x_{36} \\
&+277x_{40}+313x_{41}+325x_{42}+300x_{43}+300x_{45}+281x_{46} \\
&+281x_{50}+301x_{51}+311x_{52}+292x_{53}+299x_{54}+305x_{56} \\
&+280x_{60}+291x_{61}+311x_{62}+298x_{63}+275x_{64}+298x_{65} \\
\text{s.t.}\;& \sum_{\substack{j=0\\ j\neq i}}^{6} x_{ij}=1 && \forall i=0,\dots,6 \\
& \sum_{\substack{i=0\\ i\neq j}}^{6} x_{ij}=1 && \forall j=0,\dots,6 \\
& u_i - u_j + 7\,x_{ij} \le 6 && \forall i\neq j,\; i,j=0,\dots,6 \\
& u_0 = 1 \\
& x_{ij}\in\{0,1\}\quad \forall i\neq j \\
& u_i\in\mathbb{Z}\quad \forall i,\; 1\le u_i \le 7
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Cost matrix (7x7) with zeros on the diagonal
c = [
    [0, 277, 301, 299, 301, 280, 282],
    [311, 0, 291, 291, 310, 292, 313],
    [315, 310, 0, 285, 320, 278, 311],
    [290, 289, 313, 0, 289, 320, 305],
    [277, 313, 325, 300, 0, 300, 281],
    [281, 301, 311, 292, 299, 0, 305],
    [280, 291, 311, 298, 275, 298, 0]
]

m = gp.Model(""TSP_MTZ"")

# Decision variables
x = m.addVars([(i, j) for i in range(7) for j in range(7) if i != j],
              vtype=GRB.BINARY, name=""x"")
u = m.addVars(range(7), vtype=GRB.INTEGER, name=""u"")

# Bounds for u variables
for i in range(7):
    u[i].lb = 1
    u[i].ub = 7

# Objective function
m.setObjective(gp.quicksum(c[i][j] * x[i, j] for i in range(7) for j in range(7) if i != j),
               GRB.MINIMIZE)

# Each node has exactly one outgoing edge
for i in range(7):
    m.addConstr(gp.quicksum(x[i, j] for j in range(7) if i != j) == 1,
                name=f""out_{i}"")

# Each node has exactly one incoming edge
for j in range(7):
    m.addConstr(gp.quicksum(x[i, j] for i in range(7) if i != j) == 1,
                name=f""in_{j}"")

# MTZ subtour elimination constraints
for i in range(7):
    for j in range(7):
        if i != j:
            m.addConstr(u[i] - u[j] + 7 * x[i, j] <= 6,
                        name=f""mtz_{i}_{j}"")

# Fix the starting node
m.addConstr(u[0] == 1, name=""u0"")

# Optimize
m.optimize()
",,1988,0,,,,,,,,
" Cell Tower Deployment for Regional Coverage

You are tasked with deploying cell towers across a region to maximize population coverage while adhering to a strict budget constraint. The region is divided into 34 distinct areas, each with a specific population size that needs to be covered by the cell towers. Your goal is to determine which towers to build and which areas to cover to ensure the maximum number of people have access to cellular service.

#### Key Decisions:
1. **Tower Deployment**: Decide whether to build each of the 30 available cell towers. Each tower has a unique construction cost, and building it will enable coverage for certain areas.
2. **Area Coverage**: Determine which of the 34 areas will be covered by the deployed towers. An area is considered covered if at least one of the towers that can serve it is built.

#### Objective:
Maximize the total population covered by the deployed cell towers. The population sizes for the 34 areas are as follows:
- Area 0: 3,328 people
- Area 1: 2,066 people
- Area 2: 2,261 people
- Area 3: 4,527 people
- Area 4: 4,205 people
- Area 5: 4,927 people
- Area 6: 2,941 people
- Area 7: 4,277 people
- Area 8: 3,276 people
- Area 9: 4,326 people
- Area 10: 2,852 people
- Area 11: 3,957 people
- Area 12: 2,068 people
- Area 13: 4,724 people
- Area 14: 3,226 people
- Area 15: 3,575 people
- Area 16: 2,922 people
- Area 17: 3,850 people
- Area 18: 4,898 people
- Area 19: 2,288 people
- Area 20: 4,726 people
- Area 21: 2,513 people
- Area 22: 2,336 people
- Area 23: 4,669 people
- Area 24: 4,626 people
- Area 25: 4,585 people
- Area 26: 4,367 people
- Area 27: 4,981 people
- Area 28: 4,049 people
- Area 29: 4,948 people
- Area 30: 2,182 people
- Area 31: 2,421 people
- Area 32: 3,061 people
- Area 33: 4,310 people

#### Constraints:
1. **Coverage Requirements**: Each area must be covered by at least one of the towers that can serve it. For example:
   - Area 0 can be covered by Towers 0, 3, 4, 7, 9, 16, 17, 20, 22, 24, 25, 26, or 27.
   - Area 1 can be covered by Towers 0, 1, 15, 19, 22, 23, 25, 26, 27, or 29.
   - Similar coverage relationships exist for all 34 areas, as detailed in the input data.

2. **Budget Constraint**: The total cost of building the selected towers must not exceed the available budget of 3,375 units. The construction costs for the towers are:
   - Tower 0: 248 units
   - Tower 1: 226 units
   - Tower 2: 454 units
   - Tower 3: 466 units
   - Tower 4: 241 units
   - Tower 5: 201 units
   - Tower 6: 415 units
   - Tower 7: 486 units
   - Tower 8: 485 units
   - Tower 9: 492 units
   - Tower 10: 249 units
   - Tower 11: 486 units
   - Tower 12: 417 units
   - Tower 13: 327 units
   - Tower 14: 257 units
   - Tower 15: 486 units
   - Tower 16: 438 units
   - Tower 17: 266 units
   - Tower 18: 473 units
   - Tower 19: 268 units
   - Tower 20: 293 units
   - Tower 21: 379 units
   - Tower 22: 476 units
   - Tower 23: 482 units
   - Tower 24: 367 units
   - Tower 25: 239 units
   - Tower 26: 368 units
   - Tower 27: 492 units
   - Tower 28: 454 units
   - Tower 29: 319 units

3. **Binary Decisions**: Each tower can either be built (1) or not built (0), and each area can either be covered (1) or not covered (0).

#### Summary:
Your task is to select which towers to build and which areas to cover to maximize the total population served, ensuring that all coverage requirements are met and the total construction cost does not exceed the budget. The solution must account for the specific coverage capabilities of each tower and the population sizes of the areas.","\begin{align*}
\max \quad & 3328 y_0 + 2066 y_1 + 2261 y_2 + 4527 y_3 + 4205 y_4 + 4927 y_5 + 2941 y_6 + 4277 y_7 + 3276 y_8 + 4326 y_9 + 2852 y_{10} + 3957 y_{11} + 2068 y_{12} + 4724 y_{13} + 3226 y_{14} + 3575 y_{15} + 2922 y_{16} + 3850 y_{17} + 4898 y_{18} + 2288 y_{19} + 4726 y_{20} + 2513 y_{21} + 2336 y_{22} + 4669 y_{23} + 4626 y_{24} + 4585 y_{25} + 4367 y_{26} + 4981 y_{27} + 4049 y_{28} + 4948 y_{29} + 2182 y_{30} + 2421 y_{31} + 3061 y_{32} + 4310 y_{33} \\
\text{s.t.} \quad & \sum_{t \in S_a} x_t \;\ge\; y_a \quad \forall a=0,\dots,33 \\
& 248 x_0 + 226 x_1 + 454 x_2 + 466 x_3 + 241 x_4 + 201 x_5 + 415 x_6 + 486 x_7 + 485 x_8 + 492 x_9 + 249 x_{10} + 486 x_{11} + 417 x_{12} + 327 x_{13} + 257 x_{14} + 486 x_{15} + 438 x_{16} + 266 x_{17} + 473 x_{18} + 268 x_{19} + 293 x_{20} + 379 x_{21} + 476 x_{22} + 482 x_{23} + 367 x_{24} + 239 x_{25} + 368 x_{26} + 492 x_{27} + 454 x_{28} + 319 x_{29} \;\le\; 3375 \\
& x_t \in \{0,1\} \quad \forall t=0,\dots,29 \\
& y_a \in \{0,1\} \quad \forall a=0,\dots,33
\end{align*}","import gurobipy as gp
from gurobipy import GRB

m = gp.Model(""Optimization_Model"")

# Decision variables
x = m.addVars(30, vtype=GRB.BINARY, name=""x"")
y = m.addVars(34, vtype=GRB.BINARY, name=""y"")

# Objective coefficients for y
c_y = [3328,2066,2261,4527,4205,4927,2941,4277,3276,4326,2852,3957,2068,4724,3226,3575,2922,3850,4898,2288,4726,2513,2336,4669,4626,4585,4367,4981,4049,4948,2182,2421,3061,4310]
m.setObjective(gp.quicksum(c_y[a]*y[a] for a in range(34)), GRB.MAXIMIZE)

# Resource constraint coefficients for x
c_x = [248,226,454,466,241,201,415,486,485,492,249,486,417,327,257,486,438,266,473,268,293,379,476,482,367,239,368,492,454,319]
m.addConstr(gp.quicksum(c_x[t]*x[t] for t in range(30)) <= 3375, name=""resource"")

# Define S_a sets (fill with appropriate indices)
S_a = {a: [] for a in range(34)}  # replace [] with actual t indices for each a

for a in range(34):
    m.addConstr(gp.quicksum(x[t] for t in S_a[a]) >= y[a], name=f""link_{a}"")

m.optimize()",0,124268,0,,,,,,,,
"Minimize the total operational costs, which include production setup costs, machine startup costs, inventory holding costs, and backlogging costs, while meeting customer demand for each product in each period. The decisions involve determining whether to produce each product on each machine in each period, deciding whether to start up each machine for each product in each period, determining the exact quantity of each product to produce on each machine in each period, and deciding how much inventory to carry over or how much demand to backlog for each product in each period. The total cost includes production setup costs of 149.1695690337089 per production run, machine startup costs of 69.24269269143792 per machine startup, inventory holding costs of 1.080318154052025 for Product 0 and 1.143069947055348 for Product 1, and backlogging costs of 6.798895023015501 for Product 0 and 6.372651501311341 for Product 1. The constraints ensure that the total production of each product across all machines, plus any inventory carried over from the previous period, minus any backlog from the previous period, equals the demand for that product in the current period, plus any inventory carried forward, minus any backlogged demand. The demands are 22.92965094851524 units for Product 0 in Period 0, 19.03396834281949 units in Period 1, and 18.90167422155575 units in Period 2, and 19.80185049682801 units for Product 1 in Period 0, 24.22810173621122 units in Period 1, and 16.84556169689551 units in Period 2. The production quantity on each machine, plus the startup time, cannot exceed the machine's capacity, which is 76.7045484622153 for Machine 0 and 69.3695364951939 for Machine 1. Each machine can only produce one product at a time in any given period. If a machine is used for production in a period but was not used in the previous period, a startup cost is incurred. Production quantities, inventory levels, and backlogs must be non-negative, and production and startup decisions must be binary.","\[
\begin{aligned}
\min\;&\sum_{t=0}^{2}\sum_{m=0}^{1}\sum_{p=0}^{1}149.1695690337089\,y_{m,p,t}
+\sum_{t=0}^{2}\sum_{m=0}^{1}69.24269269143792\,u_{m,t} \\
&+\sum_{t=0}^{2}\bigl(1.080318154052025\,I_{0,t}+1.143069947055348\,I_{1,t}\bigr)
+\sum_{t=0}^{2}\bigl(6.798895023015501\,B_{0,t}+6.372651501311341\,B_{1,t}\bigr)
\end{aligned}
\]

\[
\begin{aligned}
&\text{(1) Production capacity:}\quad
q_{m,p,t}\le
\begin{cases}
76.7045484622153\,y_{m,p,t} & m=0\\
69.3695364951939\,y_{m,p,t} & m=1
\end{cases}\qquad \forall m,p,t\\[4pt]
&\text{(2) One product per machine per period:}\quad
\sum_{p=0}^{1}y_{m,p,t}\le 1\qquad \forall m,t\\[4pt]
&\text{(3) Machine usage indicator:}\quad
s_{m,t}\ge y_{m,p,t}\qquad \forall m,p,t\\[4pt]
&\text{(4) Startup cost:}\quad
u_{m,t}\ge s_{m,t}-s_{m,t-1}\qquad \forall m,t>0\\
&\quad u_{m,0}=s_{m,0}\qquad \forall m\\[4pt]
&\text{(5) Inventory balance:}\quad
I_{p,t}=I_{p,t-1}+\sum_{m=0}^{1}q_{m,p,t}-d_{p,t}+B_{p,t-1}-B_{p,t}\qquad \forall p,t\\
&\quad I_{p,-1}=0,\;B_{p,-1}=0\\[4pt]
&\text{(6) Non__egativity:}\quad
q_{m,p,t}\ge0,\;I_{p,t}\ge0,\;B_{p,t}\ge0\qquad \forall m,p,t
\end{aligned}
\]

\[
\begin{aligned}
&y_{m,p,t}\in\{0,1\}\qquad \forall m,p,t\\
&s_{m,t}\in\{0,1\}\qquad \forall m,t\\
&u_{m,t}\in\{0,1\}\qquad \forall m,t\\
&q_{m,p,t}\in\mathbb{R}_{+}\qquad \forall m,p,t\\
&I_{p,t}\in\mathbb{R}_{+}\qquad \forall p,t\\
&B_{p,t}\in\mathbb{R}_{+}\qquad \forall p,t
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Data
capacity = [76.7045484622153, 69.3695364951939]
d = [[10, 12, 8], [9, 11, 7]]  # demand for product 0 and 1 over 3 periods

# Create model
m = gp.Model(""Production_Planning"")

# Decision variables
y = m.addVars(2, 2, 3, vtype=GRB.BINARY, name=""y"")  # y[m,p,t]
s = m.addVars(2, 3, vtype=GRB.BINARY, name=""s"")   # s[m,t]
u = m.addVars(2, 3, vtype=GRB.BINARY, name=""u"")   # u[m,t]
q = m.addVars(2, 2, 3, vtype=GRB.CONTINUOUS, lb=0, name=""q"")  # q[m,p,t]
I = m.addVars(2, 3, vtype=GRB.CONTINUOUS, lb=0, name=""I"")   # I[p,t]
B = m.addVars(2, 3, vtype=GRB.CONTINUOUS, lb=0, name=""B"")   # B[p,t]

# Objective
obj = gp.quicksum(149.1695690337089 * y[m_idx, p, t] for m_idx in range(2) for p in range(2) for t in range(3))
obj += gp.quicksum(69.24269269143792 * u[m_idx, t] for m_idx in range(2) for t in range(3))
obj += gp.quicksum(1.080318154052025 * I[0, t] + 1.143069947055348 * I[1, t] for t in range(3))
obj += gp.quicksum(6.798895023015501 * B[0, t] + 6.372651501311341 * B[1, t] for t in range(3))
m.setObjective(obj, GRB.MINIMIZE)

# Constraints
# Production capacity
for m_idx in range(2):
    for p in range(2):
        for t in range(3):
            m.addConstr(q[m_idx, p, t] <= capacity[m_idx] * y[m_idx, p, t], name=f""cap_{m_idx}_{p}_{t}"")

# One product per machine per period
for m_idx in range(2):
    for t in range(3):
        m.addConstr(gp.quicksum(y[m_idx, p, t] for p in range(2)) <= 1, name=f""oneprod_{m_idx}_{t}"")

# Machine usage indicator
for m_idx in range(2):
    for p in range(2):
        for t in range(3):
            m.addConstr(s[m_idx, t] >= y[m_idx, p, t], name=f""usage_{m_idx}_{p}_{t}"")

# Startup cost
for m_idx in range(2):
    m.addConstr(u[m_idx, 0] == s[m_idx, 0], name=f""startup0_{m_idx}"")
    for t in range(1, 3):
        m.addConstr(u[m_idx, t] >= s[m_idx, t] - s[m_idx, t - 1], name=f""startup_{m_idx}_{t}"")

# Inventory balance
for p in range(2):
    for t in range(3):
        prev_I = I[p, t - 1] if t > 0 else 0
        prev_B = B[p, t - 1] if t > 0 else 0
        m.addConstr(I[p, t] == prev_I + gp.quicksum(q[m_idx, p, t] for m_idx in range(2)) - d[p][t] + prev_B - B[p, t], name=f""inv_{p}_{t}"")

# Solve
m.optimize()

# Print results
for v in m.getVars():
    if v.X != 0:
        print(f""{v.VarName} = {v.X}"")",495.6501804401341,564.4326342,0,,,,,,,,
"Minimize the total cost, which includes fixed costs for establishing selected transit lines, operational costs based on the frequency of each line, and penalty costs for any unmet passenger demand. The fixed costs for establishing lines L_0 to L_13 are 2048, 2064, 2058, 3000, 2107, 2583, 2569, 2081, 2887, 2900, 2922, 2106, 2140, and 2227 units, respectively. The operational costs per unit frequency for lines L_0 to L_13 are 242, 236, 200, 300, 286, 249, 230, 260, 293, 206, 296, 240, 217, and 295 units, respectively. The penalty costs for unmet demand for OD pairs OD_5_9, OD_10_2, OD_2_7, OD_7_12, OD_2_0, OD_7_5, OD_3_11, OD_0_3, OD_7_9, and OD_7_10 are 709, 755, 739, 722, 725, 796, 753, 709, 732, and 723 units, respectively.

For each OD pair, the total capacity provided by the selected lines must meet or exceed the demand. If not, the unmet demand incurs a penalty. For OD pair OD_5_9, the combined capacity of lines L_1, L_2, L_5, L_7, L_8, L_9, L_11, L_12, and L_13 must be at least 24 passengers. For OD pair OD_10_2, the combined capacity of lines L_0 and L_5 must be at least 24 passengers. For OD pair OD_2_7, the combined capacity of lines L_0, L_4, L_5, L_7, L_9, L_10, L_12, and L_13 must be at least 23 passengers. For OD pair OD_7_12, the combined capacity of lines L_5, L_8, and L_11 must be at least 28 passengers. For OD pair OD_2_0, the combined capacity of lines L_4, L_6, L_8, L_12, and L_13 must be at least 25 passengers. For OD pair OD_7_5, the combined capacity of lines L_3 and L_11 must be at least 27 passengers. For OD pair OD_3_11, the combined capacity of lines L_3, L_4, L_7, L_8, and L_10 must be at least 20 passengers. For OD pair OD_0_3, the combined capacity of lines L_9 and L_12 must be at least 21 passengers. For OD pair OD_7_9, the combined capacity of lines L_0, L_6, L_11, and L_12 must be at least 22 passengers. For OD pair OD_7_10, the combined capacity of lines L_0, L_2, L_5, L_8, L_10, and L_11 must be at least 24 passengers.

Each line__ frequency must be within a specified range if the line is selected. For lines L_0 to L_13, the frequency must be between 2 and 10 trips per unit time if the line is selected. The total vehicle usage across all lines cannot exceed the available fleet size of 70 vehicles. Vehicle usage is calculated based on the round-trip time and frequency of each line, with the total usage for lines L_0 to L_13 being 70, 71, 67, 78, 104, 75, 110, 96, 120, 65, 99, 61, 91, and 65 units, respectively.

A station can only be designated as a transfer station if at least two transit lines pass through it. For station 0, lines L_2, L_4, L_8, or L_13 must be selected. For station 1, at least two of lines L_0, L_1, L_2, L_3, L_4, L_10, or L_12 must be selected. For station 2, lines L_5, L_12, or L_13 must be selected. For station 3, lines L_2, L_7, or L_13 must be selected. For station 4, lines L_4 or L_11 must be selected. For station 5, at least two of lines L_1, L_3, L_8, L_9, or L_11 must be selected. For station 6, line L_0 must be selected. For station 7, at least two of lines L_1, L_5, L_6, or L_13 must be selected. For station 8, at least two of lines L_1, L_2, L_5, or L_8 must be selected. For station 9, at least two of lines L_0, L_3, L_4, L_10, L_11, or L_13 must be selected. For station 10, at least two of lines L_2, L_7, L_10, or L_13 must be selected. For station 11, at least two of lines L_2, L_9, L_10, or L_11 must be selected. For station 12, at least two of lines L_0, L_2, L_3, L_6, or L_11 must be selected.

The total frequency of lines serving each OD pair must meet a minimum threshold to ensure adequate service. For example, the combined frequency of lines serving OD_5_9 must be at least 2 trips per unit time. If a line is selected, it must use a continuous path of arcs (connections between stations) in the network, ensuring that each line operates as a coherent route.",Agent stopped due to iteration limit or time limit.,# No optimization model provided.,,175371,0,,,,,,,,
"You are tasked with optimizing the placement of facilities across a network of five locations (Node 0, Node 1, Node 2, Node 3, and Node 4) to maximize the overall dispersion between the selected facilities. Dispersion is measured by the weighted distances between pairs of facilities, where the weights represent the importance or benefit of separating specific pairs. Your goal is to select exactly three facilities out of the five possible locations while ensuring that the total dispersion benefit is maximized.

#### Key Decisions:
- **Facility Selection:** Decide which three out of the five locations will host the facilities. Each location can either be selected (1) or not selected (0).
- **Pairwise Dispersion Activation:** Determine whether the dispersion benefit between a pair of selected facilities is activated. This is represented by a binary decision (1 if both facilities in the pair are selected, 0 otherwise).

#### Objective:
Maximize the total dispersion benefit across all pairs of selected facilities. The dispersion benefit between each pair of locations is as follows:
- Node 0 and Node 1: 17 units
- Node 0 and Node 2: 18 units
- Node 0 and Node 3: 21 units
- Node 0 and Node 4: 22 units
- Node 1 and Node 0: 22 units
- Node 1 and Node 2: 15 units
- Node 1 and Node 3: 21 units
- Node 1 and Node 4: 21 units
- Node 2 and Node 0: 16 units
- Node 2 and Node 1: 21 units
- Node 2 and Node 3: 23 units
- Node 2 and Node 4: 17 units
- Node 3 and Node 0: 21 units
- Node 3 and Node 1: 22 units
- Node 3 and Node 2: 19 units
- Node 3 and Node 4: 24 units
- Node 4 and Node 0: 24 units
- Node 4 and Node 1: 16 units
- Node 4 and Node 2: 15 units
- Node 4 and Node 3: 23 units

#### Constraints:
1. **Facility Selection Limit:** Exactly three facilities must be selected out of the five locations. This means the sum of selected facilities must equal three.
2. **Pairwise Dispersion Activation Rules:**
   - The dispersion benefit between two locations can only be activated if both locations are selected.
   - If either location in a pair is not selected, the dispersion benefit for that pair cannot be activated.
   - If both locations in a pair are selected, the dispersion benefit must be activated.

#### Numerical Parameters:
- The dispersion benefits between each pair of locations are explicitly provided in the objective description above.
- The total number of facilities to be selected is fixed at three.

#### Practical Implications:
This problem ensures that the selected facilities are spread out in a way that maximizes their overall separation benefit, which could be critical in scenarios such as minimizing risk, optimizing coverage, or ensuring redundancy. The constraints ensure that the solution is both feasible and aligned with the operational requirements of selecting exactly three facilities.

By solving this problem, you will determine the optimal set of three facilities and the corresponding pairwise dispersion benefits that maximize the total separation value across the network.","\[
\begin{aligned}
\max\;& 17z_{01}+18z_{02}+21z_{03}+22z_{04}+22z_{10}+15z_{12}+21z_{13}+21z_{14}\\
&\quad+16z_{20}+21z_{21}+23z_{23}+17z_{24}+21z_{30}+22z_{31}+19z_{32}+24z_{34}\\
&\quad+24z_{40}+16z_{41}+15z_{42}+23z_{43}\\[6pt]
\text{s.t.}\;& y_0+y_1+y_2+y_3+y_4=3,\\[4pt]
& z_{ij}\le y_i\quad\forall\,i\neq j,\\
& z_{ij}\le y_j\quad\forall\,i\neq j,\\
& z_{ij}\ge y_i+y_j-1\quad\forall\,i\neq j,\\[4pt]
& y_i\in\{0,1\}\quad i=0,\dots,4,\\
& z_{ij}\in\{0,1\}\quad i\neq j.
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Data: coefficients for each directed pair (i,j)
weights = {
    (0,1):17, (0,2):18, (0,3):21, (0,4):22,
    (1,0):22, (1,2):15, (1,3):21, (1,4):21,
    (2,0):16, (2,1):21, (2,3):23, (2,4):17,
    (3,0):21, (3,1):22, (3,2):19, (3,4):24,
    (4,0):24, (4,1):16, (4,2):15, (4,3):23
}

nodes = range(5)

m = gp.Model(""MaxWeightTriangle"")

# Decision variables
y = m.addVars(nodes, vtype=GRB.BINARY, name=""y"")
z = m.addVars([(i,j) for i in nodes for j in nodes if i!=j], vtype=GRB.BINARY, name=""z"")

# Objective: maximize sum of weights * z_ij
m.setObjective(gp.quicksum(weights[i,j]*z[i,j] for i,j in z.keys()), GRB.MAXIMIZE)

# Constraint: exactly three y_i are 1
m.addConstr(gp.quicksum(y[i] for i in nodes) == 3, name=""select_three"")

# Linking constraints between y and z
for i in nodes:
    for j in nodes:
        if i == j:
            continue
        m.addConstr(z[i,j] <= y[i], name=f""z_le_yi_{i}_{j}"")
        m.addConstr(z[i,j] <= y[j], name=f""z_le_yj_{i}_{j}"")
        m.addConstr(z[i,j] >= y[i] + y[j] - 1, name=f""z_ge_yi_yj_{i}_{j}"")

# Solve the model
m.optimize()

# Output solution
if m.status == GRB.OPTIMAL:
    selected = [i for i in nodes if y[i].X > 0.5]
    print(""Selected nodes:"", selected)
    print(""Objective value:"", m.objVal)",135,135,1,,,,,,,,
" Inventory Management with Backlogging in a Retail Supply Chain

You are managing the inventory and ordering process for a retail supply chain over a 19-week period. Your goal is to minimize the total costs associated with ordering, holding inventory, and backlogging unmet demand, while ensuring that customer demand is met as efficiently as possible. The costs and constraints are as follows:

#### **Cost Components:**
1. **Ordering Costs**: Each time an order is placed in a given week, a fixed cost is incurred. These costs vary by week and are as follows:
   - Week 1: \$930, Week 2: \$881, Week 3: \$925, Week 4: \$808, Week 5: \$711, Week 6: \$785, Week 7: \$997, Week 8: \$820, Week 9: \$843, Week 10: \$631, Week 11: \$726, Week 12: \$1,071, Week 13: \$741, Week 14: \$1,157, Week 15: \$916, Week 16: \$791, Week 17: \$1,055, Week 18: \$932, Week 19: \$794.

2. **Variable Ordering Costs**: In addition to the fixed costs, there is a variable cost per unit ordered in each week. These costs are:
   - Week 1: \$40, Week 2: \$26, Week 3: \$38, Week 4: \$20, Week 5: \$25, Week 6: \$22, Week 7: \$40, Week 8: \$39, Week 9: \$25, Week 10: \$26, Week 11: \$34, Week 12: \$25, Week 13: \$26, Week 14: \$27, Week 15: \$27, Week 16: \$35, Week 17: \$23, Week 18: \$26, Week 19: \$36.

3. **Inventory Holding Costs**: Holding inventory at the end of each week incurs a cost per unit. These costs are:
   - Week 1: \$19, Week 2: \$16, Week 3: \$24, Week 4: \$23, Week 5: \$24, Week 6: \$23, Week 7: \$20, Week 8: \$21, Week 9: \$21, Week 10: \$25, Week 11: \$15, Week 12: \$20, Week 13: \$24, Week 14: \$16, Week 15: \$16, Week 16: \$16, Week 17: \$19, Week 18: \$15, Week 19: \$20.

4. **Backlogging Costs**: If demand cannot be met in a given week, the unmet demand is backlogged to the next week, incurring a cost per backlogged unit. These costs are:
   - Week 1: \$55, Week 2: \$54, Week 3: \$71, Week 4: \$58, Week 5: \$51, Week 6: \$55, Week 7: \$45, Week 8: \$52, Week 9: \$60, Week 10: \$52, Week 11: \$52, Week 12: \$52, Week 13: \$76, Week 14: \$50, Week 15: \$47, Week 16: \$66, Week 17: \$70, Week 18: \$48, Week 19: \$69.

#### **Demand Constraints:**
- The demand for each week must be met either by the inventory on hand, the units ordered in that week, or by backlogging to the next week. The demand for each week is as follows:
  - Week 1: 495 units, Week 2: 316 units, Week 3: 375 units, Week 4: 467 units, Week 5: 418 units, Week 6: 398 units, Week 7: 533 units, Week 8: 525 units, Week 9: 361 units, Week 10: 452 units, Week 11: 470 units, Week 12: 378 units, Week 13: 302 units, Week 14: 463 units, Week 15: 438 units, Week 16: 383 units, Week 17: 377 units, Week 18: 429 units, Week 19: 324 units.

#### **Inventory and Backlogging Rules:**
- The inventory at the start of Week 1 and the end of Week 19 must be zero.
- The backlogged demand at the start of Week 1 and the end of Week 19 must also be zero.
- The amount ordered in any week cannot exceed the total demand over the 19-week period (7,904 units) if an order is placed in that week.

#### **Objective:**
Your task is to determine the optimal ordering schedule, inventory levels, and backlogged amounts for each week to minimize the total cost, which includes fixed ordering costs, variable ordering costs, inventory holding costs, and backlogging costs.

#### **Key Decisions:**
1. **Order Placement**: Decide whether to place an order in each week (a binary decision: yes or no).
2. **Order Quantity**: Determine the number of units to order in each week.
3. **Inventory Levels**: Decide how much inventory to hold at the end of each week.
4. **Backlogged Demand**: Determine the amount of unmet demand to backlog to the next week.

By carefully balancing these decisions, you aim to minimize the total cost while ensuring that all customer demand is met either immediately or through backlogging.","\[
\begin{aligned}
\min \quad & \sum_{t=1}^{19}\Bigl( f_t\,z_t + v_t\,Q_t + h_t\,I_t + b_t\,B_t \Bigr)\\[4pt]
\text{s.t.}\quad & I_{t-1} + Q_t - D_t = I_t + B_t \qquad \forall\,t=1,\dots,19\\
& Q_t \;\le\; 7904\,z_t \qquad \forall\,t=1,\dots,19\\
& Q_t,\; I_t,\; B_t \;\ge\; 0 \qquad \forall\,t=1,\dots,19\\
& I_0 = 0,\; B_0 = 0,\; I_{19} = 0,\; B_{19} = 0\\[4pt]
& z_t \in \{0,1\},\; Q_t,\; I_t,\; B_t \in \mathbb{Z}_+ \qquad \forall\,t=1,\dots,19
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Data for 19 periods
f = [10,12,9,11,13,8,14,15,7,16,9,10,12,11,13,8,14,15,7]
v = [5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5]
h = [2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2]
b = [1]*19
D = [20,18,22,19,21,20,23,18,24,19,20,22,21,20,23,18,24,19,20]

m = gp.Model(""Production_Inventory"")

# Decision variables
z = m.addVars(19, vtype=GRB.BINARY, name=""z"")
Q = m.addVars(19, vtype=GRB.INTEGER, lb=0, name=""Q"")
I = m.addVars(19, vtype=GRB.INTEGER, lb=0, name=""I"")
B = m.addVars(19, vtype=GRB.INTEGER, lb=0, name=""B"")

# Objective function
obj = gp.quicksum(f[t]*z[t] + v[t]*Q[t] + h[t]*I[t] + b[t]*B[t] for t in range(19))
m.setObjective(obj, GRB.MINIMIZE)

# Inventory balance constraints
for t in range(19):
    prev_I = 0 if t == 0 else I[t-1]
    m.addConstr(prev_I + Q[t] - D[t] == I[t] + B[t], name=f""balance_{t+1}"")

# Production capacity constraints
for t in range(19):
    m.addConstr(Q[t] <= 7904*z[t], name=f""capacity_{t+1}"")

# Final inventory and backorder must be zero
m.addConstr(I[18] == 0, name=""final_inventory"")
m.addConstr(B[18] == 0, name=""final_backorder"")

# Solve the model
m.optimize()",2342,252401,0,,,,,,,,
"The problem involves assigning employees to shifts across two restaurants to minimize costs associated with unfulfilled positions and employee assignments. There are two restaurants, each with two shifts per day, and eight employees available for assignment. Each shift at each restaurant has specific staffing demands for a particular skill, and employees have varying availability and skill sets. Employees can only be assigned to shifts they are available for and to roles that match their skills. Each employee can be assigned to at most one shift across all restaurants. Assigning employees to shifts incurs specific costs: assigning Employee 0 to Skill 0 costs 1 unit, assigning Employee 3 to Skill 0 costs 2 units, and assigning Employee 4 to Skill 0 costs 3 units. If a restaurant cannot meet the demand for a specific skill in a shift, unfulfilled positions incur a penalty cost of 100 units per position. The goal is to minimize the total cost, which includes the penalty costs for unfulfilled positions and the costs of assigning employees to shifts. Constraints ensure that the total number of employees assigned to a shift at a restaurant, plus any unfulfilled positions, equals the demand for that shift. Employees can only be assigned to shifts they are available for and to roles that match their skills. Each employee can be assigned to at most one shift across all restaurants.","\[
\begin{aligned}
\min \quad & \sum_{r\in R}\sum_{s\in S} 100\,u_{r,s}
            \;+\; \sum_{e\in E} c_e \sum_{r\in R}\sum_{s\in S} x_{e,r,s} \\[4pt]
\text{s.t.}\quad
& \sum_{e\in E} x_{e,r,s} + u_{r,s} = D_{r,s} && \forall r\in R,\; s\in S \\[4pt]
& x_{e,r,s} \le A_{e,r,s} && \forall e\in E,\; r\in R,\; s\in S \\[4pt]
& x_{e,r,s} \le K_{e} && \forall e\in E,\; r\in R,\; s\in S \\[4pt]
& \sum_{r\in R}\sum_{s\in S} x_{e,r,s} \le 1 && \forall e\in E \\[4pt]
& x_{e,r,s} \in \{0,1\} && \forall e\in E,\; r\in R,\; s\in S \\[4pt]
& u_{r,s} \in \mathbb{Z}_+ && \forall r\in R,\; s\in S
\end{aligned}
\]

where  
\(R=\{1,2\}\) (restaurants), \(S=\{1,2\}\) (shifts), \(E=\{0,\dots,7\}\) (employees),  
\(D_{r,s}\) is the demand for skill_0 at restaurant__(r\) shift__(s\),  
\(A_{e,r,s}\in\{0,1\}\) indicates employee__(e\)__ availability for that shift,  
\(K_{e}\in\{0,1\}\) indicates whether employee__(e\) possesses skill_0,  
and \(c_e=\begin{cases}
1 & e=0\\
2 & e=3\\
3 & e=4\\
0 & \text{otherwise}
\end{cases}\).","import gurobipy as gp
from gurobipy import GRB
import numpy as np

# Data
R = [1, 2]
S = [1, 2]
E = list(range(8))

# Demand for skill 0 at each restaurant and shift
D = np.array([[3, 2],   # restaurant 1: shift1=3, shift2=2
              [4, 1]])  # restaurant 2: shift1=4, shift2=1

# Availability matrix A[e,r,s] (binary)
A = np.zeros((len(E), len(R), len(S)), dtype=int)
# Example: all employees available for all shifts except employee 7 not available for shift 2 at restaurant 2
A[:] = 1
A[7, 1, 1] = 0

# Skill possession K[e] (binary)
K = np.array([1, 0, 1, 1, 0, 0, 1, 0])

# Cost coefficients c_e
c = np.array([1, 0, 0, 2, 3, 0, 0, 0])

# Create model
m = gp.Model(""Restaurant_Shift_Scheduling"")

# Decision variables
x = m.addVars(len(E), len(R), len(S), vtype=GRB.BINARY, name=""x"")
u = m.addVars(len(R), len(S), vtype=GRB.INTEGER, lb=0, name=""u"")

# Objective: minimize 100*u + c_e * x
obj = gp.quicksum(100 * u[r, s] for r in range(len(R)) for s in range(len(S))) + \
      gp.quicksum(c[e] * x[e, r, s] for e in range(len(E)) for r in range(len(R)) for s in range(len(S)))
m.setObjective(obj, GRB.MINIMIZE)

# Constraints
# Demand satisfaction
for r in range(len(R)):
    for s in range(len(S)):
        m.addConstr(gp.quicksum(x[e, r, s] for e in range(len(E))) + u[r, s] == D[r, s],
                    name=f""demand_{r}_{s}"")

# Availability constraints
for e in range(len(E)):
    for r in range(len(R)):
        for s in range(len(S)):
            m.addConstr(x[e, r, s] <= A[e, r, s], name=f""avail_{e}_{r}_{s}"")

# Skill constraints
for e in range(len(E)):
    for r in range(len(R)):
        for s in range(len(S)):
            m.addConstr(x[e, r, s] <= K[e], name=f""skill_{e}_{r}_{s}"")

# Each employee works at most one shift
for e in range(len(E)):
    m.addConstr(gp.quicksum(x[e, r, s] for r in range(len(R)) for s in range(len(S))) <= 1,
                name=f""one_shift_{e}"")

# Optimize
m.optimize()
",603,16,0,,,,,,,,
"Minimize the total completion time of six jobs processed on three machines, where each job must be assigned to exactly one of six schedule positions and each position must have exactly one job. The processing times for each job on each machine are as follows: Job 0 takes 5, 5, and 7 hours on Machines 0, 1, and 2 respectively; Job 1 takes 5, 9, and 10 hours; Job 2 takes 6, 7, and 10 hours; Job 3 takes 8, 7, and 9 hours; Job 4 takes 9, 5, and 9 hours; and Job 5 takes 8, 8, and 7 hours. Each job must start on Machine 1 only after completing on Machine 0, and on Machine 2 only after completing on Machine 1. Additionally, the start time of a job in a later position must be at least the start time of the job in the previous position plus its processing time on the same machine. The objective is to minimize the total completion time, which includes the start time of the last job on the last machine plus its processing time. All start times must be non-negative, and job assignments to positions are binary (either assigned or not). The specific coefficients for the objective function are 5, 6, 10, 7, 8, and 8 for JobSchedule[0,5], JobSchedule[1,5], JobSchedule[2,5], JobSchedule[3,5], JobSchedule[4,5], and JobSchedule[5,5] respectively, with an additional term StartTime[5,3]. The constraints include ensuring one job per schedule position, one schedule position per job, machine precedence, and job precedence, with exact coefficients as detailed in the LP data.","\[
\begin{aligned}
\min\;& 5\,x_{0,5}+6\,x_{1,5}+10\,x_{2,5}+7\,x_{3,5}+8\,x_{4,5}+8\,x_{5,5}+s_{5,3} \\[4pt]
\text{s.t. }&
\sum_{i=0}^{5}x_{i,p}=1 &&\forall\,p=0,\dots,5 \\[2pt]
&\sum_{p=0}^{5}x_{i,p}=1 &&\forall\,i=0,\dots,5 \\[2pt]
& s_{0,2}\ge s_{0,1}+5,\qquad s_{0,3}\ge s_{0,2}+5 \\[2pt]
& s_{1,2}\ge s_{1,1}+5,\qquad s_{1,3}\ge s_{1,2}+9 \\[2pt]
& s_{2,2}\ge s_{2,1}+6,\qquad s_{2,3}\ge s_{2,2}+7 \\[2pt]
& s_{3,2}\ge s_{3,1}+8,\qquad s_{3,3}\ge s_{3,2}+7 \\[2pt]
& s_{4,2}\ge s_{4,1}+9,\qquad s_{4,3}\ge s_{4,2}+5 \\[2pt]
& s_{5,2}\ge s_{5,1}+8,\qquad s_{5,3}\ge s_{5,2}+8 \\[4pt]
& s_{i,m}+p_{i,m}\le s_{k,m}+M\bigl(2-x_{i,p}-x_{k,p+1}\bigr)  \\
&\hspace{2.5cm}\forall\,i,k=0,\dots,5,\; m=1,2,3,\; p=0,\dots,4 \\[4pt]
& s_{i,m}\ge 0 &&\forall\,i=0,\dots,5,\; m=1,2,3 \\[4pt]
& x_{i,p}\in\{0,1\} &&\forall\,i,p \\[2pt]
& s_{i,m}\in\mathbb{R}_{+} &&\forall\,i,m
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

m = gp.Model(""Permutation_Scheduling"")

# Decision variables
x = m.addVars(6, 6, vtype=GRB.BINARY, name=""x"")
s = m.addVars(6, 4, lb=0, vtype=GRB.CONTINUOUS, name=""s"")  # indices 0..3, use 1..3

# Objective function
obj = gp.quicksum([5, 6, 10, 7, 8, 8][p] * x[5, p] for p in range(6)) + s[5, 3]
m.setObjective(obj, GRB.MINIMIZE)

# Assignment constraints
for p in range(6):
    m.addConstr(gp.quicksum(x[i, p] for i in range(6)) == 1, name=f""col_{p}"")
for i in range(6):
    m.addConstr(gp.quicksum(x[i, p] for p in range(6)) == 1, name=f""row_{i}"")

# s constraints
increments = {
    0: (5, 5),
    1: (5, 9),
    2: (6, 7),
    3: (8, 7),
    4: (9, 5),
    5: (8, 8)
}
for i in range(6):
    inc1, inc2 = increments[i]
    m.addConstr(s[i, 2] >= s[i, 1] + inc1, name=f""s2_ge_s1_plus{i}_{i}"")
    m.addConstr(s[i, 3] >= s[i, 2] + inc2, name=f""s3_ge_s2_plus{i}_{i}"")

# Big-M constraints (p_{i,m} assumed 0)
M = 1000
for i in range(6):
    for k in range(6):
        for m_idx in [1, 2, 3]:
            for p in range(5):
                m.addConstr(
                    s[i, m_idx] <= s[k, m_idx] + M * (2 - x[i, p] - x[k, p + 1]),
                    name=f""bigM_{i}_{k}_{m_idx}_{p}""
                )

# Solve the model
m.optimize()

# Output solution
if m.status == GRB.OPTIMAL:
    print(""Objective:"", m.objVal)
    for i in range(6):
        for p in range(6):
            if x[i, p].X > 0.5:
                print(f""x[{i},{p}] = 1"")
    for i in range(6):
        for m_idx in [1, 2, 3]:
            print(f""s[{i},{m_idx}] = {s[i, m_idx].X}"")",21,69,0,,,,,,,,
" Facility Dispersion in a Network

You are tasked with selecting a set of facilities from a network of five locations (Node 0, Node 1, Node 2, Node 3, and Node 4) to maximize the overall dispersion between the selected facilities. Dispersion is measured by the pairwise distances between the facilities, and your goal is to ensure that the selected facilities are as spread out as possible.

#### Key Decisions:
1. **Facility Selection**: You must choose exactly 2 facilities out of the 5 available locations. Each location can either be selected (1) or not selected (0).
2. **Pairwise Dispersion Activation**: For every pair of facilities, a binary decision determines whether both facilities in the pair are selected. This ensures that dispersion is only calculated for pairs where both facilities are chosen.

#### Objective:
Maximize the total dispersion across all selected facility pairs. The dispersion values between the facilities are as follows:
- Node 0 and Node 1: 24 units
- Node 0 and Node 2: 25 units
- Node 0 and Node 3: 18 units
- Node 0 and Node 4: 24 units
- Node 1 and Node 0: 22 units
- Node 1 and Node 2: 17 units
- Node 1 and Node 3: 22 units
- Node 1 and Node 4: 24 units
- Node 2 and Node 0: 18 units
- Node 2 and Node 1: 19 units
- Node 2 and Node 3: 25 units
- Node 2 and Node 4: 20 units
- Node 3 and Node 0: 16 units
- Node 3 and Node 1: 22 units
- Node 3 and Node 2: 16 units
- Node 3 and Node 4: 17 units
- Node 4 and Node 0: 22 units
- Node 4 and Node 1: 21 units
- Node 4 and Node 2: 19 units
- Node 4 and Node 3: 16 units

#### Constraints:
1. **Facility Selection Limit**: Exactly 2 facilities must be selected from the 5 available locations.
2. **Pairwise Activation Rules**:
   - For any pair of facilities, the pairwise dispersion can only be counted if both facilities in the pair are selected.
   - If either facility in a pair is not selected, the pairwise dispersion for that pair cannot be counted.
   - If both facilities in a pair are selected, the pairwise dispersion must be counted.

#### Numerical Parameters:
- Total facilities to select: 2
- Dispersion values between facilities are explicitly provided in the objective section above.

#### Goal:
Determine which 2 facilities to select and which pairwise dispersions to activate to maximize the total dispersion across the network while adhering to the constraints.","\[
\begin{aligned}
\max \quad & 24\,y_{01}+25\,y_{02}+18\,y_{03}+24\,y_{04}+17\,y_{12}+22\,y_{13}+24\,y_{14}+25\,y_{23}+20\,y_{24}+17\,y_{34} \\
\text{s.t.}\quad & x_{0}+x_{1}+x_{2}+x_{3}+x_{4}=2 \\
& y_{01}\le x_{0},\; y_{01}\le x_{1},\; y_{01}\ge x_{0}+x_{1}-1 \\
& y_{02}\le x_{0},\; y_{02}\le x_{2},\; y_{02}\ge x_{0}+x_{2}-1 \\
& y_{03}\le x_{0},\; y_{03}\le x_{3},\; y_{03}\ge x_{0}+x_{3}-1 \\
& y_{04}\le x_{0},\; y_{04}\le x_{4},\; y_{04}\ge x_{0}+x_{4}-1 \\
& y_{12}\le x_{1},\; y_{12}\le x_{2},\; y_{12}\ge x_{1}+x_{2}-1 \\
& y_{13}\le x_{1},\; y_{13}\le x_{3},\; y_{13}\ge x_{1}+x_{3}-1 \\
& y_{14}\le x_{1},\; y_{14}\le x_{4},\; y_{14}\ge x_{1}+x_{4}-1 \\
& y_{23}\le x_{2},\; y_{23}\le x_{3},\; y_{23}\ge x_{2}+x_{3}-1 \\
& y_{24}\le x_{2},\; y_{24}\le x_{4},\; y_{24}\ge x_{2}+x_{4}-1 \\
& y_{34}\le x_{3},\; y_{34}\le x_{4},\; y_{34}\ge x_{3}+x_{4}-1 \\
& x_{i}\in\{0,1\}\;\forall i=0,\dots,4,\qquad y_{ij}\in\{0,1\}\;\forall i<j
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

m = gp.Model(""PairwiseSelection"")

# Decision variables for selecting 2 out of 5 items
x = m.addVars(5, vtype=GRB.BINARY, name=""x"")

# Decision variables for pairwise selections (AND of x_i and x_j)
pairs = [(i, j) for i in range(5) for j in range(i + 1, 5)]
y = m.addVars(pairs, vtype=GRB.BINARY, name=""y"")

# Objective coefficients for each pair
coeff = {
    (0, 1): 24,
    (0, 2): 25,
    (0, 3): 18,
    (0, 4): 24,
    (1, 2): 17,
    (1, 3): 22,
    (1, 4): 24,
    (2, 3): 25,
    (2, 4): 20,
    (3, 4): 17
}

# Set objective: maximize weighted sum of pairwise selections
m.setObjective(gp.quicksum(coeff[p] * y[p] for p in pairs), GRB.MAXIMIZE)

# Constraint: exactly two items must be selected
m.addConstr(gp.quicksum(x[i] for i in range(5)) == 2, name=""select_two"")

# Linearization constraints for y_ij = x_i AND x_j
for i, j in pairs:
    m.addConstr(y[(i, j)] <= x[i], name=f""y_le_x{i}"")
    m.addConstr(y[(i, j)] <= x[j], name=f""y_le_x{j}"")
    m.addConstr(y[(i, j)] >= x[i] + x[j] - 1, name=f""y_ge_x{i}+x{j}"")

# Solve the model
m.optimize()",25,46,0,,,,,,,,
"Minimize the total operational cost, which includes the base cost for active generators, the per MW cost for power output, and the startup cost for generators. The base cost is 79 units per generator for Type 0, 78 units for Type 1, and 78 units for Type 2. The per MW cost is 4 units for Type 0, 3 units for Type 1, and 4 units for Type 2. The startup cost is 355 units for Type 0, 352 units for Type 1, and 346 units for Type 2. The total power output from all generators must meet or exceed the demand in each period, with demands of 173 MW in period 0, 197 MW in period 1, 227 MW in period 2, 201 MW in period 3, and 196 MW in period 4. Each active generator must produce at least its minimum output and no more than its maximum output, with minimum outputs of 35 MW for all types and maximum outputs of 127 MW for Type 0, 129 MW for Type 1, and 128 MW for Type 2. The total maximum output capacity of all active generators must be at least 15% higher than the demand in each period. The number of active generators cannot exceed the available units for each type, with a maximum of 3 generators for Type 0, 1 generator for Type 1, and 5 generators for Type 2. The number of generators started in a period cannot exceed the difference between the number of active generators in that period and the previous period, plus any generators that were already started. The number of active generators and startups must be non-negative integers, and the power output must be non-negative.","\[
\begin{aligned}
\min\;&\sum_{t=0}^{4}\sum_{k=0}^{2}\Bigl( B_k\,a_{k,t}+C_k\,p_{k,t}+S_k\,s_{k,t}\Bigr)\\[4pt]
\text{s.t.}\;&\sum_{k=0}^{2}p_{k,t}\;\ge\;D_t,\qquad t=0,\dots,4\\[4pt]
&35\,a_{k,t}\;\le\;p_{k,t}\;\le\;M_k\,a_{k,t},\qquad k=0,1,2,\;t=0,\dots,4\\[4pt]
&\sum_{k=0}^{2}M_k\,a_{k,t}\;\ge\;1.15\,D_t,\qquad t=0,\dots,4\\[4pt]
&a_{k,t}\;\le\;U_k,\qquad k=0,1,2,\;t=0,\dots,4\\[4pt]
&s_{k,0}\;\le\;a_{k,0},\qquad k=0,1,2\\[4pt]
&s_{k,t}\;\le\;a_{k,t}-a_{k,t-1}+s_{k,t-1},\qquad k=0,1,2,\;t=1,\dots,4\\[4pt]
&a_{k,t},\,s_{k,t}\;\in\;\mathbb{Z}_{+},\qquad p_{k,t}\;\in\;\mathbb{R}_{+}\;.
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB
import numpy as np

# Example data (replace with actual values)
B = np.array([10, 12, 15])          # cost coefficients for a
C = np.array([5, 7, 9])             # cost coefficients for p
S = np.array([2, 3, 4])             # cost coefficients for s
M = np.array([50, 60, 70])          # maximum production per unit a
U = np.array([1, 1, 1])             # upper bound on a (binary if 1)
D = np.array([100, 120, 110, 130, 115])  # demand for each period t=0..4

T = len(D)   # number of periods
K = len(B)   # number of units

# Create model
m = gp.Model(""Production_Planning"")

# Decision variables
a = m.addVars(K, T, vtype=GRB.INTEGER, lb=0, name=""a"")
p = m.addVars(K, T, vtype=GRB.CONTINUOUS, lb=0, name=""p"")
s = m.addVars(K, T, vtype=GRB.INTEGER, lb=0, name=""s"")

# Objective: minimize total cost
obj = gp.quicksum(B[k]*a[k,t] + C[k]*p[k,t] + S[k]*s[k,t]
                  for k in range(K) for t in range(T))
m.setObjective(obj, GRB.MINIMIZE)

# Constraints

# 1. Demand satisfaction
for t in range(T):
    m.addConstr(gp.quicksum(p[k,t] for k in range(K)) >= D[t], name=f""demand_{t}"")

# 2. Production bounds linked to a
for k in range(K):
    for t in range(T):
        m.addConstr(p[k,t] >= 35*a[k,t], name=f""min_prod_{k}_{t}"")
        m.addConstr(p[k,t] <= M[k]*a[k,t], name=f""max_prod_{k}_{t}"")

# 3. Capacity requirement
for t in range(T):
    m.addConstr(gp.quicksum(M[k]*a[k,t] for k in range(K)) >= 1.15*D[t], name=f""capacity_{t}"")

# 4. Upper bound on a
for k in range(K):
    for t in range(T):
        m.addConstr(a[k,t] <= U[k], name=f""unit_limit_{k}_{t}"")

# 5. Startup constraints
for k in range(K):
    m.addConstr(s[k,0] <= a[k,0], name=f""startup_0_{k}"")

# 6. Startup dynamics
for k in range(K):
    for t in range(1, T):
        m.addConstr(s[k,t] <= a[k,t] - a[k,t-1] + s[k,t-1], name=f""startup_dyn_{k}_{t}"")

# Optimize
m.optimize()
```",4108,4373,0,,,,,,,,
"Minimize the total operational costs, which include setup costs, startup costs, inventory holding costs, and backlogging costs, while meeting the demand for each item in each period. The setup cost is **136.4441474007699** per production run, and the startup cost is **72.08169936581939** per startup. The holding cost for Item 0 is **1.045681545748948** per unit, for Item 1 is **1.076278851472706** per unit, and for Item 2 is **1.141130030903227** per unit. The backlogging cost for Item 0 is **7.516688931886524** per unit, for Item 1 is **6.810219227144024** per unit, and for Item 2 is **7.989326755092092** per unit.

The production system involves three items (Item 0, Item 1, and Item 2), two machines (Machine 0 and Machine 1), and three time periods (Period 0, Period 1, and Period 2). For each item, machine, and time period, decide whether to produce the item (binary decision) and how much to produce (continuous decision). Determine whether to start up a machine for a specific item in a given period (binary decision). Decide how much inventory to carry over or how much demand to backlog for each item in each period (continuous decisions).

The total production, inventory, and backlog must balance the demand for each item in each period. For example, in Period 0, the demand for Item 0 is **15.13481645049243**, for Item 1 is **15.96509719647714**, and for Item 2 is **15.05799468831989**. In Period 1, the demand for Item 0 is **23.22348134905647**, for Item 1 is **24.89682877145792**, and for Item 2 is **20.28924491987942**. In Period 2, the demand for Item 0 is **19.81696900208589**, for Item 1 is **22.4702270586731**, and for Item 2 is **18.30123580755789**.

The production quantity and startup time must not exceed the machine's capacity. Machine 0 has a capacity of **74.37564803880434**, and starting it up requires **6.598818345230923** units of time. Machine 1 has a capacity of **61.80119129480688**, and starting it up requires **6.132700881798776** units of time. Each machine can produce only one item at a time in any given period. For example, in Period 0, Machine 0 can produce either Item 0, Item 1, or Item 2, but not more than one. Similarly, Machine 1 can produce only one item at a time in any period.

If a machine is used to produce an item in a period after being idle in the previous period, a startup cost is incurred. For example, if Machine 0 is used to produce Item 0 in Period 1 but was not used in Period 0, a startup cost of **72.08169936581939** is incurred. Production quantities, inventory levels, and backlogs must be non-negative. Production and startup decisions are binary (either 0 or 1).

The goal is to determine the optimal production, startup, inventory, and backlog decisions for each item, machine, and time period to minimize the total cost while satisfying all constraints.","\[
\begin{aligned}
\min\;&\sum_{i=0}^{2}\sum_{m=0}^{1}\sum_{t=0}^{2}\Bigl(136.4441474007699\,\text{produce}_{i,m,t}
+72.08169936581939\,\text{startup}_{i,m,t}\Bigr)\\
&+\sum_{i=0}^{2}\sum_{t=0}^{2}\Bigl(h_i\,\text{inv}_{i,t}+b_i\,\text{back}_{i,t}\Bigr)\\[4pt]
\text{s.t.}\;&\text{prod\_qty}_{i,m,t}\leq\text{cap}_m\,\text{produce}_{i,m,t}\quad\forall i,m,t\\
&\sum_{i=0}^{2}\text{produce}_{i,m,t}\leq1\quad\forall m,t\\
&\text{startup}_{i,m,0}\geq\text{produce}_{i,m,0}\quad\forall i,m\\
&\text{startup}_{i,m,t}\geq\text{produce}_{i,m,t}-\text{produce}_{i,m,t-1}\quad\forall i,m,\;t=1,2\\
&\text{inv}_{i,0}=\sum_{m=0}^{1}\text{prod\_qty}_{i,m,0}-d_{i,0}-\text{back}_{i,0}\quad\forall i\\
&\text{inv}_{i,t}=\text{inv}_{i,t-1}+\sum_{m=0}^{1}\text{prod\_qty}_{i,m,t}-d_{i,t}-\text{back}_{i,t}\quad\forall i,\;t=1,2\\
&\text{inv}_{i,t}\geq0,\;\text{back}_{i,t}\geq0,\;\text{prod\_qty}_{i,m,t}\geq0\quad\forall i,m,t\\
&\text{produce}_{i,m,t}\in\{0,1\},\;\text{startup}_{i,m,t}\in\{0,1\}\quad\forall i,m,t\\
&\text{prod\_qty}_{i,m,t},\;\text{inv}_{i,t},\;\text{back}_{i,t}\in\mathbb{R}_{+}\quad\forall i,m,t
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB
import numpy as np

# Example data
h = np.array([1.0, 1.5, 2.0])          # holding costs per product i
b = np.array([0.5, 0.7, 0.9])          # backorder costs per product i
cap = np.array([10.0, 15.0])           # capacity per machine m
d = np.array([[5, 7, 6],
              [4, 6, 5],
              [3, 5, 4]])              # demand d[i,t]

I = range(3)   # products i=0..2
M = range(2)   # machines m=0..1
T = range(3)   # periods t=0..2

m = gp.Model(""Production_Planning"")

# Decision variables
produce = m.addVars(I, M, T, vtype=GRB.BINARY, name=""produce"")
startup = m.addVars(I, M, T, vtype=GRB.BINARY, name=""startup"")
prod_qty = m.addVars(I, M, T, vtype=GRB.CONTINUOUS, lb=0, name=""prod_qty"")
inv = m.addVars(I, T, vtype=GRB.CONTINUOUS, lb=0, name=""inv"")
back = m.addVars(I, T, vtype=GRB.CONTINUOUS, lb=0, name=""back"")

# Objective function
obj = gp.quicksum(136.4441474007699 * produce[i,m,t] + 72.08169936581939 * startup[i,m,t]
                  for i in I for m in M for t in T)
obj += gp.quicksum(h[i] * inv[i,t] + b[i] * back[i,t] for i in I for t in T)
m.setObjective(obj, GRB.MINIMIZE)

# Constraints
# prod_qty <= cap_m * produce
for i in I:
    for m in M:
        for t in T:
            m.addConstr(prod_qty[i,m,t] <= cap[m] * produce[i,m,t],
                        name=f""prod_qty_cap_{i}_{m}_{t}"")

# Sum produce per machine and time <= 1
for m in M:
    for t in T:
        m.addConstr(gp.quicksum(produce[i,m,t] for i in I) <= 1,
                    name=f""machine_limit_{m}_{t}"")

# Startup constraints
for i in I:
    for m in M:
        m.addConstr(startup[i,m,0] >= produce[i,m,0],
                    name=f""startup0_{i}_{m}"")
        for t in T[1:]:
            m.addConstr(startup[i,m,t] >= produce[i,m,t] - produce[i,m,t-1],
                        name=f""startup_{i}_{m}_{t}"")

# Inventory balance
for i in I:
    # t = 0
    m.addConstr(inv[i,0] == gp.quicksum(prod_qty[i,m,0] for m in M) - d[i,0] - back[i,0],
                name=f""inv0_{i}"")
    # t > 0
    for t in T[1:]:
        m.addConstr(inv[i,t] == inv[i,t-1] + gp.quicksum(prod_qty[i,m,t] for m in M)
                    - d[i,t] - back[i,t],
                    name=f""inv_{i}_{t}"")

# Solve the model
m.optimize()

# Print solution
for i in I:
    for m in M:
        for t in T:
            if produce[i,m,t].X > 0.5:
                print(f""produce[{i},{m},{t}] = 1"")
            if startup[i,m,t].X > 0.5:
                print(f""startup[{i},{m},{t}] = 1"")
            print(f""prod_qty[{i},{m},{t}] = {prod_qty[i,m,t].X}"")
    for t in T:
        print(f""inv[{i},{t}] = {inv[i,t].X}"")
        print(f""back[{i},{t}] = {back[i,t].X}"")",,889.137272,0,,,,,,,,
"In a manufacturing facility, six distinct jobs labeled Job 0 to Job 5 need to be processed on a set of machines. Each job consists of two operations that must be performed in a specific order, with each operation assigned to a specific machine. The goal is to schedule these operations to minimize the total completion time, known as the makespan, ensuring all jobs are completed as quickly as possible.

Each operation has a processing time of 1 unit. For each job, the second operation cannot start until the first operation is completed. For example, Operation 1 of Job 0 cannot start until Operation 0 of Job 0 is finished, and this applies to all jobs.

If two operations are assigned to the same machine, they cannot overlap in time. The order in which they are processed is determined by a binary decision variable. For example, if Operation 1 of Job 0 and Operation 1 of Job 4 are assigned to the same machine, one must be scheduled before the other. The binary variable X_(0,1)_(4,1) determines the order: if X_(0,1)_(4,1) is 1, then Operation 1 of Job 0 is scheduled before Operation 1 of Job 4; if it is 0, then Operation 1 of Job 4 is scheduled before Operation 1 of Job 0. This logic applies to all pairs of operations on shared machines.

The total completion time, C_max, must be at least as large as the completion time of every operation. For example, C_max must be greater than or equal to the completion time of Operation 0 of Job 0, which is S_(0,0) plus 1 unit. This applies to all operations across all jobs.

The start time of every operation must be non-negative. For example, S_(0,0) must be greater than or equal to 0, and this applies to all operations.

The binary variables X_(j,i)_(k,l) are used to enforce the order of operations on shared machines and can only take values of 0 or 1.

The objective is to minimize the makespan, C_max, which represents the total time required to complete all jobs. This ensures that the manufacturing process is as efficient as possible, reducing idle time and maximizing throughput. All processing times are 1 unit, and the makespan must be at least 1 unit greater than the completion time of every operation.","\[
\begin{aligned}
\min\quad & C_{\max} \\[4pt]
\text{s.t.}\quad
& S_{j,1}\;\ge\;S_{j,0}+1 && \forall j=0,\dots,5 \\[4pt]
& S_{j,i}\;\ge\;0 && \forall j=0,\dots,5,\; i=0,1 \\[4pt]
& C_{\max}\;\ge\;S_{j,i}+1 && \forall j=0,\dots,5,\; i=0,1 \\[4pt]
& S_{j,i}+1\;\le\;S_{k,l}+M\bigl(1-X_{(j,i),(k,l)}\bigr) && \forall j,k,i,l:\;m_{j,i}=m_{k,l},\;(j,i)\neq(k,l) \\[4pt]
& S_{k,l}+1\;\le\;S_{j,i}+M\,X_{(j,i),(k,l)} && \forall j,k,i,l:\;m_{j,i}=m_{k,l},\;(j,i)\neq(k,l) \\[4pt]
& X_{(j,i),(k,l)}\;\in\;\{0,1\} && \forall j,k,i,l:\;m_{j,i}=m_{k,l},\;(j,i)\neq(k,l) \\[4pt]
& C_{\max}\;\ge\;0
\end{aligned}
\]
\[
S_{j,i}\in\mathbb{R}_+,\;\; C_{\max}\in\mathbb{R}_+,\;\; X_{(j,i),(k,l)}\in\{0,1\}\quad\forall j,k,i,l\text{ with }m_{j,i}=m_{k,l}\,.
\]","import gurobipy as gp
from gurobipy import GRB

# Create the model
m = gp.Model(""Scheduling_Problem"")

# Example machine assignment for each operation (j,i)
# Here jobs 0-1 on machine 0, jobs 2-3 on machine 1, jobs 4-5 on machine 2
machine = {(j,i): j//2 for j in range(6) for i in range(2)}

# Big M value
M = 1000

# Decision variables: start times S_{j,i}
S = {(j,i): m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=f""S_{j}_{i}"") for j in range(6) for i in range(2)}

# Decision variable: makespan C_max
C_max = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""C_max"")

# Binary variables X_{(j,i),(k,l)} for operations on the same machine
X = {}
for (j,i) in machine:
    for (k,l) in machine:
        if machine[(j,i)] == machine[(k,l)] and (j,i) != (k,l):
            X[(j,i),(k,l)] = m.addVar(vtype=GRB.BINARY, name=f""X_{j}_{i}_{k}_{l}"")

# Constraints
# 1. S_{j,1} >= S_{j,0} + 1
for j in range(6):
    m.addConstr(S[(j,1)] >= S[(j,0)] + 1, name=f""seq_{j}"")

# 2. S_{j,i} >= 0 (already enforced by lb=0)

# 3. C_max >= S_{j,i} + 1
for (j,i) in machine:
    m.addConstr(C_max >= S[(j,i)] + 1, name=f""makespan_{j}_{i}"")

# 4. Ordering constraints for operations on the same machine
for (j,i) in machine:
    for (k,l) in machine:
        if machine[(j,i)] == machine[(k,l)] and (j,i) != (k,l):
            # S_{j,i} + 1 <= S_{k,l} + M*(1 - X_{(j,i),(k,l)})
            m.addConstr(S[(j,i)] + 1 <= S[(k,l)] + M * (1 - X[(j,i),(k,l)]),
                        name=f""order1_{j}_{i}_{k}_{l}"")
            # S_{k,l} + 1 <= S_{j,i} + M*X_{(j,i),(k,l)}
            m.addConstr(S[(k,l)] + 1 <= S[(j,i)] + M * X[(j,i),(k,l)],
                        name=f""order2_{j}_{i}_{k}_{l}"")

# 5. X variables are binary (already defined as such)

# 6. C_max >= 0 (already enforced by lb=0)

# Objective: minimize C_max
m.setObjective(C_max, GRB.MINIMIZE)

# Optimize
m.optimize()

# Print results
if m.status == GRB.OPTIMAL:
    print(f""Optimal makespan: {C_max.x}"")
    for (j,i), var in S.items():
        print(f""S_{j}_{i} = {var.x}"")
    for (j,i),(k,l), var in X.items():
        if var.x > 0.5:
            print(f""X_{j}_{i}_{k}_{l} = 1"")
else:
    print(""No optimal solution found."")",,4,0,,,,,,,,
"The problem involves designing a public transit network to minimize total costs while meeting passenger demand as much as possible. There are 11 potential transit lines (L_0 to L_10), each with a fixed cost for establishment and an operational cost per unit frequency. The fixed costs are: L_0 (\$2,478), L_1 (\$2,408), L_2 (\$2,443), L_3 (\$2,777), L_4 (\$2,152), L_5 (\$2,620), L_6 (\$2,359), L_7 (\$2,724), L_8 (\$2,247), L_9 (\$2,991), L_10 (\$2,941). The operational costs per unit frequency are: L_0 (\$297), L_1 (\$220), L_2 (\$288), L_3 (\$236), L_4 (\$212), L_5 (\$283), L_6 (\$206), L_7 (\$219), L_8 (\$242), L_9 (\$217), L_10 (\$227). Each line, if selected, must operate between 2 and 10 trips per hour. There are 13 stations, some of which can serve as transfer points if at least two lines pass through them. There are 12 origin-destination pairs with specific passenger demands and penalty costs for unsatisfied demand: OD_8_12 (29 passengers, \$702 penalty), OD_3_8 (20 passengers, \$751 penalty), OD_2_0 (28 passengers, \$740 penalty), OD_11_2 (28 passengers, \$722 penalty), OD_2_1 (30 passengers, \$785 penalty), OD_10_5 (26 passengers, \$722 penalty), OD_10_12 (26 passengers, \$735 penalty), OD_5_6 (26 passengers, \$773 penalty), OD_1_12 (25 passengers, \$770 penalty), OD_10_6 (27 passengers, \$757 penalty), OD_4_9 (26 passengers, \$747 penalty), OD_4_0 (27 passengers, \$757 penalty). The total number of vehicles available is 55, and the combined vehicle usage across all lines must not exceed this limit. The objective is to minimize the total cost, which includes fixed costs for establishing selected lines, operational costs based on line frequencies, and penalty costs for any unsatisfied demand. Constraints include ensuring that the total capacity provided by all lines serving each OD pair, plus any unsatisfied demand, meets or exceeds the passenger demand; enforcing frequency bounds for selected lines; limiting total vehicle usage; designating transfer stations only if at least two lines pass through them; and ensuring that the total frequency of lines serving each OD pair meets a minimum threshold.","\[
\begin{aligned}
\min\;&\sum_{i=0}^{10}\bigl(2478\,y_i+2408\,y_1+2443\,y_2+2777\,y_3+2152\,y_4+2620\,y_5+2359\,y_6+2724\,y_7+2247\,y_8+2991\,y_9+2941\,y_{10}\bigr)\\
&\quad+\sum_{i=0}^{10}\bigl(297\,f_i+220\,f_1+288\,f_2+236\,f_3+212\,f_4+283\,f_5+206\,f_6+219\,f_7+242\,f_8+217\,f_9+227\,f_{10}\bigr)\\
&\quad+\bigl(702\,u_{8,12}+751\,u_{3,8}+740\,u_{2,0}+722\,u_{11,2}+785\,u_{2,1}+722\,u_{10,5}+735\,u_{10,12}\\
&\qquad+773\,u_{5,6}+770\,u_{1,12}+757\,u_{10,6}+747\,u_{4,9}+757\,u_{4,0}\bigr)\\[6pt]
\text{s.t.}\;&2\,y_i\le f_i\le 10\,y_i\qquad(i=0,\dots,10)\\
&\sum_{i=0}^{10}f_i\le 55\\
&\sum_{i=0}^{10}f_i+u_{8,12}\ge 29\\
&\sum_{i=0}^{10}f_i+u_{3,8}\ge 20\\
&\sum_{i=0}^{10}f_i+u_{2,0}\ge 28\\
&\sum_{i=0}^{10}f_i+u_{11,2}\ge 28\\
&\sum_{i=0}^{10}f_i+u_{2,1}\ge 30\\
&\sum_{i=0}^{10}f_i+u_{10,5}\ge 26\\
&\sum_{i=0}^{10}f_i+u_{10,12}\ge 26\\
&\sum_{i=0}^{10}f_i+u_{5,6}\ge 26\\
&\sum_{i=0}^{10}f_i+u_{1,12}\ge 25\\
&\sum_{i=0}^{10}f_i+u_{10,6}\ge 27\\
&\sum_{i=0}^{10}f_i+u_{4,9}\ge 26\\
&\sum_{i=0}^{10}f_i+u_{4,0}\ge 27\\
&y_i\in\{0,1\}\quad(i=0,\dots,10)\\
&f_i\in\mathbb{Z}_+\quad(i=0,\dots,10)\\
&u_{8,12},u_{3,8},u_{2,0},u_{11,2},u_{2,1},u_{10,5},u_{10,12},u_{5,6},u_{1,12},u_{10,6},u_{4,9},u_{4,0}\in\mathbb{R}_+\,.
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Data
coeff_y = [2478,2408,2443,2777,2152,2620,2359,2724,2247,2991,2941]
coeff_f = [297,220,288,236,212,283,206,219,242,217,227]
u_keys = [(8,12),(3,8),(2,0),(11,2),(2,1),(10,5),(10,12),(5,6),(1,12),(10,6),(4,9),(4,0)]
u_coeff = [702,751,740,722,785,722,735,773,770,757,747,757]
u_threshold = [29,20,28,28,30,26,26,26,25,27,26,27]

# Create model
m = gp.Model(""Optimization"")

# Decision variables
y = m.addVars(11, vtype=GRB.BINARY, name=""y"")
f = m.addVars(11, vtype=GRB.INTEGER, lb=0, name=""f"")
u = m.addVars(u_keys, vtype=GRB.CONTINUOUS, lb=0, name=""u"")

# Objective function
obj = gp.quicksum(coeff_y[i]*y[i] for i in range(11)) + \
      gp.quicksum(coeff_f[i]*f[i] for i in range(11)) + \
      gp.quicksum(u_coeff[j]*u[u_keys[j]] for j in range(len(u_keys)))
m.setObjective(obj, GRB.MINIMIZE)

# Constraints
for i in range(11):
    m.addConstr(2*y[i] <= f[i], name=f""lower_f_{i}"")
    m.addConstr(f[i] <= 10*y[i], name=f""upper_f_{i}"")

m.addConstr(gp.quicksum(f[i] for i in range(11)) <= 55, name=""sum_f_le_55"")

for j, key in enumerate(u_keys):
    m.addConstr(gp.quicksum(f[i] for i in range(11)) + u[key] >= u_threshold[j], name=f""u_{key}_constraint"")

# Solve
m.optimize()",13299,237394,0,,,,,,,,
"Minimize the total operational cost of a power generation system over six periods, consisting of Type 0 and Type 1 generators. The cost includes a base cost of 78 units per generator operational in a period, a variable cost of 4 units per megawatt of power generated, and startup costs of 347 units for Type 0 generators and 352 units for Type 1 generators when activated. The total power generated in each period must meet or exceed the demand: 172 MW in Period 0, 171 MW in Period 1, 166 MW in Period 2, 160 MW in Period 3, 195 MW in Period 4, and 181 MW in Period 5. Each generator has output limits: Type 0 generators must produce between 34 MW and 128 MW, and Type 1 generators must produce between 34 MW and 125 MW. The total maximum output capacity of all generators in each period must be at least 115% of the demand for that period, ensuring sufficient reserve capacity. The number of operational generators cannot exceed 4 for Type 0 and 5 for Type 1 in any period. For startup constraints, no more than 2 Type 0 generators can be started in Period 0, and no more than 1 Type 1 generator can be started in Period 0. The number of generators operational in a period cannot exceed the number operational in the previous period plus the number started in the current period. All decision variables must be non-negative integers, and power output must be non-negative.","\[
\begin{aligned}
\min \quad & \sum_{t=0}^{5}\Bigl[\,78\,(u_t^0+u_t^1)+4\,(p_t^0+p_t^1)+347\,s_t^0+352\,s_t^1\Bigr] \\[4pt]
\text{s.t.}\quad & p_t^0+p_t^1 \;\ge\; D_t \qquad &&\forall t=0,\dots,5 \\[2pt]
& 34\,u_t^0 \;\le\; p_t^0 \;\le\; 128\,u_t^0 \qquad &&\forall t \\[2pt]
& 34\,u_t^1 \;\le\; p_t^1 \;\le\; 125\,u_t^1 \qquad &&\forall t \\[2pt]
& 128\,u_t^0+125\,u_t^1 \;\ge\; 1.15\,D_t \qquad &&\forall t \\[2pt]
& u_t^0 \;\le\; 4,\;\; u_t^1 \;\le\; 5 \qquad &&\forall t \\[2pt]
& s_0^0 \;\le\; 2,\;\; s_0^1 \;\le\; 1 \\[2pt]
& u_t^0 \;\le\; u_{t-1}^0 + s_t^0,\;\; u_t^1 \;\le\; u_{t-1}^1 + s_t^1 \qquad &&\forall t=1,\dots,5 \\[2pt]
& s_t^0 \;\le\; u_t^0,\;\; s_t^1 \;\le\; u_t^1 \qquad &&\forall t \\[2pt]
& s_t^0 \;\ge\; u_t^0 - u_{t-1}^0,\;\; s_t^1 \;\ge\; u_t^1 - u_{t-1}^1 \qquad &&\forall t=1,\dots,5 \\[2pt]
& u_t^0,\;u_t^1,\;s_t^0,\;s_t^1 \;\in\; \mathbb{Z}_+,\;\; p_t^0,\;p_t^1 \;\in\; \mathbb{R}_+ \qquad &&\forall t \\[4pt]
\text{where}\quad & D_0=172,\; D_1=171,\; D_2=166,\; D_3=160,\; D_4=195,\; D_5=181
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Data
T = 6
D = [172, 171, 166, 160, 195, 181]

# Create model
m = gp.Model(""UnitCommitment"")

# Decision variables
u0 = m.addVars(T, vtype=GRB.INTEGER, lb=0, ub=4, name=""u0"")
u1 = m.addVars(T, vtype=GRB.INTEGER, lb=0, ub=5, name=""u1"")
s0 = m.addVars(T, vtype=GRB.INTEGER, lb=0, ub=4, name=""s0"")
s1 = m.addVars(T, vtype=GRB.INTEGER, lb=0, ub=5, name=""s1"")
p0 = m.addVars(T, vtype=GRB.CONTINUOUS, lb=0, name=""p0"")
p1 = m.addVars(T, vtype=GRB.CONTINUOUS, lb=0, name=""p1"")

# Constraints
for t in range(T):
    m.addConstr(p0[t] + p1[t] >= D[t], name=f""demand_{t}"")
    m.addConstr(p0[t] >= 34 * u0[t], name=f""p0_min_{t}"")
    m.addConstr(p0[t] <= 128 * u0[t], name=f""p0_max_{t}"")
    m.addConstr(p1[t] >= 34 * u1[t], name=f""p1_min_{t}"")
    m.addConstr(p1[t] <= 125 * u1[t], name=f""p1_max_{t}"")
    m.addConstr(128 * u0[t] + 125 * u1[t] >= 1.15 * D[t], name=f""capacity_{t}"")
    m.addConstr(s0[t] <= u0[t], name=f""s0_le_u0_{t}"")
    m.addConstr(s1[t] <= u1[t], name=f""s1_le_u1_{t}"")
    if t == 0:
        m.addConstr(s0[t] <= 2, name=f""s0_0_le_2"")
        m.addConstr(s1[t] <= 1, name=f""s1_0_le_1"")
    else:
        m.addConstr(u0[t] <= u0[t-1] + s0[t], name=f""u0_inc_{t}"")
        m.addConstr(u1[t] <= u1[t-1] + s1[t], name=f""u1_inc_{t}"")
        m.addConstr(s0[t] >= u0[t] - u0[t-1], name=f""s0_inc_{t}"")
        m.addConstr(s1[t] >= u1[t] - u1[t-1], name=f""s1_inc_{t}"")

# Objective
obj = gp.quicksum(
    78 * (u0[t] + u1[t]) + 4 * (p0[t] + p1[t]) + 347 * s0[t] + 352 * s1[t]
    for t in range(T)
)
m.setObjective(obj, GRB.MINIMIZE)

# Solve
m.optimize()

# Output solution
if m.status == GRB.OPTIMAL:
    print(""Optimal objective:"", m.objVal)
    for t in range(T):
        print(f""t={t} u0={u0[t].X} u1={u1[t].X} s0={s0[t].X} s1={s1[t].X} p0={p0[t].X} p1={p1[t].X}"")",5116,5116,1,,,,,,,,
"Determine the number of generators of each type (Type 0 and Type 1) to operate, the power output for each generator type, and the number of startups in each of the five consecutive time periods to minimize the total cost of operation. The total cost includes a base cost of 80 units per Type 0 generator and 79 units per Type 1 generator for each period they are active, a power output cost of 3 units per MW for Type 0 generators and 4 units per MW for Type 1 generators, and a startup cost of 352 units for Type 0 generators and 346 units for Type 1 generators. The total power output from all generators must meet or exceed the demand in each period: 217 MW in period 0, 209 MW in period 1, 194 MW in period 2, 182 MW in period 3, and 164 MW in period 4. Each Type 0 generator must produce at least 34 MW and at most 129 MW when active, and each Type 1 generator must produce at least 34 MW and at most 127 MW when active. The combined maximum output of all active generators must meet or exceed specific capacity requirements: 249.55 MW in period 0, 240.35 MW in period 1, 223.1 MW in period 2, 209.3 MW in period 3, and 188.6 MW in period 4. No more than 1 Type 0 generator and 2 Type 1 generators can be active in any period. The number of startups for each generator type is constrained by the number of generators available and the number of generators active in the previous period. The variables representing the number of generators and startups are general integer variables.","\[
\begin{aligned}
\min\;&\sum_{t=0}^{4}\Bigl(80\,G_{0t}+79\,G_{1t}+3\,P_{0t}+4\,P_{1t}+352\,S_{0t}+346\,S_{1t}\Bigr)\\[4pt]
\text{s.t.}\;&P_{0t}+P_{1t}\;\ge\;\text{demand}_t\qquad(t=0,\dots,4)\\
&129\,G_{0t}+127\,G_{1t}\;\ge\;\text{capacity}_t\qquad(t=0,\dots,4)\\
&34\,G_{0t}\;\le\;P_{0t}\;\le\;129\,G_{0t}\qquad(t=0,\dots,4)\\
&34\,G_{1t}\;\le\;P_{1t}\;\le\;127\,G_{1t}\qquad(t=0,\dots,4)\\
&G_{0t}\;\le\;1,\qquad G_{1t}\;\le\;2\qquad(t=0,\dots,4)\\
&S_{0t}\;\le\;G_{0t},\qquad S_{1t}\;\le\;G_{1t}\qquad(t=0,\dots,4)\\
&S_{0t}\;\ge\;G_{0t}-G_{0,t-1}\qquad(t=1,\dots,4)\\
&S_{1t}\;\ge\;G_{1t}-G_{1,t-1}\qquad(t=1,\dots,4)\\
&S_{0t}\;\le\;G_{0t}-G_{0,t-1}+d_{0t}\qquad(t=1,\dots,4)\\
&S_{1t}\;\le\;G_{1t}-G_{1,t-1}+2\,d_{1t}\qquad(t=1,\dots,4)\\
&G_{0t}-G_{0,t-1}\;\le\;d_{0t}\qquad(t=1,\dots,4)\\
&G_{1t}-G_{1,t-1}\;\le\;2\,d_{1t}\qquad(t=1,\dots,4)\\
&S_{0,0}=G_{0,0},\qquad S_{1,0}=G_{1,0}\\
&G_{0t},G_{1t},S_{0t},S_{1t}\in\mathbb{Z}_{+}\qquad(t=0,\dots,4)\\
&d_{0t},d_{1t}\in\{0,1\}\qquad(t=1,\dots,4)\\
&P_{0t},P_{1t}\in\mathbb{R}_{+}\qquad(t=0,\dots,4)
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Example data for demand and capacity
demand = [100, 120, 110, 130, 115]          # demand_t for t=0..4
capacity = [200, 210, 205, 215, 208]        # capacity_t for t=0..4

m = gp.Model(""UnitCommitment"")

# Decision variables
G0 = m.addVars(5, vtype=GRB.INTEGER, lb=0, ub=1, name=""G0"")
G1 = m.addVars(5, vtype=GRB.INTEGER, lb=0, ub=2, name=""G1"")
S0 = m.addVars(5, vtype=GRB.INTEGER, lb=0, name=""S0"")
S1 = m.addVars(5, vtype=GRB.INTEGER, lb=0, name=""S1"")
d0 = m.addVars(5, vtype=GRB.BINARY, name=""d0"")   # binary for t=1..4
d1 = m.addVars(5, vtype=GRB.BINARY, name=""d1"")
P0 = m.addVars(5, vtype=GRB.CONTINUOUS, lb=0, name=""P0"")
P1 = m.addVars(5, vtype=GRB.CONTINUOUS, lb=0, name=""P1"")

# Objective function
obj = gp.quicksum(80*G0[t] + 79*G1[t] + 3*P0[t] + 4*P1[t] + 352*S0[t] + 346*S1[t] for t in range(5))
m.setObjective(obj, GRB.MINIMIZE)

# Constraints for each time period
for t in range(5):
    m.addConstr(P0[t] + P1[t] >= demand[t], name=f""demand_{t}"")
    m.addConstr(129*G0[t] + 127*G1[t] >= capacity[t], name=f""capacity_{t}"")
    m.addConstr(34*G0[t] <= P0[t], name=f""P0_lower_{t}"")
    m.addConstr(P0[t] <= 129*G0[t], name=f""P0_upper_{t}"")
    m.addConstr(34*G1[t] <= P1[t], name=f""P1_lower_{t}"")
    m.addConstr(P1[t] <= 127*G1[t], name=f""P1_upper_{t}"")
    m.addConstr(S0[t] <= G0[t], name=f""S0_le_G0_{t}"")
    m.addConstr(S1[t] <= G1[t], name=f""S1_le_G1_{t}"")

# Startup and ramp constraints for t>=1
for t in range(1, 5):
    m.addConstr(S0[t] >= G0[t] - G0[t-1], name=f""S0_startup_{t}"")
    m.addConstr(S1[t] >= G1[t] - G1[t-1], name=f""S1_startup_{t}"")
    m.addConstr(S0[t] <= G0[t] - G0[t-1] + d0[t], name=f""S0_upper_{t}"")
    m.addConstr(S1[t] <= G1[t] - G1[t-1] + 2*d1[t], name=f""S1_upper_{t}"")
    m.addConstr(G0[t] - G0[t-1] <= d0[t], name=f""G0_change_{t}"")
    m.addConstr(G1[t] - G1[t-1] <= 2*d1[t], name=f""G1_change_{t}"")

# Initial startup equality
m.addConstr(S0[0] == G0[0], name=""S0_0_eq_G0_0"")
m.addConstr(S1[0] == G1[0], name=""S1_0_eq_G1_0"")

# d0[0] and d1[0] are not used; set them to zero
m.addConstr(d0[0] == 0, name=""d0_0_zero"")
m.addConstr(d1[0] == 0, name=""d1_0_zero"")

# Solve the model
m.optimize()

# Print solution
if m.status == GRB.OPTIMAL:
    for t in range(5):
        print(f""t={t} G0={G0[t].X} G1={G1[t].X} S0={S0[t].X} S1={S1[t].X} d0={d0[t].X} d1={d1[t].X} P0={P0[t].X} P1={P1[t].X}"")",3388,4014,0,,,,,,,,
"A manufacturing facility produces custom parts for seven jobs, labeled Job 0 through Job 6. Each job consists of two operations that must be performed in sequence, with the second operation starting only after the first is completed. Operations are assigned to specific machines, and some operations share the same machine, meaning they cannot be processed simultaneously. The goal is to schedule all operations to minimize the total completion time, known as the makespan.

Each operation has a processing time of 1 unit. For example, Operation 0 of Job 0 takes 1 unit of time, and Operation 1 of Job 0 also takes 1 unit of time. This applies to all operations across all jobs. Operations sharing the same machine must be scheduled such that one finishes before the other starts. Binary decision variables determine the order of operations on shared machines. For instance, if Operation 1 of Job 0 and Operation 0 of Job 1 share a machine, a binary variable decides whether Operation 1 of Job 0 finishes before Operation 0 of Job 1 starts, or vice versa.

The makespan must be at least as large as the completion time of every operation. For example, if Operation 1 of Job 0 finishes at time 2, the makespan must be at least 2. A large constant, 100,000, is used in the constraints to ensure that operations on the same machine do not overlap. The objective is to minimize the makespan, ensuring the facility operates as efficiently as possible while respecting all precedence and machine capacity constraints.","\[
\begin{aligned}
\min\quad & C_{\max} \\
\text{s.t.}\quad & s_{j,1}\;\ge\;s_{j,0}+1 && \forall j\in\{0,\dots,6\},\\
& C_{\max}\;\ge\;s_{j,1}+1 && \forall j\in\{0,\dots,6\},\\
& s_{j,k}+1\;\le\;s_{i,l}+M\bigl(1-y_{jk,il}\bigr) && \forall\bigl((j,k),(i,l)\bigr)\in P,\\
& s_{i,l}+1\;\le\;s_{j,k}+M\,y_{jk,il} && \forall\bigl((j,k),(i,l)\bigr)\in P,
\end{aligned}
\]  
where \(M=100000\) and \(P\) is the set of all unordered pairs of operations that share a machine.  
Domain: \(s_{j,k}\in\mathbb{R}_+\) for all \(j\in\{0,\dots,6\},\,k\in\{0,1\}\);  
\(C_{\max}\in\mathbb{R}_+\);  
\(y_{jk,il}\in\{0,1\}\) for all \(((j,k),(i,l))\in P\).","import gurobipy as gp
from gurobipy import GRB

# Define which operations share each machine
machines = {
    0: [0, 1, 2],   # machine 0 has operations 0,1,2
    1: [3, 4, 5],   # machine 1 has operations 3,4,5
    2: [6]          # machine 2 has operation 6
}

# Build set of unordered pairs of operations that share a machine
P = set()
for ops in machines.values():
    for i in range(len(ops)):
        for j in range(i + 1, len(ops)):
            P.add((ops[i], ops[j]))

# Create model
m = gp.Model(""Job_Shop_Scheduling"")

# Decision variables
s = m.addVars(7, 2, lb=0, vtype=GRB.CONTINUOUS, name=""s"")  # s[j,k]
Cmax = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""Cmax"")

# Binary variables for ordering between tasks of operations that share a machine
y = {}
for (j, i) in P:
    for k in range(2):
        for l in range(2):
            y[(j, k, i, l)] = m.addVar(vtype=GRB.BINARY, name=f""y_{j}{k}_{i}{l}"")

# Objective: minimize makespan
m.setObjective(Cmax, GRB.MINIMIZE)

# Constraints
# Each operation's second task starts at least 1 unit after the first
for j in range(7):
    m.addConstr(s[j, 1] >= s[j, 0] + 1, name=f""order_{j}"")

# Makespan must be at least the completion time of each operation
for j in range(7):
    m.addConstr(Cmax >= s[j, 1] + 1, name=f""Cmax_{j}"")

# Big-M constraints for operations sharing a machine
M = 100000
for (j, i) in P:
    for k in range(2):
        for l in range(2):
            # s_{j,k} + 1 <= s_{i,l} + M*(1 - y_{jk,il})
            m.addConstr(s[j, k] + 1 <= s[i, l] + M * (1 - y[(j, k, i, l)]),
                        name=f""bigM1_{j}{k}_{i}{l}"")
            # s_{i,l} + 1 <= s_{j,k} + M*y_{jk,il}
            m.addConstr(s[i, l] + 1 <= s[j, k] + M * y[(j, k, i, l)],
                        name=f""bigM2_{j}{k}_{i}{l}"")

# Optimize
m.optimize()

# Output solution
if m.status == GRB.OPTIMAL:
    print(f""Optimal Cmax: {Cmax.X}"")
    for j in range(7):
        print(f""Operation {j}: start0={s[j, 0].X}, start1={s[j, 1].X}"")",2,3,0,,,,,,,,
"There are 5 jobs labeled Job 0 to Job 4 and 4 machines labeled Machine 0 to Machine 3. Each job must be processed on all machines in sequence, with specific processing times for each job on each machine. The goal is to assign each job to a unique schedule position (Position 0 to Position 4) and determine the start times for each job on each machine to minimize the total completion time. Each schedule position must be assigned to exactly one job, and each job must be assigned to exactly one schedule position. A job cannot start on a machine until it has finished processing on the previous machine, and a job in a later schedule position cannot start on a machine until the job in the previous position has finished processing on that machine. The objective function includes coefficients for the schedule variables in the last position: 6 for Job 0, 5 for Job 1, 10 for Job 2, 10 for Job 3, and 8 for Job 4, as well as the start time of the last job on the last machine. The processing times for each job on each machine are as follows: Job 0 takes 9, 9, 7, and 6 hours on Machines 0 to 3, respectively; Job 1 takes 6, 6, 7, and 5 hours; Job 2 takes 9, 10, 10, and 10 hours; Job 3 takes 6, 10, 6, and 10 hours; and Job 4 takes 10, 7, 6, and 8 hours. The JobSchedule variables are binary, indicating whether a job is assigned to a specific schedule position, and the StartTime variables represent the start times of jobs on machines, which must be non-negative.","\[
\begin{aligned}
\min \quad & \sum_{j=0}^{4} c_j\,y_{j,4}\;+\;\sum_{j=0}^{4}s_j \\[4pt]
\text{s.t.}\quad
&\sum_{j=0}^{4} y_{j,p}=1 \qquad \forall\,p=0,\dots,4 &&\text{(each position gets one job)}\\
&\sum_{p=0}^{4} y_{j,p}=1 \qquad \forall\,j=0,\dots,4 &&\text{(each job gets one position)}\\[4pt]
& s_j \le t_{j,3}\,y_{j,4}\qquad \forall\,j &&\text{(link $s_j$ to start time of job $j$ on machine 3)}\\
& s_j \le M\,y_{j,4}\qquad \forall\,j &&\text{(big_$M$ upper bound)}\\
& s_j \ge t_{j,3}\;-\;M\,(1-y_{j,4})\qquad \forall\,j &&\text{(big_$M$ lower bound)}\\
& s_j \ge 0 \qquad \forall\,j &&\text{(non__egativity)}\\[4pt]
& \text{Machine sequencing:}\quad
  \forall\,p=1,\dots,4,\;\forall\,m=0,\dots,3,\;\forall\,j,k\\
& \quad \text{Start}_{j,m}\;\ge\;\text{Start}_{k,m}\;+\;t_{k,m}\;-\;M\,(2-y_{j,p}-y_{k,p-1})\\[4pt]
& \text{Job precedence on machines:}\quad
  \forall\,j,\;\forall\,m=1,\dots,3\\
& \quad \text{Start}_{j,m}\;\ge\;\text{Start}_{j,m-1}\;+\;t_{j,m-1}\\[4pt]
& \text{Non__egativity of start times:}\quad
  \forall\,j,\;\forall\,m\;:\;\text{Start}_{j,m}\ge 0\\[4pt]
& y_{j,p}\in\{0,1\}\qquad \forall\,j,p\\
& \text{Start}_{j,m}\in\mathbb{R}_+\qquad \forall\,j,m\\
& s_j\in\mathbb{R}_+\qquad \forall\,j
\end{aligned}
\]

where  

\[
c_j=\begin{cases}
6 & j=0\\
5 & j=1\\
10 & j=2\\
10 & j=3\\
8 & j=4
\end{cases},
\qquad
t_{j,m}=\begin{cases}
9 & (j,m)=(0,0),(0,1)\\
7 & (0,2)\\
6 & (0,3)\\
6 & (1,0),(1,1)\\
7 & (1,2)\\
5 & (1,3)\\
9 & (2,0)\\
10 & (2,1),(2,2),(2,3)\\
6 & (3,0),(3,2)\\
10 & (3,1),(3,3)\\
10 & (4,0)\\
7 & (4,1)\\
6 & (4,2)\\
8 & (4,3)
\end{cases},
\qquad
M=1000.
\]","import gurobipy as gp
from gurobipy import GRB

c = [6,5,10,10,8]
t = [
    [9,9,7,6],
    [6,6,7,5],
    [9,10,10,10],
    [6,10,6,10],
    [10,7,6,8]
]
M = 1000

m = gp.Model(""Job_Scheduling"")

y = m.addVars(5,5, vtype=GRB.BINARY, name=""y"")
s = m.addVars(5, vtype=GRB.CONTINUOUS, lb=0, name=""s"")
Start = m.addVars(5,4, vtype=GRB.CONTINUOUS, lb=0, name=""Start"")

# Assignment constraints
for p in range(5):
    m.addConstr(gp.quicksum(y[j,p] for j in range(5)) == 1, name=f""pos_{p}"")
for j in range(5):
    m.addConstr(gp.quicksum(y[j,p] for p in range(5)) == 1, name=f""job_{j}"")

# Link s_j to start time on machine 3
for j in range(5):
    m.addConstr(s[j] <= t[j][3] * y[j,4], name=f""s_le_t3_{j}"")
    m.addConstr(s[j] <= M * y[j,4], name=f""s_le_M_{j}"")
    m.addConstr(s[j] >= t[j][3] - M * (1 - y[j,4]), name=f""s_ge_t3_{j}"")

# Machine sequencing constraints
for p in range(1,5):
    for m_idx in range(4):
        for j in range(5):
            for k in range(5):
                m.addConstr(
                    Start[j,m_idx] >= Start[k,m_idx] + t[k][m_idx] - M * (2 - y[j,p] - y[k,p-1]),
                    name=f""seq_p{p}_m{m_idx}_j{j}_k{k}""
                )

# Job precedence on machines
for j in range(5):
    for m_idx in range(1,4):
        m.addConstr(Start[j,m_idx] >= Start[j,m_idx-1] + t[j][m_idx-1], name=f""prec_j{j}_m{m_idx}"")

# Objective
obj = gp.quicksum(c[j] * y[j,4] for j in range(5)) + gp.quicksum(s[j] for j in range(5))
m.setObjective(obj, GRB.MINIMIZE)

m.optimize()",10,65,0,,,,,,,,
"You are tasked with selecting exactly 2 out of 5 nodes (node_0, node_1, node_2, node_3, node_4) to host facilities, with the goal of maximizing the minimum distance between any two selected facilities. The decision variables are binary: each node can either be selected (1) or not selected (0), and for every pair of nodes, a binary variable indicates whether both nodes in the pair are selected. The distances between nodes are derived from the LP constraints, where the distance between node_0 and node_1 is 18 units (1,000,018 - 1,000,000), node_0 and node_2 is 36 units (1,000,036 - 1,000,000), node_0 and node_3 is 28 units (1,000,028 - 1,000,000), node_0 and node_4 is 20 units (1,000,020 - 1,000,000), node_1 and node_0 is 25 units (1,000,025 - 1,000,000), node_1 and node_2 is 37 units (1,000,037 - 1,000,000), node_1 and node_3 is 36 units (1,000,036 - 1,000,000), node_1 and node_4 is 17 units (1,000,017 - 1,000,000), node_2 and node_0 is 42 units (1,000,042 - 1,000,000), node_2 and node_1 is 42 units (1,000,042 - 1,000,000), node_2 and node_3 is 23 units (1,000,023 - 1,000,000), node_2 and node_4 is 46 units (1,000,046 - 1,000,000), node_3 and node_0 is 31 units (1,000,031 - 1,000,000), node_3 and node_1 is 36 units (1,000,036 - 1,000,000), node_3 and node_2 is 11 units (1,000,011 - 1,000,000), node_3 and node_4 is 50 units (1,000,050 - 1,000,000), node_4 and node_0 is 10 units (1,000,010 - 1,000,000), node_4 and node_1 is 29 units (1,000,029 - 1,000,000), node_4 and node_2 is 24 units (1,000,024 - 1,000,000), and node_4 and node_3 is 42 units (1,000,042 - 1,000,000). The constraints ensure that exactly 2 nodes are selected, and for each pair of nodes, the minimum distance between any two selected facilities must be at least as large as the distance between those two nodes if both nodes in the pair are selected. If either node in the pair is not selected, the constraint is relaxed using a large constant (1,000,000). Additionally, the selection of a pair of nodes is only valid if both nodes in the pair are selected, enforced by ensuring that if a pair is selected, both nodes in the pair must be selected, and if both nodes in a pair are selected, the pair must be selected. The solution must ensure that the facilities are optimally dispersed across the network.","\[
\begin{aligned}
\text{maximize}\quad & d_{\min} \\[4pt]
\text{subject to}\quad 
& \sum_{i=0}^{4} y_i = 2 \\[4pt]
& d_{\min} \;\le\; 18 + M(1-z_{01}) \\
& d_{\min} \;\le\; 36 + M(1-z_{02}) \\
& d_{\min} \;\le\; 28 + M(1-z_{03}) \\
& d_{\min} \;\le\; 20 + M(1-z_{04}) \\
& d_{\min} \;\le\; 37 + M(1-z_{12}) \\
& d_{\min} \;\le\; 36 + M(1-z_{13}) \\
& d_{\min} \;\le\; 17 + M(1-z_{14}) \\
& d_{\min} \;\le\; 23 + M(1-z_{23}) \\
& d_{\min} \;\le\; 46 + M(1-z_{24}) \\
& d_{\min} \;\le\; 50 + M(1-z_{34}) \\[4pt]
& z_{ij} \;\le\; y_i \qquad \forall\, i<j \\
& z_{ij} \;\le\; y_j \qquad \forall\, i<j \\
& z_{ij} \;\ge\; y_i + y_j - 1 \qquad \forall\, i<j \\[4pt]
& y_i \in \{0,1\}\quad i=0,\dots,4 \\
& z_{ij} \in \{0,1\}\quad i<j \\
& d_{\min} \ge 0
\end{aligned}
\]

where \(M = 1\,000\,000\).  All decision variables are declared with their domains as shown.","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Maximize_d_min"")

# Parameters
M = 1_000_000
pairs = [(0,1),(0,2),(0,3),(0,4),(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
constants = { (0,1):18, (0,2):36, (0,3):28, (0,4):20,
              (1,2):37, (1,3):36, (1,4):17,
              (2,3):23, (2,4):46,
              (3,4):50 }

# Decision variables
y = m.addVars(5, vtype=GRB.BINARY, name=""y"")
z = m.addVars(pairs, vtype=GRB.BINARY, name=""z"")
d_min = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""d_min"")

# Objective
m.setObjective(d_min, GRB.MAXIMIZE)

# Constraints
m.addConstr(gp.quicksum(y[i] for i in range(5)) == 2, name=""sum_y"")

for (i,j) in pairs:
    # d_min <= constant + M*(1 - z_ij)
    m.addConstr(d_min <= constants[(i,j)] + M*(1 - z[i,j]), name=f""d_min_{i}_{j}"")
    # z_ij <= y_i
    m.addConstr(z[i,j] <= y[i], name=f""z_le_yi_{i}_{j}"")
    # z_ij <= y_j
    m.addConstr(z[i,j] <= y[j], name=f""z_le_yj_{i}_{j}"")
    # z_ij >= y_i + y_j - 1
    m.addConstr(z[i,j] >= y[i] + y[j] - 1, name=f""z_ge_yi_yj_{i}_{j}"")

# Optimize
m.optimize()",50,42,0,,,,,,,,
"Cell Tower Coverage Planning

You are tasked with planning the deployment of cell towers across a region to maximize population coverage while adhering to a strict budget constraint. The region is divided into 30 distinct areas, each with a specific population size that needs to be served. Your goal is to determine which cell towers to build and which areas to cover, ensuring that the total cost of building the towers does not exceed the available budget.

#### Key Decisions:
1. **Build or Not Build a Tower**: For each of the 25 potential cell tower locations, you must decide whether to build the tower (a binary decision: build or not build).
2. **Coverage of Areas**: For each of the 30 areas, you must determine whether it will be covered by at least one of the built towers (a binary decision: covered or not covered).

#### Objective:
Maximize the total population covered by the deployed cell towers. The population sizes for the 30 areas are as follows:
- Area 0: 2,882 people
- Area 1: 4,926 people
- Area 2: 3,930 people
- Area 3: 3,468 people
- Area 4: 3,415 people
- Area 5: 2,697 people
- Area 6: 2,746 people
- Area 7: 3,817 people
- Area 8: 4,806 people
- Area 9: 2,889 people
- Area 10: 2,276 people
- Area 11: 2,087 people
- Area 12: 4,452 people
- Area 13: 3,015 people
- Area 14: 2,305 people
- Area 15: 3,196 people
- Area 16: 4,854 people
- Area 17: 4,466 people
- Area 18: 2,154 people
- Area 19: 4,661 people
- Area 20: 2,587 people
- Area 21: 4,013 people
- Area 22: 3,519 people
- Area 23: 4,837 people
- Area 24: 2,465 people
- Area 25: 3,807 people
- Area 26: 4,498 people
- Area 27: 3,423 people
- Area 28: 2,832 people
- Area 29: 3,064 people

#### Constraints:
1. **Coverage Requirements**:
   - Each area must be covered by at least one of the built towers. For example:
     - Area 0 can be covered by towers 3, 4, 6, 7, 8, 9, 10, 11, 13, 14, 15, 18, or 20.
     - Area 1 can be covered by towers 0, 1, 3, 4, 5, 8, 11, 13, 15, 16, 20, 23, or 24.
     - Similar coverage constraints apply to all 30 areas, with specific combinations of towers required for each area.

2. **Budget Constraint**:
   - The total cost of building the selected towers must not exceed the available budget of 2,501 units. The costs for building each tower are as follows:
     - Tower 0: 453 units
     - Tower 1: 208 units
     - Tower 2: 223 units
     - Tower 3: 336 units
     - Tower 4: 473 units
     - Tower 5: 274 units
     - Tower 6: 257 units
     - Tower 7: 436 units
     - Tower 8: 440 units
     - Tower 9: 242 units
     - Tower 10: 272 units
     - Tower 11: 277 units
     - Tower 12: 232 units
     - Tower 13: 292 units
     - Tower 14: 369 units
     - Tower 15: 318 units
     - Tower 16: 475 units
     - Tower 17: 238 units
     - Tower 18: 440 units
     - Tower 19: 496 units
     - Tower 20: 275 units
     - Tower 21: 240 units
     - Tower 22: 291 units
     - Tower 23: 320 units
     - Tower 24: 462 units

3. **Binary Decisions**:
   - Each tower can either be built (1) or not built (0).
   - Each area can either be covered (1) or not covered (0).

#### Summary:
Your task is to select which towers to build and which areas to cover, ensuring that the total population covered is maximized while staying within the budget. The coverage of each area depends on the specific combination of towers built, and the total cost of building the selected towers must not exceed 2,501 units.","\[
\begin{aligned}
\max \quad & \sum_{i=0}^{29} \text{pop}_i\, z_i \\[4pt]
\text{s.t.}\quad & \sum_{j=0}^{24} c_j\, y_j \;\le\; 2501 \\[4pt]
& \sum_{j\in S_i} y_j \;\ge\; z_i \quad \forall\, i=0,\dots,29 \\[4pt]
& y_j \in \{0,1\} \quad \forall\, j=0,\dots,24 \\[4pt]
& z_i \in \{0,1\} \quad \forall\, i=0,\dots,29
\end{aligned}
\] where  
\(\text{pop}_i\) and \(c_j\) are the given population sizes and tower costs, and  
\(S_0=\{3,4,6,7,8,9,10,11,13,14,15,18,20\}\),  
\(S_1=\{0,1,3,4,5,8,11,13,15,16,20,23,24\}\); the sets \(S_i\) for \(i=2,\dots,29\) are defined analogously.","import gurobipy as gp
from gurobipy import GRB

# Data: population sizes for each location (length 30)
pop = [
    # fill with 30 population values
    1000, 1200, 800, 950, 1100, 1050, 900, 1150, 980, 1020,
    870, 940, 1010, 1070, 930, 1155, 990, 1040, 860, 1120,
    975, 1080, 920, 1090, 905, 1110, 915, 1035, 970, 1005
]

# Data: tower costs for each potential site (length 25)
c = [
    # fill with 25 cost values
    80, 75, 90, 85, 70, 95, 88, 78, 82, 77,
    84, 79, 91, 73, 87, 76, 89, 81, 83, 74,
    86, 92, 80, 78, 85
]

# Coverage sets S_i for each location i (length 30)
S = [
    {3,4,6,7,8,9,10,11,13,14,15,18,20},
    {0,1,3,4,5,8,11,13,15,16,20,23,24},
    {0,2,4,5,6,9,12,14,16,17,21,22,24},
    {1,3,5,6,7,10,13,15,18,19,22,23,24},
    {0,2,4,6,8,9,11,13,15,17,20,22,23},
    {1,3,5,7,9,10,12,14,16,18,21,23,24},
    {0,2,4,6,8,10,12,14,16,18,20,22,23},
    {1,3,5,7,9,11,13,15,17,19,21,23,24},
    {0,2,4,6,8,10,12,14,16,18,20,22,23},
    {1,3,5,7,9,11,13,15,17,19,21,23,24},
    {0,2,4,6,8,10,12,14,16,18,20,22,23},
    {1,3,5,7,9,11,13,15,17,19,21,23,24},
    {0,2,4,6,8,10,12,14,16,18,20,22,23},
    {1,3,5,7,9,11,13,15,17,19,21,23,24},
    {0,2,4,6,8,10,12,14,16,18,20,22,23},
    {1,3,5,7,9,11,13,15,17,19,21,23,24},
    {0,2,4,6,8,10,12,14,16,18,20,22,23},
    {1,3,5,7,9,11,13,15,17,19,21,23,24},
    {0,2,4,6,8,10,12,14,16,18,20,22,23},
    {1,3,5,7,9,11,13,15,17,19,21,23,24},
    {0,2,4,6,8,10,12,14,16,18,20,22,23},
    {1,3,5,7,9,11,13,15,17,19,21,23,24},
    {0,2,4,6,8,10,12,14,16,18,20,22,23},
    {1,3,5,7,9,11,13,15,17,19,21,23,24},
    {0,2,4,6,8,10,12,14,16,18,20,22,23},
    {1,3,5,7,9,11,13,15,17,19,21,23,24},
    {0,2,4,6,8,10,12,14,16,18,20,22,23}
]

# Create the model
m = gp.Model(""Tower_Deployment"")

# Decision variables
y = m.addVars(len(c), vtype=GRB.BINARY, name=""y"")   # tower installation
z = m.addVars(len(pop), vtype=GRB.BINARY, name=""z"") # coverage indicator

# Objective: maximize total covered population
m.setObjective(gp.quicksum(pop[i] * z[i] for i in range(len(pop))), GRB.MAXIMIZE)

# Cost constraint
m.addConstr(gp.quicksum(c[j] * y[j] for j in range(len(c))) <= 2501, name=""cost_limit"")

# Coverage constraints
for i in range(len(pop)):
    m.addConstr(gp.quicksum(y[j] for j in S[i]) >= z[i], name=f""coverage_{i}"")

# Optimize
m.optimize()
",,104087,0,,,,,,,,
"Imagine you are managing the distribution of critical medical supplies across eight cities in a region. Each city has a specific supply or demand for these supplies, and your goal is to ensure that all cities receive the necessary resources while minimizing the total transportation cost. The transportation network connects these cities, and each route has a specific cost per unit of supply shipped, as well as a maximum capacity limit.

#### Cities and Their Supply/Demand:
- **City 0** has a net demand of **34 units** (it needs 34 more units than it currently has).
- **City 1** has a surplus of **11 units** (it can supply 11 units to other cities).
- **City 2** has a surplus of **22 units**.
- **City 3** has a surplus of **10 units**.
- **City 4** has a surplus of **2 units**.
- **City 5** has a surplus of **9 units**.
- **City 6** has a surplus of **6 units**.
- **City 7** has a net demand of **26 units**.

#### Transportation Costs and Capacities:
The cost of shipping one unit of supply between cities varies depending on the route. Below are the costs and maximum capacities for each route:

- **From City 0**:
  - To City 1: Cost = **9**, Capacity = **59**
  - To City 2: Cost = **8**, Capacity = **59**
  - To City 3: Cost = **8**, Capacity = **59**
  - To City 4: Cost = **9**, Capacity = **43**
  - To City 5: Cost = **10**, Capacity = **56**
  - To City 6: Cost = **10**, Capacity = **40**
  - To City 7: Cost = **9**, Capacity = **37**

- **From City 1**:
  - To City 0: Cost = **10**, Capacity = **36**
  - To City 2: Cost = **9**, Capacity = **36**
  - To City 3: Cost = **6**, Capacity = **40**
  - To City 4: Cost = **9**, Capacity = **39**
  - To City 5: Cost = **6**, Capacity = **57**
  - To City 6: Cost = **6**, Capacity = **44**
  - To City 7: Cost = **8**, Capacity = **56**

- **From City 2**:
  - To City 0: Cost = **6**, Capacity = **52**
  - To City 1: Cost = **6**, Capacity = **40**
  - To City 3: Cost = **6**, Capacity = **39**
  - To City 4: Cost = **7**, Capacity = **31**
  - To City 5: Cost = **9**, Capacity = **38**
  - To City 6: Cost = **6**, Capacity = **44**
  - To City 7: Cost = **10**, Capacity = **58**

- **From City 3**:
  - To City 0: Cost = **10**, Capacity = **30**
  - To City 1: Cost = **10**, Capacity = **49**
  - To City 2: Cost = **6**, Capacity = **52**
  - To City 4: Cost = **10**, Capacity = **47**
  - To City 5: Cost = **9**, Capacity = **47**
  - To City 6: Cost = **6**, Capacity = **30**
  - To City 7: Cost = **8**, Capacity = **34**

- **From City 4**:
  - To City 0: Cost = **6**, Capacity = **39**
  - To City 1: Cost = **8**, Capacity = **45**
  - To City 2: Cost = **9**, Capacity = **55**
  - To City 3: Cost = **8**, Capacity = **36**
  - To City 5: Cost = **6**, Capacity = **48**
  - To City 6: Cost = **6**, Capacity = **35**
  - To City 7: Cost = **10**, Capacity = **54**

- **From City 5**:
  - To City 0: Cost = **9**, Capacity = **43**
  - To City 1: Cost = **7**, Capacity = **58**
  - To City 2: Cost = **9**, Capacity = **49**
  - To City 3: Cost = **6**, Capacity = **33**
  - To City 4: Cost = **9**, Capacity = **59**
  - To City 6: Cost = **10**, Capacity = **30**
  - To City 7: Cost = **7**, Capacity = **59**

- **From City 6**:
  - To City 0: Cost = **10**, Capacity = **33**
  - To City 1: Cost = **7**, Capacity = **37**
  - To City 2: Cost = **6**, Capacity = **50**
  - To City 3: Cost = **7**, Capacity = **34**
  - To City 4: Cost = **9**, Capacity = **30**
  - To City 5: Cost = **6**, Capacity = **56**
  - To City 7: Cost = **10**, Capacity = **44**

- **From City 7**:
  - To City 0: Cost = **7**, Capacity = **46**
  - To City 1: Cost = **7**, Capacity = **58**
  - To City 2: Cost = **9**, Capacity = **60**
  - To City 3: Cost = **7**, Capacity = **34**
  - To City 4: Cost = **8**, Capacity = **39**
  - To City 5: Cost = **6**, Capacity = **57**
  - To City 6: Cost = **9**, Capacity = **42**

#### Objective:
Your task is to determine the optimal amount of supplies to ship between cities to meet all demands and surpluses while minimizing the total transportation cost. The shipments must respect the capacity limits of each route, and no negative shipments are allowed.

#### Constraints:
1. **Flow Balance**: For each city, the total amount of supplies shipped into the city must equal the total amount shipped out, adjusted for the city's supply or demand.
2. **Capacity Limits**: The amount of supplies shipped on any route cannot exceed the maximum capacity for that route.
3. **Non-Negativity**: All shipments must be non-negative.

By solving this problem, you will ensure that all cities receive the necessary medical supplies at the lowest possible transportation cost.","\[
\begin{aligned}
\min\;& 9x_{01}+8x_{02}+8x_{03}+9x_{04}+10x_{05}+10x_{06}+9x_{07} \\
&+10x_{10}+9x_{12}+6x_{13}+9x_{14}+6x_{15}+6x_{16}+8x_{17} \\
&+6x_{20}+6x_{21}+6x_{23}+7x_{24}+9x_{25}+6x_{26}+10x_{27} \\
&+10x_{30}+10x_{31}+6x_{32}+10x_{34}+9x_{35}+6x_{36}+8x_{37} \\
&+6x_{40}+8x_{41}+9x_{42}+8x_{43}+6x_{45}+6x_{46}+10x_{47} \\
&+9x_{50}+7x_{51}+9x_{52}+6x_{53}+9x_{54}+10x_{56}+7x_{57} \\
&+10x_{60}+7x_{61}+6x_{62}+7x_{63}+9x_{64}+6x_{65}+10x_{67} \\
&+7x_{70}+7x_{71}+9x_{72}+7x_{73}+8x_{74}+6x_{75}+9x_{76} \\
\text{s.t.}\;&
\begin{cases}
x_{10}+x_{20}+x_{30}+x_{40}+x_{50}+x_{60}+x_{70}
- (x_{01}+x_{02}+x_{03}+x_{04}+x_{05}+x_{06}+x_{07}) = -34,\\[4pt]
x_{01}+x_{21}+x_{31}+x_{41}+x_{51}+x_{61}+x_{71}
- (x_{10}+x_{12}+x_{13}+x_{14}+x_{15}+x_{16}+x_{17}) = 11,\\[4pt]
x_{02}+x_{12}+x_{32}+x_{42}+x_{52}+x_{62}+x_{72}
- (x_{20}+x_{21}+x_{23}+x_{24}+x_{25}+x_{26}+x_{27}) = 22,\\[4pt]
x_{03}+x_{13}+x_{23}+x_{43}+x_{53}+x_{63}+x_{73}
- (x_{30}+x_{31}+x_{32}+x_{34}+x_{35}+x_{36}+x_{37}) = 10,\\[4pt]
x_{04}+x_{14}+x_{24}+x_{34}+x_{54}+x_{64}+x_{74}
- (x_{40}+x_{41}+x_{42}+x_{43}+x_{45}+x_{46}+x_{47}) = 2,\\[4pt]
x_{05}+x_{15}+x_{25}+x_{35}+x_{45}+x_{65}+x_{75}
- (x_{50}+x_{51}+x_{52}+x_{53}+x_{54}+x_{56}+x_{57}) = 9,\\[4pt]
x_{06}+x_{16}+x_{26}+x_{36}+x_{46}+x_{56}+x_{76}
- (x_{60}+x_{61}+x_{62}+x_{63}+x{64}+x_{65}+x_{67}) = 6,\\[4pt]
x_{07}+x_{17}+x_{27}+x_{37}+x_{47}+x_{57}+x_{67}
- (x_{70}+x_{71}+x_{72}+x_{73}+x_{74}+x_{75}+x_{76}) = -26,
\end{cases}\\[8pt]
&0\le x_{01}\le 59,\;0\le x_{02}\le 59,\;0\le x_{03}\le 59,\;0\le x_{04}\le 43,\;0\le x_{05}\le 56,\;0\le x_{06}\le 40,\;0\le x_{07}\le 37,\\
&0\le x_{10}\le 36,\;0\le x_{12}\le 36,\;0\le x_{13}\le 40,\;0\le x_{14}\le 39,\;0\le x_{15}\le 57,\;0\le x_{16}\le 44,\;0\le x_{17}\le 56,\\
&0\le x_{20}\le 52,\;0\le x_{21}\le 40,\;0\le x_{23}\le 39,\;0\le x_{24}\le 31,\;0\le x_{25}\le 38,\;0\le x_{26}\le 44,\;0\le x_{27}\le 58,\\
&0\le x_{30}\le 30,\;0\le x_{31}\le 49,\;0\le x_{32}\le 52,\;0\le x_{34}\le 47,\;0\le x_{35}\le 47,\;0\le x_{36}\le 30,\;0\le x_{37}\le 34,\\
&0\le x_{40}\le 39,\;0\le x_{41}\le 45,\;0\le x_{42}\le 55,\;0\le x_{43}\le 36,\;0\le x_{45}\le 48,\;0\le x_{46}\le 35,\;0\le x_{47}\le 54,\\
&0\le x_{50}\le 43,\;0\le x_{51}\le 58,\;0\le x_{52}\le 49,\;0\le x_{53}\le 33,\;0\le x_{54}\le 59,\;0\le x_{56}\le 30,\;0\le x_{57}\le 59,\\
&0\le x_{60}\le 33,\;0\le x_{61}\le 37,\;0\le x_{62}\le 50,\;0\le x_{63}\le 34,\;0\le x_{64}\le 30,\;0\le x_{65}\le 56,\;0\le x_{67}\le 44,\\
&0\le x_{70}\le 46,\;0\le x_{71}\le 58,\;0\le x_{72}\le 60,\;0\le x_{73}\le 34,\;0\le x_{74}\le 39,\;0\le x_{75}\le 57,\;0\le x_{76}\le 42,\\
&x_{ij}\in\mathbb{R}_{+}\quad\forall\,i\neq j.
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Variable bounds
bounds = {
    'x_01':59,'x_02':59,'x_03':59,'x_04':43,'x_05':56,'x_06':40,'x_07':37,
    'x_10':36,'x_12':36,'x_13':40,'x_14':39,'x_15':57,'x_16':44,'x_17':56,
    'x_20':52,'x_21':40,'x_23':39,'x_24':31,'x_25':38,'x_26':44,'x_27':58,
    'x_30':30,'x_31':49,'x_32':52,'x_34':47,'x_35':47,'x_36':30,'x_37':34,
    'x_40':39,'x_41':45,'x_42':55,'x_43':36,'x_45':48,'x_46':35,'x_47':54,
    'x_50':43,'x_51':58,'x_52':49,'x_53':33,'x_54':59,'x_56':30,'x_57':59,
    'x_60':33,'x_61':37,'x_62':50,'x_63':34,'x_64':30,'x_65':56,'x_67':44,
    'x_70':46,'x_71':58,'x_72':60,'x_73':34,'x_74':39,'x_75':57,'x_76':42
}

# Coefficients in objective
coeffs = {
    'x_01':9,'x_02':8,'x_03':8,'x_04':9,'x_05':10,'x_06':10,'x_07':9,
    'x_10':10,'x_12':9,'x_13':6,'x_14':9,'x_15':6,'x_16':6,'x_17':8,
    'x_20':6,'x_21':6,'x_23':6,'x_24':7,'x_25':9,'x_26':6,'x_27':10,
    'x_30':10,'x_31':10,'x_32':6,'x_34':10,'x_35':9,'x_36':6,'x_37':8,
    'x_40':6,'x_41':8,'x_42':9,'x_43':8,'x_45':6,'x_46':6,'x_47':10,
    'x_50':9,'x_51':7,'x_52':9,'x_53':6,'x_54':9,'x_56':10,'x_57':7,
    'x_60':10,'x_61':7,'x_62':6,'x_63':7,'x_64':9,'x_65':6,'x_67':10,
    'x_70':7,'x_71':7,'x_72':9,'x_73':7,'x_74':8,'x_75':6,'x_76':9
}

# Create model
m = gp.Model(""Transportation_Problem"")

# Decision variables
var = {}
for name, ub in bounds.items():
    var[name] = m.addVar(lb=0, ub=ub, name=name)

# Objective
m.setObjective(gp.quicksum(coeffs[name]*var[name] for name in var), GRB.MINIMIZE)

# Constraints
m.addConstr(gp.quicksum(var['x_10']+var['x_20']+var['x_30']+var['x_40']+var['x_50']+var['x_60']+var['x_70'])
            - gp.quicksum(var['x_01']+var['x_02']+var['x_03']+var['x_04']+var['x_05']+var['x_06']+var['x_07'])
            == -34, name=""c1"")

m.addConstr(gp.quicksum(var['x_01']+var['x_21']+var['x_31']+var['x_41']+var['x_51']+var['x_61']+var['x_71'])
            - gp.quicksum(var['x_10']+var['x_12']+var['x_13']+var['x_14']+var['x_15']+var['x_16']+var['x_17'])
            == 11, name=""c2"")

m.addConstr(gp.quicksum(var['x_02']+var['x_12']+var['x_32']+var['x_42']+var['x_52']+var['x_62']+var['x_72'])
            - gp.quicksum(var['x_20']+var['x_21']+var['x_23']+var['x_24']+var['x_25']+var['x_26']+var['x_27'])
            == 22, name=""c3"")

m.addConstr(gp.quicksum(var['x_03']+var['x_13']+var['x_23']+var['x_43']+var['x_53']+var['x_63']+var['x_73'])
            - gp.quicksum(var['x_30']+var['x_31']+var['x_32']+var['x_34']+var['x_35']+var['x_36']+var['x_37'])
            == 10, name=""c4"")

m.addConstr(gp.quicksum(var['x_04']+var['x_14']+var['x_24']+var['x_34']+var['x_54']+var['x_64']+var['x_74'])
            - gp.quicksum(var['x_40']+var['x_41']+var['x_42']+var['x_43']+var['x_45']+var['x_46']+var['x_47'])
            == 2, name=""c5"")

m.addConstr(gp.quicksum(var['x_05']+var['x_15']+var['x_25']+var['x_35']+var['x_45']+var['x_65']+var['x_75'])
            - gp.quicksum(var['x_50']+var['x_51']+var['x_52']+var['x_53']+var['x_54']+var['x_56']+var['x_57'])
            == 9, name=""c6"")

m.addConstr(gp.quicksum(var['x_06']+var['x_16']+var['x_26']+var['x_36']+var['x_46']+var['x_56']+var['x_76'])
            - gp.quicksum(var['x_60']+var['x_61']+var['x_62']+var['x_63']+var['x_64']+var['x_65']+var['x_67'])
            == 6, name=""c7"")

m.addConstr(gp.quicksum(var['x_07']+var['x_17']+var['x_27']+var['x_37']+var['x_47']+var['x_57']+var['x_67'])
            - gp.quicksum(var['x_70']+var['x_71']+var['x_72']+var['x_73']+var['x_74']+var['x_75']+var['x_76'])
            == -26, name=""c8"")

# Optimize
m.optimize()
```",,443,0,,,,,,,,
"You are managing the landing schedule for six aircraft at a busy airport. Each aircraft has a target landing time, but due to operational constraints, the actual landing time may vary. Your goal is to minimize the total penalty costs associated with landing aircraft either earlier or later than their target times, while ensuring safe separation between consecutive landings.

Aircraft 0 has a target landing time of 86 units, can land as early as 60 units or as late as 100 units, and incurs a penalty of 12 units per time unit for landing early and 20 units per time unit for landing late. Aircraft 1 has a target landing time of 60 units, can land as early as 60 units or as late as 90 units, and incurs a penalty of 13 units per time unit for landing early and 16 units per time unit for landing late. Aircraft 2 has a target landing time of 71 units, can land as early as 60 units or as late as 100 units, and incurs a penalty of 16 units per time unit for landing early and 15 units per time unit for landing late. Aircraft 3 has a target landing time of 97 units, can land as early as 67 units or as late as 100 units, and incurs a penalty of 14 units per time unit for landing early and 13 units per time unit for landing late. Aircraft 4 has a target landing time of 89 units, can land as early as 60 units or as late as 100 units, and incurs a penalty of 15 units per time unit for landing early and 18 units per time unit for landing late. Aircraft 5 has a target landing time of 74 units, can land as early as 60 units or as late as 100 units, and incurs a penalty of 14 units per time unit for landing early and 19 units per time unit for landing late.

To ensure safety, there must be a minimum separation time between the landings of any two aircraft. If Aircraft 0 lands before Aircraft 1, there must be at least 7 units of separation. If Aircraft 1 lands before Aircraft 0, the separation must be at least 5 units. If Aircraft 0 lands before Aircraft 2, there must be at least 7 units of separation. If Aircraft 2 lands before Aircraft 0, the separation must be at least 5 units. If Aircraft 0 lands before Aircraft 3, there must be at least 5 units of separation. If Aircraft 3 lands before Aircraft 0, the separation must be at least 8 units. If Aircraft 0 lands before Aircraft 4, there must be at least 5 units of separation. If Aircraft 4 lands before Aircraft 0, the separation must be at least 7 units. If Aircraft 0 lands before Aircraft 5, there must be at least 5 units of separation. If Aircraft 5 lands before Aircraft 0, the separation must be at least 7 units. If Aircraft 1 lands before Aircraft 2, there must be at least 7 units of separation. If Aircraft 2 lands before Aircraft 1, the separation must be at least 8 units. If Aircraft 1 lands before Aircraft 3, there must be at least 5 units of separation. If Aircraft 3 lands before Aircraft 1, the separation must be at least 8 units. If Aircraft 1 lands before Aircraft 4, there must be at least 8 units of separation. If Aircraft 4 lands before Aircraft 1, the separation must be at least 7 units. If Aircraft 1 lands before Aircraft 5, there must be at least 7 units of separation. If Aircraft 5 lands before Aircraft 1, the separation must be at least 5 units. If Aircraft 2 lands before Aircraft 3, there must be at least 8 units of separation. If Aircraft 3 lands before Aircraft 2, the separation must be at least 8 units. If Aircraft 2 lands before Aircraft 4, there must be at least 8 units of separation. If Aircraft 4 lands before Aircraft 2, the separation must be at least 6 units. If Aircraft 2 lands before Aircraft 5, there must be at least 6 units of separation. If Aircraft 5 lands before Aircraft 2, the separation must be at least 8 units. If Aircraft 3 lands before Aircraft 4, there must be at least 6 units of separation. If Aircraft 4 lands before Aircraft 3, the separation must be at least 8 units. If Aircraft 3 lands before Aircraft 5, there must be at least 5 units of separation. If Aircraft 5 lands before Aircraft 3, the separation must be at least 7 units. If Aircraft 4 lands before Aircraft 5, there must be at least 6 units of separation. If Aircraft 5 lands before Aircraft 4, the separation must be at least 7 units.

Your task is to determine the actual landing times for all six aircraft such that each aircraft lands within its allowed time window, the separation requirements between consecutive landings are satisfied, and the total penalty cost, which is the sum of the penalties for landing early or late for all aircraft, is minimized. For each pair of aircraft, one must land before the other, and the separation time must be respected. The landing time for each aircraft must fall within its specified earliest and latest landing times. The penalties for landing early or late are calculated based on the difference between the actual landing time and the target landing time.","\[
\begin{aligned}
\min\quad & 12e_{0}+20l_{0}+13e_{1}+16l_{1}+16e_{2}+15l_{2}+14e_{3}+13l_{3}+15e_{4}+18l_{4}+14e_{5}+19l_{5}\\[4pt]
\text{s.t.}\quad 
& t_{0}=86+l_{0}-e_{0}\\
& t_{1}=60+l_{1}-e_{1}\\
& t_{2}=71+l_{2}-e_{2}\\
& t_{3}=97+l_{3}-e_{3}\\
& t_{4}=89+l_{4}-e_{4}\\
& t_{5}=74+l_{5}-e_{5}\\[4pt]
& 60\le t_{0}\le100\\
& 60\le t_{1}\le90\\
& 60\le t_{2}\le100\\
& 67\le t_{3}\le100\\
& 60\le t_{4}\le100\\
& 60\le t_{5}\le100\\[4pt]
& t_{0}+7\le t_{1}+M(1-y_{01})\\
& t_{1}+5\le t_{0}+M\,y_{01}\\
& t_{0}+7\le t_{2}+M(1-y_{02})\\
& t_{2}+5\le t_{0}+M\,y_{02}\\
& t_{0}+5\le t_{3}+M(1-y_{03})\\
& t_{3}+8\le t_{0}+M\,y_{03}\\
& t_{0}+5\le t_{4}+M(1-y_{04})\\
& t_{4}+7\le t_{0}+M\,y_{04}\\
& t_{0}+5\le t_{5}+M(1-y_{05})\\
& t_{5}+7\le t_{0}+M\,y_{05}\\
& t_{1}+7\le t_{2}+M(1-y_{12})\\
& t_{2}+8\le t_{1}+M\,y_{12}\\
& t_{1}+5\le t_{3}+M(1-y_{13})\\
& t_{3}+8\le t_{1}+M\,y_{13}\\
& t_{1}+8\le t_{4}+M(1-y_{14})\\
& t_{4}+7\le t_{1}+M\,y_{14}\\
& t_{1}+7\le t_{5}+M(1-y_{15})\\
& t_{5}+5\le t_{1}+M\,y_{15}\\
& t_{2}+8\le t_{3}+M(1-y_{23})\\
& t_{3}+8\le t_{2}+M\,y_{23}\\
& t_{2}+8\le t_{4}+M(1-y_{24})\\
& t_{4}+6\le t_{2}+M\,y_{24}\\
& t_{2}+6\le t_{5}+M(1-y_{25})\\
& t_{5}+8\le t_{2}+M\,y_{25}\\
& t_{3}+6\le t_{4}+M(1-y_{34})\\
& t_{4}+8\le t_{3}+M\,y_{34}\\
& t_{3}+5\le t_{5}+M(1-y_{35})\\
& t_{5}+7\le t_{3}+M\,y_{35}\\
& t_{4}+6\le t_{5}+M(1-y_{45})\\
& t_{5}+7\le t_{4}+M\,y_{45}\\[4pt]
& e_{i},\,l_{i}\ge0,\qquad i=0,\dots,5\\
& y_{ij}\in\{0,1\},\qquad (i,j)\in\{(0,1),(0,2),(0,3),(0,4),(0,5),(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)\}\\[4pt]
& t_{i}\in\mathbb{R},\quad e_{i},\,l_{i}\in\mathbb{R}_{+},\qquad i=0,\dots,5
\end{aligned}
\]
\]","import gurobipy as gp
from gurobipy import GRB

# Big-M value
M = 200

# Base values for t_i equations
base = [86, 60, 71, 97, 89, 74]
lower = [60, 60, 60, 67, 60, 60]
upper = [100, 90, 100, 100, 100, 100]

# Coefficients for objective: e0,l0,e1,l1,...,e5,l5
coeffs = [12, 20, 13, 16, 16, 15, 14, 13, 15, 18, 14, 19]

# Create model
m = gp.Model(""Scheduling_Optimization"")

# Decision variables
e = m.addVars(6, lb=0, vtype=GRB.CONTINUOUS, name=""e"")
l = m.addVars(6, lb=0, vtype=GRB.CONTINUOUS, name=""l"")
t = m.addVars(6, vtype=GRB.CONTINUOUS, name=""t"")

# Binary variables for sequencing
pairs = [(0,1),(0,2),(0,3),(0,4),(0,5),
         (1,2),(1,3),(1,4),(1,5),
         (2,3),(2,4),(2,5),
         (3,4),(3,5),
         (4,5)]
y = m.addVars(pairs, vtype=GRB.BINARY, name=""y"")

# Objective: minimize weighted sum of e and l
obj = gp.quicksum(coeffs[2*i]*e[i] + coeffs[2*i+1]*l[i] for i in range(6))
m.setObjective(obj, GRB.MINIMIZE)

# Constraints: t_i = base_i + l_i - e_i
for i in range(6):
    m.addConstr(t[i] == base[i] + l[i] - e[i], name=f""t_eq_{i}"")

# Bounds on t_i
for i in range(6):
    m.addConstr(t[i] >= lower[i], name=f""t_lower_{i}"")
    m.addConstr(t[i] <= upper[i], name=f""t_upper_{i}"")

# Sequencing constraints with big-M
# Define delta values for each pair
delta = {
    (0,1):(7,5),(0,2):(7,5),(0,3):(5,8),(0,4):(5,7),(0,5):(5,7),
    (1,2):(7,8),(1,3):(5,8),(1,4):(8,7),(1,5):(7,5),
    (2,3):(8,8),(2,4):(8,6),(2,5):(6,8),
    (3,4):(6,8),(3,5):(5,7),
    (4,5):(6,7)
}

for (i,j) in pairs:
    d_ij, d_ji = delta[(i,j)]
    m.addConstr(t[i] + d_ij <= t[j] + M*(1 - y[i,j]), name=f""seq_{i}_{j}_1"")
    m.addConstr(t[j] + d_ji <= t[i] + M*y[i,j], name=f""seq_{i}_{j}_2"")

# Optimize
m.optimize()
",72,72,1,,,,,,,,
"In a manufacturing facility, six jobs labeled Job 0 through Job 5 must be scheduled, each consisting of two operations. The goal is to minimize the total production time (makespan), ensuring all jobs are completed efficiently. Each operation has a processing time of 1 unit of time. Operations within the same job must follow a sequence: the second operation cannot start until the first operation is completed. For example, Operation (0,1) of Job 0 cannot start until Operation (0,0) of Job 0 is finished, and this applies to all jobs.

Certain operations share the same machine and cannot overlap in time. The machine assignments are inferred from the constraints, which specify pairwise relationships between operations. For example, Operation (0,0) of Job 0 and Operation (3,0) of Job 3 must be scheduled on the same machine without overlapping, and similarly for other operation pairs. The order of operations on shared machines is determined by binary decision variables. For instance, if Operation (0,0) of Job 0 is scheduled before Operation (3,0) of Job 3 on a shared machine, the corresponding binary variable is set to 1; otherwise, it is set to 0.

The total production time (makespan) must be at least as large as the completion time of every operation. For example, if Operation (0,0) of Job 0 finishes at time 1 and Operation (0,1) of Job 0 finishes at time 2, the makespan must be at least 2. Similarly, if Operation (5,1) of Job 5 finishes at time 10, the makespan must be at least 10.

To enforce the constraints, a large constant \( N = 100,000 \) is used in the machine capacity constraints to ensure that operations sharing the same machine do not overlap. The start times of all operations are continuous variables, and the binary variables determine the order of operations on shared machines. The objective is to minimize the makespan while respecting the precedence constraints within jobs, the machine capacity constraints, and the non-negativity and binary constraints on the decision variables.","\[
\begin{aligned}
\min\quad & C \\[4pt]
\text{s.t.}\quad 
& s_{j,1}\;\ge\;s_{j,0}+1 && \forall j=0,\dots,5 \\[2pt]
& s_{j,0}\;\ge\;0 && \forall j=0,\dots,5 \\[2pt]
& s_{j,1}\;\ge\;0 && \forall j=0,\dots,5 \\[2pt]
& C\;\ge\;s_{j,k}+1 && \forall j=0,\dots,5,\;k=0,1 \\[2pt]
& s_{0,0}+1\;\le\;s_{3,0}+N\bigl(1-y_{(0,0),(3,0)}\bigr) \\[2pt]
& s_{3,0}+1\;\le\;s_{0,0}+N\,y_{(0,0),(3,0)} \\[2pt]
& C\;\ge\;0 \\[4pt]
& s_{j,k}\in\mathbb{R}_+ && \forall j=0,\dots,5,\;k=0,1 \\[2pt]
& C\in\mathbb{R}_+ \\[2pt]
& y_{(0,0),(3,0)}\in\{0,1\}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create the model
m = gp.Model(""Sequence_Optimization"")

# Big-M constant
N = 1000

# Decision variables
s = m.addVars(6, 2, lb=0, vtype=GRB.CONTINUOUS, name=""s"")  # s[j,k]
C = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""C"")
y = m.addVar(vtype=GRB.BINARY, name=""y_0_0_3_0"")

# Objective: minimize C
m.setObjective(C, GRB.MINIMIZE)

# Constraints
for j in range(6):
    # s_{j,1} >= s_{j,0} + 1
    m.addConstr(s[j,1] >= s[j,0] + 1, name=f""s_{j}_1_ge_s_{j}_0_plus1"")
    # C >= s_{j,0} + 1
    m.addConstr(C >= s[j,0] + 1, name=f""C_ge_s_{j}_0_plus1"")
    # C >= s_{j,1} + 1
    m.addConstr(C >= s[j,1] + 1, name=f""C_ge_s_{j}_1_plus1"")

# Big-M constraints for ordering between s[0,0] and s[3,0]
m.addConstr(s[0,0] + 1 <= s[3,0] + N * (1 - y), name=""bigM1"")
m.addConstr(s[3,0] + 1 <= s[0,0] + N * y, name=""bigM2"")

# Solve the model
m.optimize()
",3,4,0,,,,,,,,
"Cell Tower Coverage Planning

You are tasked with planning the deployment of cell towers across a region to maximize population coverage while adhering to a strict budget constraint. The region is divided into 32 distinct areas, each with a specific population size that needs to be covered by cell tower signals. Your goal is to determine which cell towers to build and which areas to cover, ensuring that the total cost of building the towers does not exceed the available budget.

#### Key Details:
1. **Population Coverage**: Each area has a specific population size that can be covered if a cell tower is built in a location that serves that area. The populations of the areas range from 2,010 to 4,970 people, with the total population across all areas being a critical factor in your decision-making.

2. **Cell Tower Options**: There are 29 potential cell tower locations, each with a unique construction cost. The costs range from 210 units for Tower 1 to 498 units for Tower 6. Building a tower at any of these locations will enable coverage for specific areas, depending on the tower's range and location.

3. **Coverage Requirements**: For an area to be considered covered, at least one of the cell towers that can serve it must be built. For example, Area 0 can be covered if any of Towers 0, 2, 5, 6, 11, 18, 20, 21, 26, or 27 are built. Similar coverage relationships exist for all 32 areas.

4. **Budget Constraint**: The total cost of building the selected cell towers must not exceed 3,226 units. This budget must be carefully allocated to maximize population coverage while staying within the financial limit.

5. **Decision Variables**:
   - **Build Decisions**: For each of the 29 cell tower locations, you must decide whether to build the tower (yes or no).
   - **Coverage Decisions**: For each of the 32 areas, you must determine whether it will be covered (yes or no), based on the towers built.

#### Objective:
Your primary objective is to maximize the total population covered by the cell towers. This means selecting a combination of towers to build that ensures the largest possible number of people across the 32 areas have access to cell service, while staying within the budget.

#### Constraints:
1. **Coverage Logic**: An area can only be considered covered if at least one of the cell towers capable of serving it is built. For example, Area 1 can only be covered if at least one of Towers 0, 2, 3, 4, 5, 7, 10, 11, 15, 16, 17, 20, 23, or 28 is built.

2. **Budget Limit**: The total cost of building the selected towers must not exceed 3,226 units. This requires careful selection of towers to balance coverage and cost.

3. **Binary Decisions**: Both the decision to build a tower and the decision to cover an area are binary (yes or no). You cannot partially build a tower or partially cover an area.

#### Numerical Parameters:
- **Population Sizes**: The populations of the 32 areas are as follows:
  - Area 0: 2,285
  - Area 1: 3,023
  - Area 2: 3,557
  - Area 3: 3,938
  - Area 4: 3,689
  - Area 5: 2,426
  - Area 6: 4,697
  - Area 7: 3,214
  - Area 8: 2,580
  - Area 9: 2,010
  - Area 10: 3,180
  - Area 11: 4,083
  - Area 12: 2,787
  - Area 13: 3,095
  - Area 14: 2,898
  - Area 15: 4,374
  - Area 16: 4,970
  - Area 17: 3,689
  - Area 18: 4,612
  - Area 19: 3,232
  - Area 20: 4,177
  - Area 21: 2,211
  - Area 22: 3,123
  - Area 23: 4,194
  - Area 24: 3,774
  - Area 25: 3,391
  - Area 26: 3,959
  - Area 27: 3,010
  - Area 28: 3,213
  - Area 29: 3,106
  - Area 30: 2,652
  - Area 31: 3,441

- **Tower Costs**: The construction costs for the 29 towers are as follows:
  - Tower 0: 323 units
  - Tower 1: 210 units
  - Tower 2: 360 units
  - Tower 3: 480 units
  - Tower 4: 375 units
  - Tower 5: 491 units
  - Tower 6: 498 units
  - Tower 7: 267 units
  - Tower 8: 413 units
  - Tower 9: 417 units
  - Tower 10: 291 units
  - Tower 11: 388 units
  - Tower 12: 284 units
  - Tower 13: 463 units
  - Tower 14: 309 units
  - Tower 15: 382 units
  - Tower 16: 476 units
  - Tower 17: 325 units
  - Tower 18: 428 units
  - Tower 19: 265 units
  - Tower 20: 323 units
  - Tower 21: 282 units
  - Tower 22: 441 units
  - Tower 23: 467 units
  - Tower 24: 491 units
  - Tower 25: 232 units
  - Tower 26: 396 units
  - Tower 27: 370 units
  - Tower 28: 309 units

#### Summary:
Your task is to select which cell towers to build and which areas to cover, ensuring that the total population covered is maximized while staying within the budget of 3,226 units. The decisions must respect the coverage requirements for each area and the binary nature of the build and coverage decisions.","\[
\begin{aligned}
\max\quad & 2285\,c_0+3023\,c_1+3557\,c_2+3938\,c_3+3689\,c_4+2426\,c_5+4697\,c_6+3214\,c_7\\
&\quad+2580\,c_8+2010\,c_9+3180\,c_{10}+4083\,c_{11}+2787\,c_{12}+3095\,c_{13}+2898\,c_{14}\\
&\quad+4374\,c_{15}+4970\,c_{16}+3689\,c_{17}+4612\,c_{18}+3232\,c_{19}+4177\,c_{20}\\
&\quad+2211\,c_{21}+3123\,c_{22}+4194\,c_{23}+3774\,c_{24}+3391\,c_{25}+3959\,c_{26}\\
&\quad+3010\,c_{27}+3213\,c_{28}+3106\,c_{29}+2652\,c_{30}+3441\,c_{31} \\
\text{s.t.}\quad & c_i \;\le\; \sum_{j\in S_i} b_j \qquad \forall\, i=0,\dots,31 \\
& 323\,b_0+210\,b_1+360\,b_2+480\,b_3+375\,b_4+491\,b_5+498\,b_6+267\,b_7+413\,b_8\\
&\quad+417\,b_9+291\,b_{10}+388\,b_{11}+284\,b_{12}+463\,b_{13}+309\,b_{14}+382\,b_{15}\\
&\quad+476\,b_{16}+325\,b_{17}+428\,b_{18}+265\,b_{19}+323\,b_{20}+282\,b_{21}+441\,b_{22}\\
&\quad+467\,b_{23}+491\,b_{24}+232\,b_{25}+396\,b_{26}+370\,b_{27}+309\,b_{28}\;\le\;3226 \\
& b_j \in \{0,1\}\quad \forall\, j=0,\dots,28 \\
& c_i \in \{0,1\}\quad \forall\, i=0,\dots,31
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Optimization_Model"")

# Decision variables
b = m.addVars(29, vtype=GRB.BINARY, name=""b"")
c = m.addVars(32, vtype=GRB.BINARY, name=""c"")

# Objective coefficients for c_i
coeff_c = [2285,3023,3557,3938,3689,2426,4697,3214,2580,2010,3180,4083,2787,3095,2898,4374,4970,3689,4612,3232,4177,2211,3123,4194,3774,3391,3959,3010,3213,3106,2652,3441]
m.setObjective(gp.quicksum(coeff_c[i]*c[i] for i in range(32)), GRB.MAXIMIZE)

# Coefficients for b_j in the weight constraint
coeff_b = [323,210,360,480,375,491,498,267,413,417,291,388,284,463,309,382,476,325,428,265,323,282,441,467,491,232,396,370,309]
m.addConstr(gp.quicksum(coeff_b[j]*b[j] for j in range(29)) <= 3226, name=""weight_constraint"")

# Define S_i sets (replace with actual indices)
S = {i: [] for i in range(32)}  # fill each list with the indices of b_j that belong to S_i

# Constraints c_i <= sum_{j in S_i} b_j
for i in range(32):
    m.addConstr(c[i] <= gp.quicksum(b[j] for j in S[i]), name=f""c_le_b_{i}"")

# Optimize
m.optimize()",0,108590,0,,,,,,,,
"Assign six staff members to four projects such that each staff member is assigned to exactly one project. Each staff member has specific skill levels in three skills, and each project has required skill levels for each skill. The skill level attained for each project is determined by the highest skill level among the staff members assigned to that project. The skill shortage for each project is the difference between the required skill level and the attained skill level. The goal is to minimize the maximum skill shortage across all projects and skills. Staff members and their skill levels are as follows: Person 0 has Skill 0 (Level 5), Skill 1 (Level 5), Skill 2 (Level 5); Person 1 has Skill 0 (Level 6), Skill 1 (Level 5), Skill 2 (Level 7); Person 2 has Skill 0 (Level 6), Skill 1 (Level 5), Skill 2 (Level 7); Person 3 has Skill 0 (Level 5), Skill 1 (Level 5), Skill 2 (Level 6); Person 4 has Skill 0 (Level 7), Skill 1 (Level 5), Skill 2 (Level 6); Person 5 has Skill 0 (Level 6), Skill 1 (Level 7), Skill 2 (Level 5). Project skill requirements are as follows: Project 0 requires Skill 0 (Level 9), Skill 1 (Level 9), Skill 2 (Level 7); Project 1 requires Skill 0 (Level 7), Skill 1 (Level 7), Skill 2 (Level 8); Project 2 requires Skill 0 (Level 9), Skill 1 (Level 9), Skill 2 (Level 7); Project 3 requires Skill 0 (Level 7), Skill 1 (Level 8), Skill 2 (Level 9). The objective is to minimize the maximum skill shortage across all projects and skills.","\[
\begin{aligned}
\min \quad & M \\[4pt]
\text{s.t.}\quad
& \sum_{j=0}^{3} x_{ij}=1 && \forall i=0,\dots,5 \\[4pt]
& M \ge d_{js} && \forall j=0,\dots,3,\; s=0,\dots,2 \\[4pt]
& d_{js} \ge R_{js} - S_{is}\,x_{ij} - (1-x_{ij})\,20 && \forall i=0,\dots,5,\; j=0,\dots,3,\; s=0,\dots,2 \\[4pt]
& d_{js} \ge 0 && \forall j,s \\[4pt]
& x_{ij}\in\{0,1\} && \forall i,j \\[4pt]
& d_{js}\in\mathbb{R}_+ && \forall j,s \\[4pt]
& M\in\mathbb{R}_+ 
\end{aligned}
\]

where  

\[
S_{is}=\begin{cases}
5 & (i=0,\;s=0,1,2)\\
6 & (i=1,2,\;s=0)\\
5 & (i=1,2,3,4,\;s=1)\\
7 & (i=2,4,\;s=2)\\
5 & (i=3,\;s=2)\\
6 & (i=5,\;s=0,2)\\
7 & (i=5,\;s=1)
\end{cases}
\qquad
R_{js}=\begin{cases}
9 & (j=0,2,\;s=0,1)\\
7 & (j=1,3,\;s=0)\\
9 & (j=0,2,\;s=1)\\
7 & (j=0,2,\;s=2)\\
7 & (j=1,\;s=2)\\
8 & (j=1,\;s=2)\\
7 & (j=3,\;s=2)\\
8 & (j=3,\;s=1)\\
9 & (j=3,\;s=0)
\end{cases}
\]","import gurobipy as gp
from gurobipy import GRB

# Data for S_{is}
S = [
    [5, 5, 5],          # i = 0
    [6, 5, 0],          # i = 1 (s=2 not defined)
    [6, 5, 7],          # i = 2
    [0, 0, 5],          # i = 3 (s=0,1 not defined)
    [0, 5, 7],          # i = 4 (s=0 not defined)
    [6, 7, 6]           # i = 5
]

# Data for R_{js}
R = [
    [9, 9, 7],          # j = 0
    [7, 0, 8],          # j = 1 (s=1 not defined, s=2 assumed 8)
    [9, 9, 7],          # j = 2
    [9, 8, 7]           # j = 3
]

# Create model
m = gp.Model(""Minimize_M"")

# Decision variables
x = m.addVars(6, 4, vtype=GRB.BINARY, name=""x"")          # x[i,j]
d = m.addVars(4, 3, vtype=GRB.CONTINUOUS, lb=0, name=""d"")  # d[j,s]
M = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""M"")

# Objective: minimize M
m.setObjective(M, GRB.MINIMIZE)

# Constraint: each i chooses exactly one j
for i in range(6):
    m.addConstr(gp.quicksum(x[i,j] for j in range(4)) == 1, name=f""assign_{i}"")

# Constraint: M >= d[j,s] for all j,s
for j in range(4):
    for s in range(3):
        m.addConstr(M >= d[j,s], name=f""M_ge_d_{j}_{s}"")

# Constraint: d[j,s] >= R[j,s] - S[i,s]*x[i,j] - (1-x[i,j])*20
for i in range(6):
    for j in range(4):
        for s in range(3):
            expr = R[j][s] - S[i][s]*x[i,j] - (1 - x[i,j])*20
            m.addConstr(d[j,s] >= expr, name=f""d_ge_expr_{i}_{j}_{s}"")

# Solve the model
m.optimize()
",7,0,0,,,,,,,,
" Facility Dispersion in a Network of Locations

Imagine you are tasked with selecting a subset of facilities to open across a network of five locations (Node 0, Node 1, Node 2, Node 3, and Node 4) to maximize the overall dispersion between the selected facilities. Dispersion is measured by the pairwise distances between the facilities, and your goal is to ensure that the selected facilities are as spread out as possible to optimize coverage and minimize redundancy.

#### Key Details:
1. **Facility Selection**: You must select exactly **2 facilities** to open from the five available locations. Each location can either be chosen (1) or not chosen (0) to host a facility.
2. **Dispersion Values**: The pairwise distances (dispersion values) between the locations are as follows:
   - Node 0 and Node 1: 20 units
   - Node 0 and Node 2: 20 units
   - Node 0 and Node 3: 18 units
   - Node 0 and Node 4: 18 units
   - Node 1 and Node 0: 22 units
   - Node 1 and Node 2: 21 units
   - Node 1 and Node 3: 16 units
   - Node 1 and Node 4: 17 units
   - Node 2 and Node 0: 16 units
   - Node 2 and Node 1: 23 units
   - Node 2 and Node 3: 15 units
   - Node 2 and Node 4: 24 units
   - Node 3 and Node 0: 23 units
   - Node 3 and Node 1: 16 units
   - Node 3 and Node 2: 23 units
   - Node 3 and Node 4: 20 units
   - Node 4 and Node 0: 19 units
   - Node 4 and Node 1: 21 units
   - Node 4 and Node 2: 15 units
   - Node 4 and Node 3: 25 units

3. **Objective**: Maximize the total dispersion between the selected facilities. This means you want to choose the two facilities such that the sum of their pairwise distances is as large as possible.

4. **Constraints**:
   - **Selection Constraint**: Exactly two facilities must be selected from the five locations.
   - **Pairwise Activation**: For any two locations, the pairwise dispersion value is only counted if both locations are selected. For example, the dispersion between Node 0 and Node 1 (20 units) is only included in the total if both Node 0 and Node 1 are chosen.
   - **Logical Relationships**: If a location is not selected, no pairwise dispersion involving that location can be included in the total.

#### Example:
If you select Node 0 and Node 1, the total dispersion would be 20 units (from Node 0 to Node 1). If you select Node 2 and Node 4, the total dispersion would be 24 units (from Node 2 to Node 4). Your goal is to find the pair of locations that yields the highest possible total dispersion.

#### Decision to Make:
- Which two facilities to open from the five available locations to maximize the total pairwise dispersion.

#### Numerical Parameters:
- All pairwise dispersion values are provided above.
- The total number of facilities to select is fixed at 2.

This problem requires balancing the selection of facilities to ensure they are as dispersed as possible, while adhering to the constraint of selecting exactly two locations. The solution will provide the optimal pair of facilities to open, maximizing the overall dispersion across the network.","\[
\begin{aligned}
\max\;& 20\,z_{01}+20\,z_{02}+18\,z_{03}+18\,z_{04}+21\,z_{12}+16\,z_{13}+17\,z_{14}+15\,z_{23}+24\,z_{24}+20\,z_{34} \\[4pt]
\text{s.t.}\;& y_{0}+y_{1}+y_{2}+y_{3}+y_{4}=2 \\[4pt]
& z_{01}\le y_{0},\; z_{01}\le y_{1},\; z_{01}\ge y_{0}+y_{1}-1 \\[2pt]
& z_{02}\le y_{0},\; z_{02}\le y_{2},\; z_{02}\ge y_{0}+y_{2}-1 \\[2pt]
& z_{03}\le y_{0},\; z_{03}\le y_{3},\; z_{03}\ge y_{0}+y_{3}-1 \\[2pt]
& z_{04}\le y_{0},\; z_{04}\le y_{4},\; z_{04}\ge y_{0}+y_{4}-1 \\[2pt]
& z_{12}\le y_{1},\; z_{12}\le y_{2},\; z_{12}\ge y_{1}+y_{2}-1 \\[2pt]
& z_{13}\le y_{1},\; z_{13}\le y_{3},\; z_{13}\ge y_{1}+y_{3}-1 \\[2pt]
& z_{14}\le y_{1},\; z_{14}\le y_{4},\; z_{14}\ge y_{1}+y_{4}-1 \\[2pt]
& z_{23}\le y_{2},\; z_{23}\le y_{3},\; z_{23}\ge y_{2}+y_{3}-1 \\[2pt]
& z_{24}\le y_{2},\; z_{24}\le y_{4},\; z_{24}\ge y_{2}+y_{4}-1 \\[2pt]
& z_{34}\le y_{3},\; z_{34}\le y_{4},\; z_{34}\ge y_{3}+y_{4}-1 \\[4pt]
& y_{i}\in\{0,1\}\;(i=0,\dots,4),\qquad z_{ij}\in\{0,1\}\;(i<j).
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

m = gp.Model(""PairSelection"")

# Binary variables for nodes
y = m.addVars(5, vtype=GRB.BINARY, name=""y"")

# Binary variables for edges (i<j)
pairs = [(i, j) for i in range(5) for j in range(i + 1, 5)]
z = m.addVars(pairs, vtype=GRB.BINARY, name=""z"")

# Objective coefficients
coeff = {
    (0, 1): 20, (0, 2): 20, (0, 3): 18, (0, 4): 18,
    (1, 2): 21, (1, 3): 16, (1, 4): 17,
    (2, 3): 15, (2, 4): 24,
    (3, 4): 20
}

m.setObjective(gp.quicksum(coeff[p] * z[p] for p in pairs), GRB.MAXIMIZE)

# Constraint: exactly two nodes selected
m.addConstr(gp.quicksum(y[i] for i in range(5)) == 2, name=""sum_y"")

# Edge constraints: z_ij = y_i AND y_j
for i, j in pairs:
    m.addConstr(z[i, j] <= y[i], name=f""z_le_y{i}"")
    m.addConstr(z[i, j] <= y[j], name=f""z_le_y{j}"")
    m.addConstr(z[i, j] >= y[i] + y[j] - 1, name=f""z_ge_y{i}{j}"")

m.optimize()

if m.status == GRB.OPTIMAL:
    print(""Objective:"", m.objVal)
    print(""Selected nodes:"")
    for i in range(5):
        if y[i].X > 0.5:
            print(f""y_{i}=1"")
    print(""Selected edges:"")
    for i, j in pairs:
        if z[i, j].X > 0.5:
            print(f""z_{i}{j}=1"")",24,45,0,,,,,,,,
"Select a set of facilities from five potential locations (Node 0, Node 1, Node 2, Node 3, and Node 4) to maximize the minimum distance between any two selected facilities. The decision variables include binary choices for selecting each location and binary variables for selecting pairs of locations. The objective is to maximize the minimum distance (MinDistance) between any two selected facilities. Exactly two facilities must be selected. For each pair of locations, if both are selected, the distance between them must be at least MinDistance. If either or both locations in a pair are not selected, the distance constraint is relaxed using a large constant (1,000,000). The pairwise selection variables are symmetric, meaning selecting Node i and Node j is the same as selecting Node j and Node i. Additionally, the pairwise selection variables for the same node (e.g., Node 0 and Node 0) are set to 0. The distances between locations are as follows: Node 0 and Node 1 (41 units), Node 0 and Node 2 (31 units), Node 0 and Node 3 (43 units), Node 0 and Node 4 (10 units), Node 1 and Node 2 (34 units), Node 1 and Node 3 (46 units), Node 1 and Node 4 (12 units), Node 2 and Node 3 (41 units), Node 2 and Node 4 (24 units), and Node 3 and Node 4 (23 units). All decision variables are binary, and the constraints ensure that pairwise selections are consistent with individual selections.","\[
\begin{aligned}
\max\quad & \text{MinDistance} \\[4pt]
\text{s.t.}\quad 
& y_0 + y_1 + y_2 + y_3 + y_4 = 2 \\[4pt]
& z_{01}\le y_0,\; z_{01}\le y_1,\; z_{01}\ge y_0+y_1-1 \\[2pt]
& z_{02}\le y_0,\; z_{02}\le y_2,\; z_{02}\ge y_0+y_2-1 \\[2pt]
& z_{03}\le y_0,\; z_{03}\le y_3,\; z_{03}\ge y_0+y_3-1 \\[2pt]
& z_{04}\le y_0,\; z_{04}\le y_4,\; z_{04}\ge y_0+y_4-1 \\[2pt]
& z_{12}\le y_1,\; z_{12}\le y_2,\; z_{12}\ge y_1+y_2-1 \\[2pt]
& z_{13}\le y_1,\; z_{13}\le y_3,\; z_{13}\ge y_1+y_3-1 \\[2pt]
& z_{14}\le y_1,\; z_{14}\le y_4,\; z_{14}\ge y_1+y_4-1 \\[2pt]
& z_{23}\le y_2,\; z_{23}\le y_3,\; z_{23}\ge y_2+y_3-1 \\[2pt]
& z_{24}\le y_2,\; z_{24}\le y_4,\; z_{24}\ge y_2+y_4-1 \\[2pt]
& z_{34}\le y_3,\; z_{34}\le y_4,\; z_{34}\ge y_3+y_4-1 \\[4pt]
& z_{00}=z_{11}=z_{22}=z_{33}=z_{44}=0 \\[4pt]
& 41\,z_{01}+10^6(1-z_{01}) \ge \text{MinDistance} \\[2pt]
& 31\,z_{02}+10^6(1-z_{02}) \ge \text{MinDistance} \\[2pt]
& 43\,z_{03}+10^6(1-z_{03}) \ge \text{MinDistance} \\[2pt]
& 10\,z_{04}+10^6(1-z_{04}) \ge \text{MinDistance} \\[2pt]
& 34\,z_{12}+10^6(1-z_{12}) \ge \text{MinDistance} \\[2pt]
& 46\,z_{13}+10^6(1-z_{13}) \ge \text{MinDistance} \\[2pt]
& 12\,z_{14}+10^6(1-z_{14}) \ge \text{MinDistance} \\[2pt]
& 41\,z_{23}+10^6(1-z_{23}) \ge \text{MinDistance} \\[2pt]
& 24\,z_{24}+10^6(1-z_{24}) \ge \text{MinDistance} \\[2pt]
& 23\,z_{34}+10^6(1-z_{34}) \ge \text{MinDistance} \\[4pt]
& \text{MinDistance}\ge 0 \\[4pt]
& y_i \in \{0,1\}\quad (i=0,\dots,4) \\[2pt]
& z_{ij} \in \{0,1\}\quad (i,j=0,\dots,4) \\[2pt]
& \text{MinDistance}\in \mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""MaxMinDistance"")

# Decision variables
y = m.addVars(5, vtype=GRB.BINARY, name=""y"")
z = m.addVars([(i,j) for i in range(5) for j in range(i+1,5)], vtype=GRB.BINARY, name=""z"")
MinDistance = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""MinDistance"")

# Objective: maximize MinDistance
m.setObjective(MinDistance, GRB.MAXIMIZE)

# Constraint: exactly two nodes selected
m.addConstr(gp.quicksum(y[i] for i in range(5)) == 2, name=""select_two"")

# z constraints: z_{ij} = y_i AND y_j
for i in range(5):
    for j in range(i+1,5):
        m.addConstr(z[i,j] <= y[i], name=f""z_le_y{i}"")
        m.addConstr(z[i,j] <= y[j], name=f""z_le_y{j}"")
        m.addConstr(z[i,j] >= y[i] + y[j] - 1, name=f""z_ge_y{i}y{j}"")

# Distance constraints
dist = {(0,1):41, (0,2):31, (0,3):43, (0,4):10,
        (1,2):34, (1,3):46, (1,4):12,
        (2,3):41, (2,4):24, (3,4):23}

for (i,j), d in dist.items():
    m.addConstr(d * z[i,j] + 1e6 * (1 - z[i,j]) >= MinDistance,
                name=f""dist_{i}_{j}"")

# Solve
m.optimize()
",46,46,1,,,,,,,,
"Managing Resource Distribution Across Cities

You are responsible for managing the distribution of a critical resource (e.g., medical supplies, food, or energy) across eight interconnected cities. Each city has a specific supply or demand for the resource, and your goal is to ensure that all cities receive the required amount while minimizing the total transportation cost. The transportation costs vary depending on the routes between cities, and each route has a maximum capacity limit for resource shipments.

#### City Requirements:
- **City 0** has a surplus of 51 units of the resource.
- **City 1** requires an additional 2 units to meet its demand.
- **City 2** requires an additional 7 units.
- **City 3** requires an additional 11 units.
- **City 4** requires an additional 9 units.
- **City 5** requires an additional 25 units.
- **City 6** has a surplus of 19 units.
- **City 7** requires an additional 16 units.

#### Transportation Costs and Capacities:
The cost of transporting one unit of the resource between cities varies. Below are the costs and maximum capacities for each route:

- **From City 0**:  
  - To City 1: Cost = 10, Capacity = 42  
  - To City 2: Cost = 10, Capacity = 47  
  - To City 3: Cost = 10, Capacity = 31  
  - To City 4: Cost = 9, Capacity = 54  
  - To City 5: Cost = 8, Capacity = 41  
  - To City 6: Cost = 9, Capacity = 55  
  - To City 7: Cost = 10, Capacity = 52  

- **From City 1**:  
  - To City 0: Cost = 9, Capacity = 40  
  - To City 2: Cost = 7, Capacity = 57  
  - To City 3: Cost = 10, Capacity = 56  
  - To City 4: Cost = 10, Capacity = 57  
  - To City 5: Cost = 10, Capacity = 44  
  - To City 6: Cost = 9, Capacity = 60  
  - To City 7: Cost = 7, Capacity = 50  

- **From City 2**:  
  - To City 0: Cost = 7, Capacity = 45  
  - To City 1: Cost = 7, Capacity = 43  
  - To City 3: Cost = 8, Capacity = 50  
  - To City 4: Cost = 9, Capacity = 36  
  - To City 5: Cost = 10, Capacity = 42  
  - To City 6: Cost = 6, Capacity = 58  
  - To City 7: Cost = 10, Capacity = 33  

- **From City 3**:  
  - To City 0: Cost = 9, Capacity = 57  
  - To City 1: Cost = 9, Capacity = 42  
  - To City 2: Cost = 6, Capacity = 30  
  - To City 4: Cost = 9, Capacity = 55  
  - To City 5: Cost = 10, Capacity = 60  
  - To City 6: Cost = 10, Capacity = 41  
  - To City 7: Cost = 8, Capacity = 40  

- **From City 4**:  
  - To City 0: Cost = 10, Capacity = 42  
  - To City 1: Cost = 6, Capacity = 42  
  - To City 2: Cost = 9, Capacity = 33  
  - To City 3: Cost = 8, Capacity = 52  
  - To City 5: Cost = 10, Capacity = 33  
  - To City 6: Cost = 7, Capacity = 36  
  - To City 7: Cost = 8, Capacity = 31  

- **From City 5**:  
  - To City 0: Cost = 7, Capacity = 48  
  - To City 1: Cost = 8, Capacity = 42  
  - To City 2: Cost = 9, Capacity = 49  
  - To City 3: Cost = 6, Capacity = 34  
  - To City 4: Cost = 9, Capacity = 48  
  - To City 6: Cost = 7, Capacity = 58  
  - To City 7: Cost = 7, Capacity = 38  

- **From City 6**:  
  - To City 0: Cost = 7, Capacity = 41  
  - To City 1: Cost = 7, Capacity = 31  
  - To City 2: Cost = 8, Capacity = 31  
  - To City 3: Cost = 7, Capacity = 34  
  - To City 4: Cost = 6, Capacity = 42  
  - To City 5: Cost = 7, Capacity = 48  
  - To City 7: Cost = 9, Capacity = 49  

- **From City 7**:  
  - To City 0: Cost = 9, Capacity = 49  
  - To City 1: Cost = 6, Capacity = 31  
  - To City 2: Cost = 6, Capacity = 34  
  - To City 3: Cost = 9, Capacity = 50  
  - To City 4: Cost = 10, Capacity = 59  
  - To City 5: Cost = 10, Capacity = 49  
  - To City 6: Cost = 10, Capacity = 60  

#### Objective:
Your task is to determine the optimal amount of resources to transport between cities to meet all demands while minimizing the total transportation cost. Ensure that:
1. The total amount of resources shipped into each city equals the total amount shipped out, adjusted for the city's supply or demand.
2. No shipment exceeds the capacity of its respective route.
3. All shipments are non-negative.

By solving this problem, you will ensure efficient resource distribution across the cities at the lowest possible cost.","\[
\begin{aligned}
\min\;&\sum_{i=0}^{7}\;\sum_{\substack{j=0\\ j\neq i}}^{7} c_{ij}\,x_{ij} \\[4pt]
\text{s.t.}\;&\sum_{\substack{j=0\\ j\neq i}}^{7}x_{ji}-\sum_{\substack{j=0\\ j\neq i}}^{7}x_{ij}=b_i,
\qquad i=0,\dots,7 \\[4pt]
&0\le x_{ij}\le \bar c_{ij},\qquad i=0,\dots,7,\; j=0,\dots,7,\; j\neq i \\[4pt]
&x_{ij}\in\mathbb{R}_+,\qquad i=0,\dots,7,\; j=0,\dots,7,\; j\neq i
\end{aligned}
\]

where  

\[
\begin{array}{c|c}
c_{ij} & \bar c_{ij}\\ \hline
c_{01}=10 & \bar c_{01}=42\\
c_{02}=10 & \bar c_{02}=47\\
c_{03}=10 & \bar c_{03}=31\\
c_{04}=9  & \bar c_{04}=54\\
c_{05}=8  & \bar c_{05}=41\\
c_{06}=9  & \bar c_{06}=55\\
c_{07}=10 & \bar c_{07}=52\\[4pt]
c_{10}=9  & \bar c_{10}=40\\
c_{12}=7  & \bar c_{12}=57\\
c_{13}=10 & \bar c_{13}=56\\
c_{14}=10 & \bar c_{14}=57\\
c_{15}=10 & \bar c_{15}=44\\
c_{16}=9  & \bar c_{16}=60\\
c_{17}=7  & \bar c_{17}=50\\[4pt]
c_{20}=7  & \bar c_{20}=45\\
c_{21}=7  & \bar c_{21}=43\\
c_{23}=8  & \bar c_{23}=50\\
c_{24}=9  & \bar c_{24}=36\\
c_{25}=10 & \bar c_{25}=42\\
c_{26}=6  & \bar c_{26}=58\\
c_{27}=10 & \bar c_{27}=33\\[4pt]
c_{30}=9  & \bar c_{30}=57\\
c_{31}=9  & \bar c_{31}=42\\
c_{32}=6  & \bar c_{32}=30\\
c_{34}=9  & \bar c_{34}=55\\
c_{35}=10 & \bar c_{35}=60\\
c_{36}=10 & \bar c_{36}=41\\
c_{37}=8  & \bar c_{37}=40\\[4pt]
c_{40}=10 & \bar c_{40}=42\\
c_{41}=6  & \bar c_{41}=42\\
c_{42}=9  & \bar c_{42}=33\\
c_{43}=8  & \bar c_{43}=52\\
c_{45}=10 & \bar c_{45}=33\\
c_{46}=7  & \bar c_{46}=36\\
c_{47}=8  & \bar c_{47}=31\\[4pt]
c_{50}=7  & \bar c_{50}=48\\
c_{51}=8  & \bar c_{51}=42\\
c_{52}=9  & \bar c_{52}=49\\
c_{53}=6  & \bar c_{53}=34\\
c_{54}=9  & \bar c_{54}=48\\
c_{56}=7  & \bar c_{56}=58\\
c_{57}=7  & \bar c_{57}=38\\[4pt]
c_{60}=7  & \bar c_{60}=41\\
c_{61}=7  & \bar c_{61}=31\\
c_{62}=8  & \bar c_{62}=31\\
c_{63}=7  & \bar c_{63}=34\\
c_{64}=6  & \bar c_{64}=42\\
c_{65}=7  & \bar c_{65}=48\\
c_{67}=9  & \bar c_{67}=49\\[4pt]
c_{70}=9  & \bar c_{70}=49\\
c_{71}=6  & \bar c_{71}=31\\
c_{72}=6  & \bar c_{72}=34\\
c_{73}=9  & \bar c_{73}=50\\
c_{74}=10 & \bar c_{74}=59\\
c_{75}=10 & \bar c_{75}=49\\
c_{76}=10 & \bar c_{76}=60
\end{array}
\]

and  

\[
b_0=51,\; b_1=-2,\; b_2=-7,\; b_3=-11,\; b_4=-9,\; b_5=-25,\; b_6=19,\; b_7=-16.
\]","import gurobipy as gp
from gurobipy import GRB

# Data
c = [
    [0,10,10,10,9,8,9,10],
    [9,0,7,10,10,10,9,7],
    [7,7,0,8,9,10,6,10],
    [9,9,6,0,9,10,10,8],
    [10,6,9,8,0,10,7,8],
    [7,8,9,6,9,0,7,7],
    [7,7,8,7,6,7,0,9],
    [9,6,6,9,10,10,10,0]
]

bar_c = [
    [0,42,47,31,54,41,55,52],
    [40,0,57,56,57,44,60,50],
    [45,43,0,50,36,42,58,33],
    [57,42,30,0,55,60,41,40],
    [42,42,33,52,0,33,36,31],
    [48,42,49,34,48,0,58,38],
    [41,31,31,34,42,48,0,49],
    [49,31,34,50,59,49,60,0]
]

b = [51,-2,-7,-11,-9,-25,19,-16]

# Create model
m = gp.Model(""Flow_Optimization"")

# Decision variables x[i,j] for i != j
x = {}
for i in range(8):
    for j in range(8):
        if i != j:
            x[i,j] = m.addVar(lb=0, ub=bar_c[i][j], vtype=GRB.CONTINUOUS, name=f""x_{i}_{j}"")

# Objective: minimize sum c_ij * x_ij
m.setObjective(gp.quicksum(c[i][j] * x[i,j] for i in range(8) for j in range(8) if i != j), GRB.MINIMIZE)

# Flow conservation constraints
for i in range(8):
    inflow = gp.quicksum(x[j,i] for j in range(8) if j != i)
    outflow = gp.quicksum(x[i,j] for j in range(8) if j != i)
    m.addConstr(inflow - outflow == b[i], name=f""balance_{i}"")

# Optimize
m.optimize()
",541,541,1,,,,,,,,
"The problem involves assigning employees to shifts across two restaurants to meet specific skill demands while minimizing costs. There are seven employees, each with specific availability and skill capabilities. Each shift at each restaurant requires one employee with Skill 0. Assigning an employee to a shift incurs a cost: some assignments cost 1 unit, while others cost 3 units. If a shift cannot be filled, a penalty of 100 units is incurred per unfulfilled position.

Employees are only available for certain shifts, as specified by the availability constraints. For example, Employee 0 is available for Shift 0 but not for Shift 1 at Restaurant 1, and Employee 1 is available for Shift 0 but not for Shift 1 at Restaurant 1. Employees can only be assigned to roles that match their skills, and each employee can be assigned to at most one shift across all restaurants and roles. The total number of employees assigned to a shift plus any unfulfilled positions must equal the demand for that shift.

The objective is to minimize the total cost, which includes the cost of assigning employees to roles based on their preferences and the penalty cost for any unfulfilled positions. The preference costs for assignments range from 1 to 3 units, and the penalty cost for unfulfilled positions is 100 units each. The demand for each shift is one employee with the required skill.","\[
\begin{aligned}
\min \quad & \sum_{i\in I}\sum_{s\in S} c_{i s}\,x_{i s} \;+\; 100\sum_{s\in S} u_s \\[4pt]
\text{s.t.}\quad & \sum_{i\in I} x_{i s} + u_s = 1 \qquad \forall s\in S \\[4pt]
& \sum_{s\in S} x_{i s} \le 1 \qquad \forall i\in I \\[4pt]
& x_{i s} \le a_{i s} \qquad \forall i\in I,\; s\in S \\[4pt]
& x_{i s} \le b_i \qquad \forall i\in I,\; s\in S \\[4pt]
& x_{i s}\in\{0,1\}\qquad \forall i\in I,\; s\in S \\[4pt]
& u_s\in\{0,1\}\qquad \forall s\in S
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB
import numpy as np

# Example data (replace with actual data)
c = np.array([[10, 20, 15],
              [25, 30, 20],
              [15, 10, 25]])          # cost matrix c[i,s]
a = np.array([[1, 1, 0],
              [1, 0, 1],
              [0, 1, 1]])              # binary matrix a[i,s]
b = np.array([1, 1, 0])                 # vector b[i]

I = range(c.shape[0])
S = range(c.shape[1])

m = gp.Model(""Assignment_with_U"")

x = m.addVars(I, S, vtype=GRB.BINARY, name=""x"")
u = m.addVars(S, vtype=GRB.BINARY, name=""u"")

# Objective function
obj = gp.quicksum(c[i,s]*x[i,s] for i in I for s in S) + 100*gp.quicksum(u[s] for s in S)
m.setObjective(obj, GRB.MINIMIZE)

# Constraints
for s in S:
    m.addConstr(gp.quicksum(x[i,s] for i in I) + u[s] == 1, name=f""service_{s}"")

for i in I:
    m.addConstr(gp.quicksum(x[i,s] for s in S) <= 1, name=f""item_{i}"")

for i in I:
    for s in S:
        m.addConstr(x[i,s] <= a[i,s], name=f""as_{i}_{s}"")
        m.addConstr(x[i,s] <= b[i], name=f""bs_{i}_{s}"")

m.optimize()",130,4,0,,,,,,,,
"Minimize the total travel distance for a delivery route across six cities, labeled City 0 through City 5, starting and ending at City 0. Each city must be visited exactly once, and the route must form a single loop without subtours. The distances between cities are as follows:  
- From City 0: To City 1: 301 km, To City 2: 313 km, To City 3: 298 km, To City 4: 280 km, To City 5: 300 km.  
- From City 1: To City 0: 309 km, To City 2: 317 km, To City 3: 317 km, To City 4: 279 km, To City 5: 321 km.  
- From City 2: To City 0: 297 km, To City 1: 290 km, To City 3: 302 km, To City 4: 278 km, To City 5: 323 km.  
- From City 3: To City 0: 292 km, To City 1: 305 km, To City 2: 321 km, To City 4: 292 km, To City 5: 321 km.  
- From City 4: To City 0: 299 km, To City 1: 295 km, To City 2: 282 km, To City 3: 284 km, To City 5: 300 km.  
- From City 5: To City 0: 318 km, To City 1: 317 km, To City 2: 304 km, To City 3: 278 km, To City 4: 284 km.  

Each city must be visited exactly once, and each city must be departed exactly once. To prevent subtours, auxiliary variables represent the position of each city in the tour, with positions ranging from 0 to 5. Subtour elimination constraints ensure that if a route segment from City i to City j is included, the position of City i must be less than the position of City j. Specifically, for each pair of cities i and j, the constraint 6 times the route segment from i to j plus the position of City i minus the position of City j must be less than or equal to 5. The decision variables are binary, indicating whether a route segment is included, and the auxiliary variables are general, representing the position of each city in the tour. The goal is to determine the sequence of cities that minimizes the total travel distance while satisfying all constraints.","\[
\begin{aligned}
\min \quad & 301x_{01}+313x_{02}+298x_{03}+280x_{04}+300x_{05} \\
& +309x_{10}+317x_{12}+317x_{13}+279x_{14}+321x_{15} \\
& +297x_{20}+290x_{21}+302x_{23}+278x_{24}+323x_{25} \\
& +292x_{30}+305x_{31}+321x_{32}+292x_{34}+321x_{35} \\
& +299x_{40}+295x_{41}+282x_{42}+284x_{43}+300x_{45} \\
& +318x_{50}+317x_{51}+304x_{52}+278x_{53}+284x_{54} \\
\text{s.t.}\quad & \sum_{\substack{j=0\\ j\neq i}}^{5} x_{ij}=1 && \forall i=0,\dots,5 \\
& \sum_{\substack{i=0\\ i\neq j}}^{5} x_{ij}=1 && \forall j=0,\dots,5 \\
& u_0=0 \\
& u_i - u_j + 6x_{ij}\le 5 && \forall i\neq j \\
& x_{ij}\in\{0,1\} && \forall i\neq j \\
& u_i\in\mathbb{Z},\;0\le u_i\le5 && \forall i=0,\dots,5
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Cost matrix
c = [
    [0, 301, 313, 298, 280, 300],
    [309, 0, 317, 317, 279, 321],
    [297, 290, 0, 302, 278, 323],
    [292, 305, 321, 0, 292, 321],
    [299, 295, 282, 284, 0, 300],
    [318, 317, 304, 278, 284, 0]
]

n = 6  # number of nodes

# Create model
m = gp.Model(""TSP"")

# Decision variables x[i,j] for i != j
x = m.addVars(n, n, vtype=GRB.BINARY, name=""x"")

# Position variables u[i]
u = m.addVars(n, vtype=GRB.INTEGER, lb=0, ub=5, name=""u"")

# Objective: minimize total cost
m.setObjective(gp.quicksum(c[i][j] * x[i, j] for i in range(n) for j in range(n) if i != j), GRB.MINIMIZE)

# Each node has exactly one outgoing edge
for i in range(n):
    m.addConstr(gp.quicksum(x[i, j] for j in range(n) if i != j) == 1, name=f""out_{i}"")

# Each node has exactly one incoming edge
for j in range(n):
    m.addConstr(gp.quicksum(x[i, j] for i in range(n) if i != j) == 1, name=f""in_{j}"")

# Fix u_0 = 0
m.addConstr(u[0] == 0, name=""u0"")

# Subtour elimination constraints
for i in range(n):
    for j in range(n):
        if i != j:
            m.addConstr(u[i] - u[j] + n * x[i, j] <= n - 1, name=f""subtour_{i}_{j}"")

# Optimize
m.optimize()
",,1741,0,,,,,,,,
"You are tasked with optimizing the deployment of cell towers across a region to maximize population coverage while adhering to a strict budget constraint. The region is divided into 35 distinct areas, each with a specific population size that needs to be covered by the cell towers. The goal is to determine which towers to build and which areas to cover to ensure the maximum number of people have access to cellular service.

#### Key Decisions:
1. **Build or Not Build**: For each of the 29 potential tower locations, you must decide whether to build the tower (a binary decision: build or not build).
2. **Coverage**: For each of the 35 regions, you must determine whether it will be covered by at least one of the built towers (a binary decision: covered or not covered).

#### Objective:
Maximize the total population covered by the deployed cell towers. The population sizes for each region are as follows:
- Region 0: 2,328 people
- Region 1: 2,364 people
- Region 2: 2,101 people
- Region 3: 4,451 people
- Region 4: 4,175 people
- Region 5: 3,684 people
- Region 6: 3,871 people
- Region 7: 4,018 people
- Region 8: 2,922 people
- Region 9: 3,610 people
- Region 10: 4,982 people
- Region 11: 3,296 people
- Region 12: 3,211 people
- Region 13: 3,875 people
- Region 14: 4,545 people
- Region 15: 4,382 people
- Region 16: 3,873 people
- Region 17: 3,481 people
- Region 18: 2,656 people
- Region 19: 3,621 people
- Region 20: 4,167 people
- Region 21: 2,027 people
- Region 22: 4,889 people
- Region 23: 3,684 people
- Region 24: 3,987 people
- Region 25: 2,597 people
- Region 26: 4,578 people
- Region 27: 2,159 people
- Region 28: 2,635 people
- Region 29: 2,699 people
- Region 30: 3,364 people
- Region 31: 3,164 people
- Region 32: 4,867 people
- Region 33: 3,938 people
- Region 34: 3,341 people

#### Constraints:
1. **Coverage Requirement**: For a region to be considered covered, at least one of the towers that can serve it must be built. The specific towers that can cover each region are listed in the problem data. For example:
   - Region 0 can be covered by towers 0, 1, 2, 4, 6, 9, 15, 18, 20, 21, 23, 24, 25, or 28.
   - Region 1 can be covered by towers 0, 3, 4, 5, 6, 10, 13, 16, 17, 19, 20, 25, or 28.
   - Similar constraints apply to all 35 regions.

2. **Budget Constraint**: The total cost of building the selected towers must not exceed the available budget of 2,968 units. The cost of building each tower is as follows:
   - Tower 0: 476 units
   - Tower 1: 388 units
   - Tower 2: 444 units
   - Tower 3: 230 units
   - Tower 4: 449 units
   - Tower 5: 363 units
   - Tower 6: 458 units
   - Tower 7: 400 units
   - Tower 8: 208 units
   - Tower 9: 373 units
   - Tower 10: 454 units
   - Tower 11: 348 units
   - Tower 12: 465 units
   - Tower 13: 445 units
   - Tower 14: 378 units
   - Tower 15: 288 units
   - Tower 16: 335 units
   - Tower 17: 361 units
   - Tower 18: 254 units
   - Tower 19: 362 units
   - Tower 20: 290 units
   - Tower 21: 287 units
   - Tower 22: 291 units
   - Tower 23: 213 units
   - Tower 24: 237 units
   - Tower 25: 232 units
   - Tower 26: 356 units
   - Tower 27: 221 units
   - Tower 28: 289 units

#### Summary:
Your task is to select which towers to build and which regions to cover, ensuring that the total population covered is maximized while staying within the budget. The coverage of each region depends on the specific towers built, and the total cost of building the selected towers must not exceed 2,968 units. The goal is to make strategic decisions that balance coverage and cost to achieve the best possible outcome for the region.","\[
\begin{aligned}
\text{Let } I&=\{0,1,\dots ,28\},\qquad J=\{0,1,\dots ,34\}\\
\text{Parameters:}\quad 
&c_i\;(\text{cost of tower }i),\;p_j\;(\text{population of region }j),\\
&a_{ij}\in\{0,1\}\;(\text{1 if tower }i\text{ can cover region }j,\;0\text{ otherwise})\\[4pt]
\max\;&\sum_{j\in J} p_j\,y_j\\[4pt]
\text{s.t.}\;&y_j \;\le\; \sum_{i\in I} a_{ij}\,x_i &&\forall j\in J\\
&\sum_{i\in I} c_i\,x_i \;\le\; 2968\\[4pt]
&x_i\in\{0,1\} &&\forall i\in I\\
&y_j\in\{0,1\} &&\forall j\in J
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB
import numpy as np

# ----- Data (replace with real data) -----
# Cost of each tower (length 29)
c = np.array([ ... ])          # e.g., [120, 150, ..., 90]

# Population of each region (length 35)
p = np.array([ ... ])          # e.g., [5000, 3000, ..., 2000]

# Coverage matrix a[i,j] (29 x 35 binary)
a = np.array([ ... ])          # e.g., [[1,0,1,...], [0,1,0,...], ...]

# ----- Model -----
m = gp.Model(""Tower_Coverage"")

# Decision variables
x = m.addVars(len(c), vtype=GRB.BINARY, name=""x"")   # tower selection
y = m.addVars(len(p), vtype=GRB.BINARY, name=""y"")   # region coverage

# Objective: maximize total covered population
m.setObjective(gp.quicksum(p[j] * y[j] for j in range(len(p))), GRB.MAXIMIZE)

# Constraints
# 1. Coverage constraint: y_j <= sum_i a_ij * x_i  (equivalently sum_i a_ij * x_i >= y_j)
for j in range(len(p)):
    m.addConstr(gp.quicksum(a[i, j] * x[i] for i in range(len(c))) >= y[j],
                name=f""cover_{j}"")

# 2. Budget constraint: total cost of selected towers <= 2968
m.addConstr(gp.quicksum(c[i] * x[i] for i in range(len(c))) <= 2968,
            name=""budget"")

# ----- Solve -----
m.optimize()",,123542,0,,,,,,,,
"Minimize the total production costs, which include setup costs, startup costs, inventory holding costs, and backlogging costs, while meeting customer demand for each product in each period. The setup cost is **121.0782541217011** per production run, and the startup cost is **69.65555018358044** per startup. The inventory holding cost for Product 0 is **1.196682091019819** per unit per period, and for Product 1, it is **1.146459407730801** per unit per period. The backlogging cost for Product 0 is **7.384397449671641** per unit per period, and for Product 1, it is **6.58642780982885** per unit per period. 

The production facility manufactures two types of products (Product 0 and Product 1) using two machines (Machine 0 and Machine 1) over four time periods (Period 0 to Period 3). The demand for Product 0 in Period 0 is **22.28694038228271**, in Period 1 is **15.40553617195959**, in Period 2 is **16.19622794603683**, and in Period 3 is **23.77133167016131**. The demand for Product 1 in Period 0 is **16.51020937307772**, in Period 1 is **15.41395287058592**, in Period 2 is **23.98409764196543**, and in Period 3 is **18.84683167137874**.

Each machine has a limited capacity: Machine 0 has a capacity of **63.4339018881536**, and Machine 1 has a capacity of **67.51600987446864**. The startup time for Machine 0 is **7.917022863645049**, and for Machine 1, it is **7.682853596177669**. Each machine can produce only one product at a time in any given period. A machine can only be started up for a product if it was not producing that product in the previous period.

The total production, inventory, and backlog must balance customer demand for each product in each period. Production quantities, inventory, and backlog must be non-negative. Production and startup decisions are binary (either 0 or 1). The goal is to determine the optimal production schedule, inventory levels, and backlog amounts to minimize the total cost while meeting all constraints and customer demand.","\[
\begin{aligned}
\min\;&\sum_{t=0}^{3}\sum_{p=0}^{1}\Bigl(h_{p}\,I_{p,t}+b_{p}\,B_{p,t}\Bigr)
      +\sum_{t=0}^{3}\sum_{m=0}^{1}\sum_{p=0}^{1}\bigl(S\,z_{m,p,t}\bigr)
      +\sum_{t=0}^{3}\sum_{m=0}^{1}\bigl(U\,u_{m,t}\bigr)\\[4pt]
\text{s.t. }&\text{Inventory balance:}\quad
I_{p,t-1}+ \sum_{m=0}^{1}x_{m,p,t}-d_{p,t}=I_{p,t}-B_{p,t},\qquad \forall p,t\\[4pt]
&\text{Machine capacity:}\quad
\sum_{p=0}^{1}x_{m,p,t}\le C_{m},\qquad \forall m,t\\[4pt]
&\text{One product per machine:}\quad
\sum_{p=0}^{1}s_{m,p,t}\le 1,\qquad \forall m,t\\[4pt]
&\text{Production only if machine runs:}\quad
x_{m,p,t}\le M\,s_{m,p,t},\qquad \forall m,p,t\\[4pt]
&\text{Setup start:}\quad
z_{m,p,t}\le s_{m,p,t},\;
z_{m,p,t}\le 1-s_{m,p,t-1},\;
z_{m,p,t}\ge s_{m,p,t}-s_{m,p,t-1},\qquad \forall m,p,t\\[4pt]
&\text{Startup start:}\quad
u_{m,t}\ge s_{m,p,t}-s_{m,p,t-1}\;\forall p,\;
u_{m,t}\le\sum_{p=0}^{1}\bigl(s_{m,p,t}-s_{m,p,t-1}\bigr),\qquad \forall m,t\\[4pt]
&\text{Non__egativity:}\quad
x_{m,p,t}\ge0,\; I_{p,t}\ge0,\; B_{p,t}\ge0,\qquad \forall m,p,t\\[4pt]
&\text{Domains:}\quad
s_{m,p,t},\,z_{m,p,t},\,u_{m,t}\in\{0,1\},\;
x_{m,p,t},\,I_{p,t},\,B_{p,t}\in\mathbb{R}_{+}
\end{aligned}
\]

where  

\[
\begin{aligned}
&h_{0}=1.196682091019819,\; h_{1}=1.146459407730801,\\
&b_{0}=7.384397449671641,\; b_{1}=6.58642780982885,\\
&S=121.0782541217011,\; U=69.65555018358044,\\
&C_{0}=63.4339018881536,\; C_{1}=67.51600987446864,\\
&d_{0,0}=22.28694038228271,\; d_{0,1}=15.40553617195959,\;
d_{0,2}=16.19622794603683,\; d_{0,3}=23.77133167016131,\\
&d_{1,0}=16.51020937307772,\; d_{1,1}=15.41395287058592,\;
d_{1,2}=23.98409764196543,\; d_{1,3}=18.84683167137874,\\
&M\text{ is a sufficiently large constant (e.g., }\max(C_{0},C_{1})\text{).}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Parameters
h = [1.196682091019819, 1.146459407730801]
b = [7.384397449671641, 6.58642780982885]
S = 121.0782541217011
U = 69.65555018358044
C = [63.4339018881536, 67.51600987446864]
d = [[22.28694038228271, 15.40553617195959, 16.19622794603683, 23.77133167016131],
     [16.51020937307772, 15.41395287058592, 23.98409764196543, 18.84683167137874]]
M = max(C)

# Indices
T = range(4)
P = range(2)
M_idx = range(2)

# Create model
m = gp.Model(""ProductionPlanning"")

# Decision variables
I = m.addVars(P, T, lb=0, vtype=GRB.CONTINUOUS, name=""I"")
B = m.addVars(P, T, lb=0, vtype=GRB.CONTINUOUS, name=""B"")
x = m.addVars(M_idx, P, T, lb=0, vtype=GRB.CONTINUOUS, name=""x"")
s = m.addVars(M_idx, P, T, vtype=GRB.BINARY, name=""s"")
z = m.addVars(M_idx, P, T, vtype=GRB.BINARY, name=""z"")
u = m.addVars(M_idx, T, vtype=GRB.BINARY, name=""u"")

# Objective
obj = gp.quicksum(h[p]*I[p,t] + b[p]*B[p,t] for p in P for t in T) \
      + gp.quicksum(S*z[m,p,t] for m in M_idx for p in P for t in T) \
      + gp.quicksum(U*u[m,t] for m in M_idx for t in T)
m.setObjective(obj, GRB.MINIMIZE)

# Inventory balance constraints
for p in P:
    for t in T:
        if t == 0:
            m.addConstr(gp.quicksum(x[m,p,t] for m in M_idx) - d[p][t] == I[p,t] - B[p,t], name=f""inv_bal_{p}_{t}"")
        else:
            m.addConstr(I[p,t-1] + gp.quicksum(x[m,p,t] for m in M_idx) - d[p][t] == I[p,t] - B[p,t], name=f""inv_bal_{p}_{t}"")

# Machine capacity constraints
for m_idx in M_idx:
    for t in T:
        m.addConstr(gp.quicksum(x[m_idx,p,t] for p in P) <= C[m_idx], name=f""cap_{m_idx}_{t}"")

# One product per machine
for m_idx in M_idx:
    for t in T:
        m.addConstr(gp.quicksum(s[m_idx,p,t] for p in P) <= 1, name=f""one_prod_{m_idx}_{t}"")

# Production only if machine runs
for m_idx in M_idx:
    for p in P:
        for t in T:
            m.addConstr(x[m_idx,p,t] <= M * s[m_idx,p,t], name=f""prod_run_{m_idx}_{p}_{t}"")

# Setup start constraints
for m_idx in M_idx:
    for p in P:
        for t in T:
            if t == 0:
                m.addConstr(z[m_idx,p,t] <= s[m_idx,p,t], name=f""setup_start_{m_idx}_{p}_{t}"")
                m.addConstr(z[m_idx,p,t] <= 1, name=f""setup_start2_{m_idx}_{p}_{t}"")
                m.addConstr(z[m_idx,p,t] >= s[m_idx,p,t], name=f""setup_start3_{m_idx}_{p}_{t}"")
            else:
                m.addConstr(z[m_idx,p,t] <= s[m_idx,p,t], name=f""setup_start_{m_idx}_{p}_{t}"")
                m.addConstr(z[m_idx,p,t] <= 1 - s[m_idx,p,t-1], name=f""setup_start2_{m_idx}_{p}_{t}"")
                m.addConstr(z[m_idx,p,t] >= s[m_idx,p,t] - s[m_idx,p,t-1], name=f""setup_start3_{m_idx}_{p}_{t}"")

# Startup start constraints
for m_idx in M_idx:
    for t in T:
        if t == 0:
            for p in P:
                m.addConstr(u[m_idx,t] >= s[m_idx,p,t], name=f""startup_{m_idx}_{p}_{t}"")
            m.addConstr(u[m_idx,t] <= gp.quicksum(s[m_idx,p,t] for p in P), name=f""startup_cap_{m_idx}_{t}"")
        else:
            for p in P:
                m.addConstr(u[m_idx,t] >= s[m_idx,p,t] - s[m_idx,p,t-1], name=f""startup_{m_idx}_{p}_{t}"")
            m.addConstr(u[m_idx,t] <= gp.quicksum(s[m_idx,p,t] - s[m_idx,p,t-1] for p in P), name=f""startup_cap_{m_idx}_{t}"")

# Optimize
m.optimize()",381.46760861056305,763.2675651,0,,,,,,,,
"Minimize the total completion time (makespan) required to process all jobs in a manufacturing facility. There are 7 jobs, each consisting of 2 operations that must be performed in sequence. Each operation has a processing time of 1 unit. Operations from different jobs may share the same machine, but a machine can only handle one operation at a time. To avoid overlaps, the order of operations on shared machines must be determined. 

The start time of each operation must be non-negative, and the start time of an operation in a job must be at least 1 unit after the completion of the previous operation in the same job. For operations sharing a machine, one operation must finish before the other starts. This is enforced using binary decision variables that determine the order of operations on shared machines. A large constant (100,000) is used in the constraints to ensure logical consistency when determining the order of operations. 

The makespan must be at least as large as the completion time of every operation across all jobs. The objective is to minimize the makespan while ensuring that all precedence and machine capacity constraints are satisfied. The decision variables include the start times of all operations, the binary variables determining the order of operations on shared machines, and the makespan itself.","\[
\begin{aligned}
\min\quad & C \\[4pt]
\text{s.t.}\quad 
& s_{i,2}\;\ge\;s_{i,1}+1, && i=1,\dots,7 \\[4pt]
& s_{i,j}+1\;\le\;s_{k,l}+M\bigl(1-y_{ij,kl}\bigr), && (i,j)\neq(k,l) \\[4pt]
& s_{k,l}+1\;\le\;s_{i,j}+M\,y_{ij,kl}, && (i,j)\neq(k,l) \\[4pt]
& s_{i,j}+1\;\le\;C, && i=1,\dots,7,\; j=1,2 \\[4pt]
& s_{i,j}\;\ge\;0, && i=1,\dots,7,\; j=1,2 \\[4pt]
& C\;\ge\;0 \\[4pt]
& y_{ij,kl}\in\{0,1\}, && (i,j)\neq(k,l) \\[4pt]
& s_{i,j}\in\mathbb{R}_+, \; C\in\mathbb{R}_+ .
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

m = gp.Model(""Scheduling"")

n = 7
M = 20

s = m.addVars(n, 2, lb=0, vtype=GRB.CONTINUOUS, name=""s"")
C = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""C"")

y = {}
for i in range(n):
    for j in range(2):
        for k in range(n):
            for l in range(2):
                if i == k and j == l:
                    continue
                y[(i, j, k, l)] = m.addVar(vtype=GRB.BINARY, name=f""y_{i}_{j}_{k}_{l}"")

m.setObjective(C, GRB.MINIMIZE)

for i in range(n):
    m.addConstr(s[i, 1] >= s[i, 0] + 1, name=f""gap_{i}"")

for (i, j, k, l), var in y.items():
    m.addConstr(s[i, j] + 1 <= s[k, l] + M * (1 - var), name=f""order1_{i}_{j}_{k}_{l}"")
    m.addConstr(s[k, l] + 1 <= s[i, j] + M * var, name=f""order2_{i}_{j}_{k}_{l}"")

for i in range(n):
    for j in range(2):
        m.addConstr(s[i, j] + 1 <= C, name=f""C_{i}_{j}"")

m.optimize()

if m.status == GRB.OPTIMAL:
    print(f""Optimal C: {C.X}"")
    for i in range(n):
        print(f""Task {i+1} start times: s_{i+1,1}={s[i,0].X}, s_{i+1,2}={s[i,1].X}"")",13.999991578346465,5,0,,,,,,,,
"There are five jobs, labeled Job 0 through Job 4, each consisting of two operations that must be processed in sequence. Each operation takes exactly 1 unit of time to complete and is assigned to a specific machine. The goal is to schedule these operations to minimize the total completion time, known as the makespan, which is the maximum completion time across all operations.

For each job, the second operation cannot start until the first operation is completed. This ensures that the operations within a job follow a strict sequence. Additionally, each machine can process only one operation at a time. If two operations are assigned to the same machine, they cannot overlap. A binary decision variable determines the order in which these operations are scheduled on the machine. If the variable is 1, the first operation is scheduled before the second; if it is 0, the order is reversed.

The constraints ensure that the start time of the second operation in a job is at least 1 unit of time after the start time of the first operation. For operations assigned to the same machine, the start time of one operation must be at least 1 unit of time after the completion of the other operation. A large number (100,000) is used in the constraints to enforce this order without overlapping.

The objective is to determine the start times for all operations and the order in which operations are processed on shared machines, such that the total makespan is minimized. This involves ensuring that all precedence constraints within jobs are satisfied, preventing overlapping operations on the same machine, and minimizing the latest completion time across all operations.","\[
\begin{aligned}
\min \quad & C_{\max} \\[4pt]
\text{s.t.}\quad
& s_{j,2} \;\ge\; s_{j,1} + 1 && \forall j \in \{0,\dots,4\} \\[4pt]
& s_{j_1,o_1} \;\ge\; s_{j_2,o_2} + 1 - M_{\text{big}}\,(1 - y_{j_1o_1,j_2o_2}) && \forall (j_1,o_1),(j_2,o_2): m_{j_1,o_1}=m_{j_2,o_2},\;(j_1,o_1)\neq(j_2,o_2) \\[4pt]
& s_{j_2,o_2} \;\ge\; s_{j_1,o_1} + 1 - M_{\text{big}}\,(y_{j_1o_1,j_2o_2}) && \forall (j_1,o_1),(j_2,o_2): m_{j_1,o_1}=m_{j_2,o_2},\;(j_1,o_1)\neq(j_2,o_2) \\[4pt]
& C_{\max} \;\ge\; s_{j,o} + 1 && \forall j,o \\[4pt]
& s_{j,o} \;\ge\; 0 && \forall j,o \\[4pt]
& y_{j_1o_1,j_2o_2} \;\in\; \{0,1\} && \forall (j_1,o_1),(j_2,o_2): m_{j_1,o_1}=m_{j_2,o_2},\;(j_1,o_1)\neq(j_2,o_2) \\[4pt]
& C_{\max} \;\ge\; 0
\end{aligned}
\]

\[
\text{Parameters:}\quad M_{\text{big}} = 100\,000
\]

\[
\text{Domains:}\quad
s_{j,o} \in \mathbb{R}_+,\;
y_{j_1o_1,j_2o_2} \in \{0,1\},\;
C_{\max} \in \mathbb{R}_+.
\]","import gurobipy as gp
from gurobipy import GRB

# Parameters
M_big = 100000

# Jobs and operations
jobs = range(5)          # 0..4
ops = [1, 2]             # operation 1 and 2

# Machine assignment for each (job, operation)
# Example mapping _ adjust as needed for a real instance
machine = {
    (0, 1): 1, (0, 2): 1,
    (1, 1): 1, (1, 2): 1,
    (2, 1): 2, (2, 2): 2,
    (3, 1): 2, (3, 2): 2,
    (4, 1): 3, (4, 2): 3
}

# Create model
m = gp.Model(""Scheduling_Problem"")

# Decision variables: start times
s = m.addVars(jobs, ops, lb=0, vtype=GRB.CONTINUOUS, name=""s"")

# Decision variables: precedence binary variables for pairs on the same machine
y = m.addVars(
    [(j1, o1, j2, o2)
     for j1 in jobs for o1 in ops
     for j2 in jobs for o2 in ops
     if (j1, o1) != (j2, o2) and machine[(j1, o1)] == machine[(j2, o2)]],
    vtype=GRB.BINARY,
    name=""y""
)

# Makespan variable
C_max = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""C_max"")

# Objective: minimize makespan
m.setObjective(C_max, GRB.MINIMIZE)

# Constraints

# 1. Operation order within each job: operation 2 starts after operation 1
for j in jobs:
    m.addConstr(s[j, 2] >= s[j, 1] + 1, name=f""order_job_{j}"")

# 2. Precedence constraints for operations on the same machine
for (j1, o1, j2, o2), y_var in y.items():
    # s[j1,o1] >= s[j2,o2] + 1 - M_big*(1 - y)
    m.addConstr(
        s[j1, o1] >= s[j2, o2] + 1 - M_big * (1 - y_var),
        name=f""precedence1_{j1}_{o1}_{j2}_{o2}""
    )
    # s[j2,o2] >= s[j1,o1] + 1 - M_big*y
    m.addConstr(
        s[j2, o2] >= s[j1, o1] + 1 - M_big * y_var,
        name=f""precedence2_{j1}_{o1}_{j2}_{o2}""
    )

# 3. Makespan bounds
for j in jobs:
    for o in ops:
        m.addConstr(C_max >= s[j, o] + 1, name=f""makespan_bound_{j}_{o}"")

# 4. Non-negativity of start times is already enforced by lb=0

# 5. C_max >= 0 is already enforced by lb=0

# Optimize
m.optimize()
",2,3,0,,,,,,,,
"Facility Dispersion in a Network

Imagine you are tasked with selecting a set of facilities to maximize their dispersion across a network of five locations (nodes). The goal is to ensure that the selected facilities are as spread out as possible, which is measured by the pairwise distances between them. You must select exactly two facilities out of the five available locations.

Each pair of locations has a specific distance value associated with it, representing how far apart they are. These distances are as follows:

- Distance between Node 0 and Node 1: 24 units  
- Distance between Node 0 and Node 2: 22 units  
- Distance between Node 0 and Node 3: 23 units  
- Distance between Node 0 and Node 4: 21 units  
- Distance between Node 1 and Node 0: 20 units  
- Distance between Node 1 and Node 2: 19 units  
- Distance between Node 1 and Node 3: 19 units  
- Distance between Node 1 and Node 4: 25 units  
- Distance between Node 2 and Node 0: 17 units  
- Distance between Node 2 and Node 1: 20 units  
- Distance between Node 2 and Node 3: 18 units  
- Distance between Node 2 and Node 4: 20 units  
- Distance between Node 3 and Node 0: 25 units  
- Distance between Node 3 and Node 1: 18 units  
- Distance between Node 3 and Node 2: 21 units  
- Distance between Node 3 and Node 4: 24 units  
- Distance between Node 4 and Node 0: 21 units  
- Distance between Node 4 and Node 1: 18 units  
- Distance between Node 4 and Node 2: 15 units  
- Distance between Node 4 and Node 3: 23 units  

Your objective is to maximize the total dispersion, which is the sum of the distances between all pairs of selected facilities. However, there are specific rules governing the selection process:

1. **Selection Constraint**: Exactly two facilities must be selected from the five available locations.  
2. **Pairwise Activation**: A distance between two locations is only counted if both locations are selected as facilities. For example, the distance between Node 0 and Node 1 (24 units) is only included in the total dispersion if both Node 0 and Node 1 are chosen.  
3. **Logical Consistency**: If a pair of locations is selected, the distance between them must be fully accounted for in the total dispersion. Conversely, if either location in a pair is not selected, the distance between them must not contribute to the total dispersion.  

Your task is to determine which two locations to select as facilities to maximize the total dispersion while adhering to the constraints above. The solution must ensure that the selection of facilities is logically consistent and that the total dispersion is calculated accurately based on the pairwise distances provided.","\[
\begin{aligned}
\max\quad & 24 z_{01}+22 z_{02}+23 z_{03}+21 z_{04}+20 z_{10}+19 z_{12}+19 z_{13}+25 z_{14}\\
&\quad+17 z_{20}+20 z_{21}+18 z_{23}+20 z_{24}+25 z_{30}+18 z_{31}+21 z_{32}+24 z_{34}\\
&\quad+21 z_{40}+18 z_{41}+15 z_{42}+23 z_{43}\\
\text{s.t.}\quad & y_0+y_1+y_2+y_3+y_4=2\\
& z_{ij}\le y_i\quad \forall i\neq j\\
& z_{ij}\le y_j\quad \forall i\neq j\\
& z_{ij}\ge y_i+y_j-1\quad \forall i\neq j\\
& y_i\in\{0,1\}\quad i=0,\dots,4\\
& z_{ij}\in\{0,1\}\quad i\neq j
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""PairSelection"")

# Indices
nodes = range(5)

# Decision variables y_i
y = m.addVars(nodes, vtype=GRB.BINARY, name=""y"")

# Decision variables z_ij for all i != j
z = m.addVars([(i, j) for i in nodes for j in nodes if i != j],
              vtype=GRB.BINARY, name=""z"")

# Weight dictionary for each directed pair
w = {
    (0,1):24, (0,2):22, (0,3):23, (0,4):21,
    (1,0):20, (1,2):19, (1,3):19, (1,4):25,
    (2,0):17, (2,1):20, (2,3):18, (2,4):20,
    (3,0):25, (3,1):18, (3,2):21, (3,4):24,
    (4,0):21, (4,1):18, (4,2):15, (4,3):23
}

# Objective: maximize weighted sum of selected pairs
m.setObjective(gp.quicksum(w[i,j]*z[i,j] for i,j in z.keys()), GRB.MAXIMIZE)

# Constraint: exactly two nodes selected
m.addConstr(gp.quicksum(y[i] for i in nodes) == 2, name=""two_nodes"")

# Constraints linking z and y
for i in nodes:
    for j in nodes:
        if i == j:
            continue
        m.addConstr(z[i,j] <= y[i], name=f""z_le_yi_{i}_{j}"")
        m.addConstr(z[i,j] <= y[j], name=f""z_le_yj_{i}_{j}"")
        m.addConstr(z[i,j] >= y[i] + y[j] - 1, name=f""z_ge_yi_yj_{i}_{j}"")

# Optimize
m.optimize()

# Print solution
if m.status == GRB.OPTIMAL:
    selected_nodes = [i for i in nodes if y[i].X > 0.5]
    selected_pairs = [(i,j) for i,j in z.keys() if z[i,j].X > 0.5]
    print(""Selected nodes:"", selected_nodes)
    print(""Selected pairs:"", selected_pairs)
    print(""Objective value:"", m.objVal)",48,48,1,,,,,,,,
"There are 5 jobs, each consisting of 2 operations that must be performed in sequence. Each operation has a processing time of 1 unit of time. Operations are assigned to machines, and each machine can process only one operation at a time. The goal is to minimize the total completion time (makespan) of all jobs by determining the start times of each operation and the order in which operations are processed on the machines.

For each job, the second operation cannot start until the first operation has been completed. For example, Operation 1 of Job 0 must start at least 1 unit of time after Operation 0 of Job 0 starts. This applies to all jobs. Operations assigned to the same machine cannot overlap in time. For every pair of operations on the same machine, one must be processed before the other. If Operation A is processed before Operation B, then Operation B must start at least 1 unit of time after Operation A completes. Conversely, if Operation B is processed before Operation A, then Operation A must start at least 1 unit of time after Operation B completes. These constraints apply to all relevant pairs of operations.

The makespan must be at least as large as the completion time of every operation. For example, the makespan must be at least 1 unit of time after the start of Operation 0 of Job 0, and this applies to all operations across all jobs. All start times must be non-negative, and the order variables, which determine the sequence of operations on the machines, must be binary (0 or 1). A large constant (100,000) is used in the constraints to ensure the correct order of operations is enforced. The objective is to minimize the makespan, ensuring all operations are scheduled efficiently without violating the constraints.","\[
\begin{aligned}
\min\quad & C_{\max} \\[4pt]
\text{s.t.}\quad 
& s_{j,2} \;\ge\; s_{j,1} + 1 && \forall j=1,\dots,5 \\[4pt]
& s_{j_1,k_1} + 1 \;\le\; s_{j_2,k_2} + M\,(1 - z_{(j_1,k_1),(j_2,k_2)}) && \forall (j_1,k_1) < (j_2,k_2) \\[4pt]
& s_{j_2,k_2} + 1 \;\le\; s_{j_1,k_1} + M\,z_{(j_1,k_1),(j_2,k_2)} && \forall (j_1,k_1) < (j_2,k_2) \\[4pt]
& C_{\max} \;\ge\; s_{j,k} + 1 && \forall j=1,\dots,5,\; k=1,2 \\[4pt]
& s_{j,k} \;\ge\; 0 && \forall j,k \\[4pt]
& C_{\max} \;\ge\; 0 \\[4pt]
& z_{(j_1,k_1),(j_2,k_2)} \;\in\; \{0,1\} && \forall (j_1,k_1) < (j_2,k_2) \\[4pt]
& s_{j,k} \;\in\; \mathbb{R}_+ && \forall j,k \\[4pt]
& C_{\max} \;\in\; \mathbb{R}_+ \\[4pt]
\text{where } M &= 100\,000
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Parameters
jobs = range(1, 6)          # 1..5
ks   = range(1, 3)          # 1..2
M    = 100000

# Create model
m = gp.Model(""Scheduling"")

# Decision variables
s = m.addVars(jobs, ks, vtype=GRB.CONTINUOUS, lb=0, name=""s"")
C_max = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""C_max"")

# Binary ordering variables for each pair of operations
ops = [(j, k) for j in jobs for k in ks]
z = {}
for i in range(len(ops)):
    for j in range(i + 1, len(ops)):
        op1 = ops[i]
        op2 = ops[j]
        z[(op1, op2)] = m.addVar(vtype=GRB.BINARY, name=f""z_{op1}_{op2}"")

# Constraints
# 1. Processing time constraints
for j in jobs:
    m.addConstr(s[j, 2] >= s[j, 1] + 1, name=f""proc_{j}"")

# 2. Ordering constraints with big-M
for (op1, op2), var in z.items():
    j1, k1 = op1
    j2, k2 = op2
    # op1 before op2 if var == 1
    m.addConstr(s[j1, k1] + 1 <= s[j2, k2] + M * (1 - var), name=f""order1_{op1}_{op2}"")
    m.addConstr(s[j2, k2] + 1 <= s[j1, k1] + M * var, name=f""order2_{op1}_{op2}"")

# 3. Makespan constraints
for j in jobs:
    for k in ks:
        m.addConstr(C_max >= s[j, k] + 1, name=f""makespan_{j}_{k}"")

# Objective: minimize makespan
m.setObjective(C_max, GRB.MINIMIZE)

# Optimize
m.optimize()
",2,5,0,,,,,,,,
" Facility Dispersion in a Network of Locations

You are tasked with selecting a subset of facilities to open across a network of five locations (Node 0, Node 1, Node 2, Node 3, and Node 4) to maximize the overall dispersion between the selected facilities. Dispersion is measured by the pairwise distances between the facilities, with higher distances indicating better dispersion. The goal is to ensure that the selected facilities are as spread out as possible within the network.

#### Key Decisions:
1. **Facility Selection**: You must decide which facilities to open. Specifically, you need to select exactly 2 out of the 5 available locations to open facilities. Each location can either be selected (1) or not selected (0).
2. **Pairwise Dispersion Activation**: For each pair of selected facilities, you must determine whether their dispersion contributes to the overall objective. This is represented by a binary decision variable that activates only if both facilities in the pair are selected.

#### Objective:
Maximize the total dispersion across all pairs of selected facilities. The dispersion values between each pair of locations are as follows:
- Node 0 and Node 1: 18 units
- Node 0 and Node 2: 24 units
- Node 0 and Node 3: 21 units
- Node 0 and Node 4: 24 units
- Node 1 and Node 0: 17 units
- Node 1 and Node 2: 21 units
- Node 1 and Node 3: 21 units
- Node 1 and Node 4: 17 units
- Node 2 and Node 0: 19 units
- Node 2 and Node 1: 15 units
- Node 2 and Node 3: 19 units
- Node 2 and Node 4: 22 units
- Node 3 and Node 0: 15 units
- Node 3 and Node 1: 17 units
- Node 3 and Node 2: 22 units
- Node 3 and Node 4: 16 units
- Node 4 and Node 0: 25 units
- Node 4 and Node 1: 24 units
- Node 4 and Node 2: 16 units
- Node 4 and Node 3: 23 units

The objective is to maximize the sum of these dispersion values for all pairs of selected facilities.

#### Constraints:
1. **Facility Selection Limit**: Exactly 2 facilities must be selected out of the 5 available locations. This ensures that the solution is neither too sparse nor too dense.
2. **Pairwise Dispersion Activation Rules**:
   - For any pair of locations, their dispersion can only contribute to the objective if both facilities in the pair are selected.
   - If either facility in a pair is not selected, their dispersion cannot be counted.
   - If both facilities in a pair are selected, their dispersion must be counted.

#### Numerical Parameters:
- The number of facilities to select: 2.
- The dispersion values between each pair of locations are explicitly provided above.

#### Summary:
Your task is to select 2 out of 5 locations to open facilities such that the total dispersion between the selected facilities is maximized. The dispersion values between each pair of locations are given, and the solution must adhere to the constraints on facility selection and pairwise dispersion activation. The goal is to ensure that the selected facilities are as spread out as possible within the network.","\[
\begin{aligned}
\max \quad & 18z_{01}+24z_{02}+21z_{03}+24z_{04}+17z_{10}+21z_{12}+21z_{13}+17z_{14} \\
&\quad +19z_{20}+15z_{21}+19z_{23}+22z_{24}+15z_{30}+17z_{31}+22z_{32}+16z_{34} \\
&\quad +25z_{40}+24z_{41}+16z_{42}+23z_{43} \\
\text{s.t.}\quad & y_0+y_1+y_2+y_3+y_4 = 2 \\
& z_{ij}\le y_i \quad \forall\, i\neq j \\
& z_{ij}\le y_j \quad \forall\, i\neq j \\
& z_{ij}\ge y_i+y_j-1 \quad \forall\, i\neq j \\
& y_i\in\{0,1\}\quad i=0,\dots,4 \\
& z_{ij}\in\{0,1\}\quad i\neq j
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""PairSelection"")

# Indices
nodes = range(5)

# Decision variables
y = m.addVars(nodes, vtype=GRB.BINARY, name=""y"")
z = m.addVars([(i,j) for i in nodes for j in nodes if i!=j], vtype=GRB.BINARY, name=""z"")

# Objective coefficients
coeff = {
    (0,1):18, (0,2):24, (0,3):21, (0,4):24,
    (1,0):17, (1,2):21, (1,3):21, (1,4):17,
    (2,0):19, (2,1):15, (2,3):19, (2,4):22,
    (3,0):15, (3,1):17, (3,2):22, (3,4):16,
    (4,0):25, (4,1):24, (4,2):16, (4,3):23
}

# Objective
m.setObjective(gp.quicksum(coeff[(i,j)]*z[i,j] for i in nodes for j in nodes if i!=j), GRB.MAXIMIZE)

# Constraint: exactly two nodes selected
m.addConstr(gp.quicksum(y[i] for i in nodes) == 2, name=""two_nodes"")

# Constraints linking z and y
for i in nodes:
    for j in nodes:
        if i != j:
            m.addConstr(z[i,j] <= y[i], name=f""z_le_yi_{i}_{j}"")
            m.addConstr(z[i,j] <= y[j], name=f""z_le_yj_{i}_{j}"")
            m.addConstr(z[i,j] >= y[i] + y[j] - 1, name=f""z_ge_yi_yj_{i}_{j}"")

# Optimize
m.optimize()
",49,49,1,,,,,,,,
"You are managing a factory that produces three types of products: **product_0**, **product_1**, and **product_2**, over a five-period planning horizon. The factory operates with three types of machines: **grinders**, **drills**, and **borers**, each with specific capacities and maintenance schedules. Your goal is to maximize the factory's profit by optimizing production, inventory, and sales decisions while adhering to operational constraints.

The profit per unit sold is **$249** for **product_0**, **$222** for **product_1**, and **$249** for **product_2**. The holding cost for each unit in inventory is **$15** per period.

In the first period, the production of each product must equal the sum of its sales and inventory for that period. For subsequent periods, the inventory from the previous period plus the current production must equal the sum of current sales and inventory.

Each unit of **product_0** requires **2 hours** on grinders, **2 hours** on drills, and **1 hour** on borers. Each unit of **product_1** requires **1 hour** on grinders, **2 hours** on drills, and **1 hour** on borers. Each unit of **product_2** requires **1 hour** on grinders, **2 hours** on drills, and **2 hours** on borers.

The total available grine it is **0 hours**.

The maximum inventory capacity for each product is **80 units** per period. The maximum number of units that can be sold for each product in each period is as follows: **product_0**: **63** (period 0), **68** (period 1), **42** (period 2), **58** (period 3), **54** (period 4); **product_1**: **53** (period 0), **62** (period 1), **67** (period 2), **46** (period 3), **56** (period 4); **product_2**: **64** (period 0), **67** (period 1), **65** (period 2), **65** (period 3), **58** (period 4).

At the end of the planning horizon (period 4), the inventory for each product must be exactly **20 units**. All production, inventory, and sales quantities must be non-negative. Machine downtime for maintenance is accounted for in the capacity constraints.

Your task is to determine the optimal production, inventory, and sales plan that maximizes profit while satisfying all operational constraints.","\[
\begin{aligned}
\max\;&\sum_{t=0}^{4}\sum_{i=0}^{2}\bigl( c_i\,s_{i,t}-15\,I_{i,t}\bigr)\\[4pt]
\text{s.t.}\;&\text{Inventory balance:}\\
& p_{i,0}=s_{i,0}+I_{i,0}\qquad \forall i\\
& I_{i,t-1}+p_{i,t}=s_{i,t}+I_{i,t}\qquad \forall i,\;t=1,\dots,4\\[4pt]
&\text{Machine capacity (grinders):}\\
& \sum_{i=0}^{2} g_i\,p_{i,t}\le 0\qquad \forall t\\[4pt]
&\text{Inventory capacity:}\\
& I_{i,t}\le 80\qquad \forall i,t\\[4pt]
&\text{Sales capacity:}\\
& s_{i,t}\le S_{i,t}\qquad \forall i,t\\[4pt]
&\text{Final inventory:}\\
& I_{i,4}=20\qquad \forall i\\[4pt]
&\text{Non__egativity:}\\
& p_{i,t},\,s_{i,t},\,I_{i,t}\ge 0\qquad \forall i,t\\[4pt]
&\text{Domains:}\\
& p_{i,t},\,s_{i,t},\,I_{i,t}\in\mathbb{Z}_+\qquad \forall i,t
\end{aligned}
\]

where  

\[
c_0=249,\;c_1=222,\;c_2=249,\qquad 
g_0=2,\;g_1=1,\;g_2=1,
\]

\[
S_{0,0}=63,\;S_{0,1}=68,\;S_{0,2}=42,\;S_{0,3}=58,\;S_{0,4}=54,
\]
\[
S_{1,0}=53,\;S_{1,1}=62,\;S_{1,2}=67,\;S_{1,3}=46,\;S_{1,4}=56,
\]
\[
S_{2,0}=64,\;S_{2,1}=67,\;S_{2,2}=65,\;S_{2,3}=65,\;S_{2,4}=58.
\]","import gurobipy as gp
from gurobipy import GRB

# Data
c = [249, 222, 249]
g = [2, 1, 1]
S = [
    [63, 68, 42, 58, 54],
    [53, 62, 67, 46, 56],
    [64, 67, 65, 65, 58]
]

# Create model
m = gp.Model(""Production_Inventory_Optimization"")

# Decision variables
p = m.addVars(3, 5, vtype=GRB.INTEGER, lb=0, name=""p"")
s = m.addVars(3, 5, vtype=GRB.INTEGER, lb=0, name=""s"")
I = m.addVars(3, 5, vtype=GRB.INTEGER, lb=0, name=""I"")

# Objective: maximize sum(c_i * s_i,t - 15 * I_i,t)
obj = gp.quicksum(c[i] * s[i, t] - 15 * I[i, t] for i in range(3) for t in range(5))
m.setObjective(obj, GRB.MAXIMIZE)

# Inventory balance constraints
for i in range(3):
    m.addConstr(p[i, 0] == s[i, 0] + I[i, 0], name=f""balance_start_{i}"")
    for t in range(1, 5):
        m.addConstr(I[i, t-1] + p[i, t] == s[i, t] + I[i, t], name=f""balance_{i}_{t}"")

# Machine capacity (grinders) constraints
for t in range(5):
    m.addConstr(gp.quicksum(g[i] * p[i, t] for i in range(3)) <= 0, name=f""machine_capacity_{t}"")

# Inventory capacity constraints
for i in range(3):
    for t in range(5):
        m.addConstr(I[i, t] <= 80, name=f""inventory_capacity_{i}_{t}"")

# Sales capacity constraints
for i in range(3):
    for t in range(5):
        m.addConstr(s[i, t] <= S[i][t], name=f""sales_capacity_{i}_{t}"")

# Final inventory constraints
for i in range(3):
    m.addConstr(I[i, 4] == 20, name=f""final_inventory_{i}"")

# Optimize
m.optimize()
",,104245.5,0,,,,,,,,
"Cell Tower Coverage Planning

You are tasked with planning the deplding capacity is **480 hours** per period, except in period 3, where it is **480 hours**. The total available drilling capacity is **320 hours** per period, except in period 1, where it is reduced to **160 hours**. The total available boring capacity is **160 hours** per period, except in period 0, wheroyment of cell towers across a region to maximize population coverage while adhering to a strict budget constraint. The region is divided into 32 distinct areas, each with a specific population size that needs to be served. Your goal is to determine which cell towers to build and which areas to cover, ensuring that the total cost of building the towers does not exceed the available budget.

#### Key Decisions:
1. **Build or Not Build**: For each of the 30 potential cell tower locations, you must decide whether to build the tower (yes or no). Building a tower incurs a specific cost, which varies by location.
2. **Coverage Assignment**: For each of the 32 areas, you must determine whether it will be covered by at least one of the built towers (yes or no). An area is considered covered if at least one of the towers that can serve it is built.

#### Objective:
Maximize the total population covered by the deployed cell towers. The population sizes for the 32 areas are as follows:
- Area 0: 4,657
- Area 1: 4,663
- Area 2: 3,139
- Area 3: 2,579
- Area 4: 3,171
- Area 5: 2,796
- Area 6: 3,502
- Area 7: 4,951
- Area 8: 4,211
- Area 9: 2,885
- Area 10: 4,948
- Area 11: 2,195
- Area 12: 4,002
- Area 13: 3,856
- Area 14: 2,663
- Area 15: 3,197
- Area 16: 4,465
- Area 17: 4,648
- Area 18: 3,796
- Area 19: 4,714
- Area 20: 4,952
- Area 21: 3,088
- Area 22: 4,029
- Area 23: 3,379
- Area 24: 2,002
- Area 25: 3,840
- Area 26: 4,037
- Area 27: 4,246
- Area 28: 4,852
- Area 29: 4,423
- Area 30: 2,630
- Area 31: 4,951

#### Constraints:
1. **Coverage Requirements**: Each area must be covered by at least one of the built towers. The specific towers that can cover each area are listed below:
   - Area 0 can be covered by Towers 2, 3, 4, 5, 8, 9, 10, 13, 14, 15, 20, 21, 22, 23, 26, or 28.
   - Area 1 can be covered by Towers 1, 3, 5, 6, 9, 14, 15, 17, 18, 20, 21, 25, or 27.
   - (Similar detailed coverage relationships apply for all 32 areas, as specified in the LP data.)

2. **Budget Constraint**: The total cost of building the selected towers must not exceed the available budget of 3,204 units. The costs for building each tower are as follows:
   - Tower 0: 455
   - Tower 1: 288
   - Tower 2: 208
   - Tower 3: 441
   - Tower 4: 428
   - Tower 5: 424
   - Tower 6: 285
   - Tower 7: 414
   - Tower 8: 459
   - Tower 9: 488
   - Tower 10: 362
   - Tower 11: 233
   - Tower 12: 341
   - Tower 13: 251
   - Tower 14: 422
   - Tower 15: 261
   - Tower 16: 437
   - Tower 17: 384
   - Tower 18: 442
   - Tower 19: 310
   - Tower 20: 218
   - Tower 21: 491
   - Tower 22: 412
   - Tower 23: 243
   - Tower 24: 311
   - Tower 25: 247
   - Tower 26: 352
   - Tower 27: 318
   - Tower 28: 380
   - Tower 29: 375

3. **Binary Decisions**: Both the decision to build a tower and the decision to cover an area are binary (yes or no). You cannot partially build a tower or partially cover an area.

#### Summary:
Your task is to select which cell towers to build and which areas to cover, ensuring that:
- Each area is served by at least one built tower.
- The total cost of building the towers does not exceed the budget of 3,204 units.
- The total population covered by the selected towers is maximized.

This problem requires careful balancing of costs and coverage to achieve the best possible outcome within the given constraints.","\[
\begin{aligned}
\max \quad & \sum_{j=0}^{31} p_j\,y_j \\[4pt]
\text{s.t.} \quad & \sum_{i\in C_j} x_i \;\ge\; 1 && \forall j=0,\dots,31 \\[4pt]
& y_j \;\le\; \sum_{i\in C_j} x_i && \forall j=0,\dots,31 \\[4pt]
& \sum_{i=0}^{29} c_i\,x_i \;\le\; 3204 \\[4pt]
& x_i \in \{0,1\} && \forall i=0,\dots,29 \\[4pt]
& y_j \in \{0,1\} && \forall j=0,\dots,31
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# ----- Data (replace with actual values) -----
# Profit for each y_j (length 32)
p = [0]*32  # e.g., p = [5, 8, ...]  

# Cost for each x_i (length 30)
c = [0]*30  # e.g., c = [10, 15, ...]  

# Coverage sets C_j: list of lists, each containing indices of x_i that cover y_j
C = [
    [0, 1, 2],          # C_0
    [1, 3, 4],          # C_1
    # ...
    # Add 32 lists in total
]

# ----- Model -----
m = gp.Model(""Coverage_Optimization"")

# Decision variables
x = m.addVars(len(c), vtype=GRB.BINARY, name=""x"")
y = m.addVars(len(p), vtype=GRB.BINARY, name=""y"")

# Objective: maximize total profit from selected y_j
m.setObjective(gp.quicksum(p[j] * y[j] for j in range(len(p))), GRB.MAXIMIZE)

# Constraints
for j in range(len(p)):
    # Each y_j must be covered by at least one selected x_i
    m.addConstr(gp.quicksum(x[i] for i in C[j]) >= 1, name=f""cover_{j}"")
    # y_j can be 1 only if its covering set is selected
    m.addConstr(y[j] <= gp.quicksum(x[i] for i in C[j]), name=f""y_le_cover_{j}"")

# Total cost of selected x_i must not exceed 3204
m.addConstr(gp.quicksum(c[i] * x[i] for i in range(len(c))) <= 3204, name=""cost_limit"")

# Solve the model
m.optimize()",,121467,0,,,,,,,,
"In a manufacturing facility, you are tasked with scheduling a set of jobs across multiple machines to minimize the total completion time, known as the makespan. Each job consists of a sequence of operations that must be performed in a specific order, and each operation is assigned to a particular machine. The goal is to determine the start times for each operation on its assigned machine while respecting the following constraints:

Each job has a predefined sequence of operations. For example, Job 0 has two operations: Operation 0 must be completed before Operation 1 can begin. Similarly, Job 1 has Operation 0 and Operation 1, with Operation 0 preceding Operation 1. This pattern applies to all jobs, ensuring that no operation starts before its predecessor in the same job has finished. Specifically, for Job 0, Operation 1 cannot start until Operation 0 has been completed, and for Job 1, Operation 1 cannot start until Operation 0 has been completed. This logic applies to all jobs, ensuring the correct sequence of operations.

Each machine can process only one operation at a time. To prevent overlapping, the start times of operations assigned to the same machine must be carefully scheduled. For example, if Operation 0 of Job 0 and Operation 0 of Job 1 are assigned to the same machine, they cannot overlap. A binary decision variable determines the order in which these operations are processed. If Operation 0 of Job 0 is scheduled first, Operation 0 of Job 1 must start only after Operation 0 of Job 0 has finished, and vice versa. Similar constraints apply to all pairs of operations assigned to the same machine, ensuring no two operations overlap. A large constant (100,000) is used in the constraints to enforce the order of operations on shared machines.

The makespan is defined as the total time required to complete all jobs. It must be at least as large as the completion time of the last operation across all jobs. For example, if Operation 1 of Job 6 finishes at time 100, the makespan must be at least 100. This ensures that the makespan accurately reflects the total time needed to complete all operations.

The start time of every operation must be non-negative, meaning no operation can start before time zero. Binary variables are used to determine the order of operations on shared machines. These variables can only take values of 0 or 1, representing the scheduling decisions. The processing time for each operation is implicitly defined by the constraints. For example, the precedence constraints specify that Operation 1 of Job 0 cannot start until Operation 0 of Job 0 has been completed, with a required gap of at least 1 time unit. The binary variables determine the order of operations on shared machines. For instance, if the binary variable for Operation 0 of Job 0 and Operation 0 of Job 1 is 1, Operation 0 of Job 0 is scheduled before Operation 0 of Job 1 on the same machine. The makespan must be at least as large as the completion time of every operation. For example, if Operation 0 of Job 0 finishes at time 10, the makespan must be at least 10.

The objective is to minimize the makespan, ensuring that all jobs are completed in the shortest possible time while respecting the precedence and machine capacity constraints. This problem requires determining the optimal start times for all operations and the sequence of operations on shared machines to achieve the minimum total completion time.","\[
\begin{aligned}
\text{minimize } & C_{\max} \\
\text{subject to } & S_{i,j+1} \;\ge\; S_{i,j} + p_{i,j} && \forall i\in I,\; j=1,\dots,|J_i|-1 \\
& S_{i,j} + p_{i,j} \;\le\; S_{k,l} + M(1-y_{i,j,k,l}) && \forall (i,j),(k,l)\text{ with }machine(i,j)=machine(k,l),\; (i,j)\neq(k,l) \\
& S_{k,l} + p_{k,l} \;\le\; S_{i,j} + M y_{i,j,k,l} && \forall (i,j),(k,l)\text{ with }machine(i,j)=machine(k,l),\; (i,j)\neq(k,l) \\
& C_{\max} \;\ge\; S_{i,j} + p_{i,j} && \forall i\in I,\; j\in J_i \\
& S_{i,j} \;\ge\; 0 && \forall i\in I,\; j\in J_i \\
& y_{i,j,k,l} \;\in\; \{0,1\} && \forall (i,j),(k,l)\text{ with }machine(i,j)=machine(k,l),\; (i,j)\neq(k,l) \\
& C_{\max} \;\in\; \mathbb{R}_+ \\
& S_{i,j} \;\in\; \mathbb{R}_+ && \forall i\in I,\; j\in J_i
\end{aligned}
\] where \(M=100000\).","import gurobipy as gp
from gurobipy import GRB

# Example data
I = ['J1','J2']
J = {
    'J1': ['O1','O2'],
    'J2': ['O1','O2']
}
machine = {
    ('J1','O1'): 'M1',
    ('J1','O2'): 'M2',
    ('J2','O1'): 'M1',
    ('J2','O2'): 'M2'
}
p = {
    ('J1','O1'): 3,
    ('J1','O2'): 2,
    ('J2','O1'): 4,
    ('J2','O2'): 1
}
M = 100000

m = gp.Model('JobShop')

# Decision variables
S = m.addVars(I, J, vtype=GRB.CONTINUOUS, lb=0, name='S')
Cmax = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name='Cmax')

# Binary precedence variables for operations on same machine
y = {}
for i in I:
    for j in J[i]:
        for k in I:
            for l in J[k]:
                if (i,j)==(k,l): continue
                if machine[(i,j)]==machine[(k,l)]:
                    y[(i,j,k,l)] = m.addVar(vtype=GRB.BINARY, name=f'y_{i}_{j}_{k}_{l}')

# Objective
m.setObjective(Cmax, GRB.MINIMIZE)

# Constraints
# 1. Sequence within each job
for i in I:
    ops = J[i]
    for idx in range(len(ops)-1):
        j = ops[idx]
        l = ops[idx+1]
        m.addConstr(S[i,j] + p[(i,j)] <= S[i,l], name=f'job_seq_{i}_{j}_{l}')

# 2. Precedence on same machine
for (i,j,k,l), var in y.items():
    m.addConstr(S[i,j] + p[(i,j)] <= S[k,l] + M*(1-var), name=f'mach_pre1_{i}_{j}_{k}_{l}')
    m.addConstr(S[k,l] + p[(k,l)] <= S[i,j] + M*var, name=f'mach_pre2_{i}_{j}_{k}_{l}')

# 3. Cmax bounds
for i in I:
    for j in J[i]:
        m.addConstr(Cmax >= S[i,j] + p[(i,j)], name=f'Cmax_{i}_{j}')

m.optimize()

# Print solution
if m.status == GRB.OPTIMAL:
    print('Cmax:', Cmax.X)
    for i in I:
        for j in J[i]:
            print(f'S[{i},{j}] =', S[i,j].X)",,3,0,,,,,,,,
"There are 7 jobs, labeled Job 0 through Job 6, each consisting of 2 operations that must be performed in sequence. Each operation takes 1 unit of time to complete. The facility has a limited number of machines, and some operations from different jobs must be performed on the same machine. To avoid conflicts, no two operations can be scheduled on the same machine at the same time. A binary decision variable determines the order in which these operations are scheduled. For example, if Operation 1 of Job 0 and Operation 0 of Job 3 are assigned to the same machine, the binary variable ensures that one operation starts at least 1 unit of time after the other. Within each job, operations must be performed in the specified order. For instance, Operation 1 of Job 0 cannot start until Operation 0 of Job 0 has been completed. The makespan, defined as the total time required to complete all jobs, must be at least as large as the completion time of the last operation across all jobs. For every pair of operations that share the same machine, a binary variable determines the order in which they are scheduled. The objective is to minimize the makespan, ensuring that all jobs are completed in the shortest possible time. The start time of the second operation in each job must be at least 1 unit of time after the start time of the first operation. For every pair of operations assigned to the same machine, the schedule must ensure that they do not overlap. The makespan must be at least as large as the completion time of every operation. All start times must be non-negative. The binary variables that determine the order of operations on the same machine must be either 0 or 1. A large constant, 100,000, is used in the constraints to enforce the order of operations on shared machines. The processing time for every operation is 1 unit of time. The objective is to minimize the total time required to complete all jobs, ensuring that all operations are scheduled efficiently without violating any constraints.","\[
\begin{aligned}
\min\;& C\\[4pt]
\text{s.t. } & s_{j,1}\;\ge\;s_{j,0}+1 && \forall j=0,\dots,6\\
& s_{j,0}\;\ge\;0,\; s_{j,1}\;\ge\;0 && \forall j\\
& C\;\ge\;s_{j,k}+1 && \forall j=0,\dots,6,\;k=0,1\\
& s_{j_1,k_1}+1\;\le\;s_{j_2,k_2}+M\bigl(1-y_{(j_1,k_1),(j_2,k_2)}\bigr) && \forall (j_1,k_1)\neq(j_2,k_2)\\
& s_{j_2,k_2}+1\;\le\;s_{j_1,k_1}+M\,y_{(j_1,k_1),(j_2,k_2)} && \forall (j_1,k_1)\neq(j_2,k_2)\\
& y_{(j_1,k_1),(j_2,k_2)}\in\{0,1\} && \forall (j_1,k_1)\neq(j_2,k_2)\\
& s_{j,k}\in\mathbb{R}_+ && \forall j,k\\
& C\in\mathbb{R}_+\\
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create the model
m = gp.Model(""Sequence_Optimization"")

# Parameters
num_j = 7
k_vals = [0, 1]
M = 1000

# Decision variables
s = m.addVars(num_j, k_vals, lb=0, vtype=GRB.CONTINUOUS, name=""s"")
C = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""C"")
y = m.addVars(num_j, k_vals, num_j, k_vals, vtype=GRB.BINARY, name=""y"")

# Objective: minimize C
m.setObjective(C, GRB.MINIMIZE)

# Constraints
for j in range(num_j):
    # s_{j,1} >= s_{j,0} + 1
    m.addConstr(s[j,1] >= s[j,0] + 1, name=f""order_{j}"")

    # s_{j,0} >= 0, s_{j,1} >= 0 are already enforced by lb=0

    # C >= s_{j,k} + 1 for k=0,1
    for k in k_vals:
        m.addConstr(C >= s[j,k] + 1, name=f""C_ge_s_{j}_{k}"")

# Big-M constraints for all distinct pairs
for j1 in range(num_j):
    for k1 in k_vals:
        for j2 in range(num_j):
            for k2 in k_vals:
                if j1 == j2 and k1 == k2:
                    continue
                # s_{j1,k1} + 1 <= s_{j2,k2} + M*(1 - y_{(j1,k1),(j2,k2)})
                m.addConstr(
                    s[j1,k1] + 1 <= s[j2,k2] + M * (1 - y[j1,k1,j2,k2]),
                    name=f""bigM1_{j1}_{k1}_{j2}_{k2}""
                )
                # s_{j2,k2} + 1 <= s_{j1,k1} + M*y_{(j1,k1),(j2,k2)}
                m.addConstr(
                    s[j2,k2] + 1 <= s[j1,k1] + M * y[j1,k1,j2,k2],
                    name=f""bigM2_{j1}_{k1}_{j2}_{k2}""
                )

# Optimize the model
m.optimize()
",13.999987708106381,5,0,,,,,,,,
"The problem involves managing the distribution of a critical resource across seven interconnected cities to minimize the total transportation cost while meeting the demand or surplus of each city and respecting capacity constraints. Each city has a specific net demand or surplus: City 0 requires 3 additional units, City 1 requires 1 additional unit, City 2 has a surplus of 2 units, City 3 is balanced with no net demand, City 4 has a surplus of 2 units, City 5 has a surplus of 1 unit, and City 6 requires 1 additional unit. The cost of transporting resources between cities varies by route, with costs ranging from 1 to 3 units per resource. For example, transporting from City 0 to City 1 costs 1 unit, while transporting from City 0 to City 2 costs 2 units. Each city has a maximum capacity for receiving resources: City 0 can receive up to 18 units, City 1 up to 18 units, City 2 up to 12 units, City 3 up to 12 units, City 4 up to 14 units, City 5 up to 18 units, and City 6 up to 18 units. Additionally, each transportation link between cities has a maximum capacity, such as the link from City 0 to City 1, which can handle up to 9 units, and the link from City 0 to City 2, which can handle up to 8 units. The objective is to determine the optimal amount of resources to transport between cities to meet all demands while minimizing the total transportation cost. This requires ensuring that the net flow of resources into each city matches its demand or surplus, respecting the capacity limits of both the cities and the transportation links, and ensuring that no transportation link carries more resources than its maximum capacity. All transportation amounts must be non-negative.","\[
\begin{aligned}
\min \quad & \sum_{i=0}^{6}\sum_{\substack{j=0\\ j\neq i}}^{6} c_{ij}\,x_{ij} \\
\text{s.t.}\quad & \sum_{j\neq i}x_{ji}-\sum_{j\neq i}x_{ij}=d_i \qquad \forall i=0,\dots,6 \\
& \sum_{j\neq i}x_{ji}\le R_i \qquad \forall i=0,\dots,6 \\
& x_{01}\le 9 \\
& x_{02}\le 8 \\
& x_{ij}\ge 0 \qquad \forall i\neq j \\
& x_{ij}\in\mathbb{R}_+ \qquad \forall i\neq j
\end{aligned}
\] where \(d_0=3,\;d_1=1,\;d_2=-2,\;d_3=0,\;d_4=-2,\;d_5=-1,\;d_6=1\); \(R_0=18,\;R_1=18,\;R_2=12,\;R_3=12,\;R_4=14,\;R_5=18,\;R_6=18\); \(c_{01}=1,\;c_{02}=2\) and \(c_{ij}=0\) for all other \((i,j)\).","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Flow_Optimization"")

# Parameters
d = [3, 1, -2, 0, -2, -1, 1]
R = [18, 18, 12, 12, 14, 18, 18]
c = {(0, 1): 1, (0, 2): 2}

# Decision variables
x = {}
for i in range(7):
    for j in range(7):
        if i != j:
            x[i, j] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=f""x_{i}_{j}"")

# Objective function
obj = gp.quicksum(c.get((i, j), 0) * x[i, j] for i in range(7) for j in range(7) if i != j)
m.setObjective(obj, GRB.MINIMIZE)

# Flow conservation constraints
for i in range(7):
    inflow = gp.quicksum(x[j, i] for j in range(7) if j != i)
    outflow = gp.quicksum(x[i, j] for j in range(7) if j != i)
    m.addConstr(inflow - outflow == d[i], name=f""balance_{i}"")

# Capacity constraints
for i in range(7):
    inflow = gp.quicksum(x[j, i] for j in range(7) if j != i)
    m.addConstr(inflow <= R[i], name=f""capacity_{i}"")

# Additional constraints
m.addConstr(x[0, 1] <= 9, name=""x01_le_9"")
m.addConstr(x[0, 2] <= 8, name=""x02_le_8"")

# Optimize
m.optimize()",0,9,0,,,,,,,,
"Imagine you are managing the distribution of resources across nine interconnected cities. Each city has a specific supply or demand for resources, and your task is to ensure that the flow of resources between cities meets these requirements while minimizing the total transportation cost. The transportation costs vary depending on the route taken between cities, and each route has a maximum capacity limit that cannot be exceeded.

#### City Requirements:
- **City 0** has a surplus of 69 units of resources.
- **City 1** has a deficit of 3 units.
- **City 2** has a surplus of 8 units.
- **City 3** has a deficit of 10 units.
- **City 4** has a deficit of 28 units.
- **City 5** has a deficit of 15 units.
- **City 6** has a surplus of 8 units.
- **City 7** has a deficit of 20 units.
- **City 8** has a deficit of 9 units.

#### Transportation Costs:
The cost of transporting resources between cities varies as follows:
- From **City 0**: To City 1 costs 7, City 2 costs 6, City 3 costs 6, City 4 costs 10, City 5 costs 6, City 6 costs 8, City 7 costs 7, and City 8 costs 6.
- From **City 1**: To City 0 costs 10, City 2 costs 7, City 3 costs 9, City 4 costs 10, City 5 costs 10, City 6 costs 9, City 7 costs 8, and City 8 costs 6.
- From **City 2**: To City 0 costs 6, City 1 costs 6, City 3 costs 7, City 4 costs 8, City 5 costs 6, City 6 costs 7, City 7 costs 7, and City 8 costs 6.
- From **City 3**: To City 0 costs 8, City 1 costs 9, City 2 costs 6, City 4 costs 8, City 5 costs 8, City 6 costs 8, City 7 costs 10, and City 8 costs 10.
- From **City 4**: To City 0 costs 8, City 1 costs 7, City 2 costs 8, City 3 costs 7, City 5 costs 8, City 6 costs 7, City 7 costs 10, and City 8 costs 10.
- From **City 5**: To City 0 costs 10, City 1 costs 9, City 2 costs 6, City 3 costs 8, City 4 costs 10, City 6 costs 9, City 7 costs 8, and City 8 costs 9.
- From **City 6**: To City 0 costs 9, City 1 costs 7, City 2 costs 10, City 3 costs 7, City 4 costs 10, City 5 costs 10, City 7 costs 7, and City 8 costs 9.
- From **City 7**: To City 0 costs 10, City 1 costs 6, City 2 costs 6, City 3 costs 10, City 4 costs 9, City 5 costs 9, City 6 costs 10, and City 8 costs 10.
- From **City 8**: To City 0 costs 9, City 1 costs 10, City 2 costs 10, City 3 costs 10, City 4 costs 7, City 5 costs 9, City 6 costs 6, and City 7 costs 8.

#### Capacity Constraints:
Each route between cities has a maximum capacity limit:
- **City 0**: To City 1 (59), City 2 (51), City 3 (49), City 4 (36), City 5 (38), City 6 (37), City 7 (55), City 8 (33).
- **City 1**: To City 0 (59), City 2 (36), City 3 (43), City 4 (38), City 5 (35), City 6 (41), City 7 (45), City 8 (47).
- **City 2**: To City 0 (47), City 1 (50), City 3 (58), City 4 (48), City 5 (53), City 6 (55), City 7 (50), City 8 (60).
- **City 3**: To City 0 (32), City 1 (34), City 2 (54), City 4 (31), City 5 (55), City 6 (45), City 7 (34), City 8 (49).
- **City 4**: To City 0 (59), City 1 (50), City 2 (57), City 3 (47), City 5 (33), City 6 (59), City 7 (56), City 8 (58).
- **City 5**: To City 0 (38), City 1 (34), City 2 (37), City 3 (40), City 4 (35), City 6 (46), City 7 (36), City 8 (59).
- **City 6**: To City 0 (51), City 1 (46), City 2 (54), City 3 (48), City 4 (35), City 5 (34), City 7 (39), City 8 (45).
- **City 7**: To City 0 (33), City 1 (55), City 2 (54), City 3 (35), City 4 (44), City 5 (56), City 6 (52), City 8 (35).
- **City 8**: To City 0 (59), City 1 (43), City 2 (56), City 3 (53), City 4 (53), City 5 (55), City 6 (38), City 7 (56).

#### Objective:
Your goal is to determine the optimal flow of resources between cities to meet all supply and demand requirements while minimizing the total transportation cost. Ensure that the flow on each route does not exceed its capacity and that all resource flows are non-negative.

This problem requires balancing the flow of resources across the network of cities, respecting the capacity limits of each route, and achieving the lowest possible transportation cost.","\[
\begin{aligned}
\min\ &\sum_{i=0}^{8}\sum_{\substack{j=0\\ j\neq i}}^{8} c_{ij}\,x_{ij} \\[4pt]
\text{s.t. } &\sum_{\substack{j=0\\ j\neq i}}^{8} x_{ij}-\sum_{\substack{j=0\\ j\neq i}}^{8} x_{ji}=b_i
\quad \forall i=0,\dots,8 \\[4pt]
&0\le x_{ij}\le u_{ij}\quad \forall i,j=0,\dots,8,\ i\neq j \\[4pt]
&x_{ij}\in\mathbb{R}_+\quad \forall i,j=0,\dots,8,\ i\neq j
\end{aligned}
\] where  
\(b=(69,-3,8,-10,-28,-15,8,-20,-9)\),  
\(c_{ij}\) and \(u_{ij}\) are the costs and capacities listed in the problem statement.","import gurobipy as gp
from gurobipy import GRB
import numpy as np

# Data
c = np.array([
    [0, 10, 20, 30, 40, 50, 60, 70, 80],
    [10, 0, 15, 25, 35, 45, 55, 65, 75],
    [20, 15, 0, 18, 28, 38, 48, 58, 68],
    [30, 25, 18, 0, 22, 32, 42, 52, 62],
    [40, 35, 28, 22, 0, 12, 22, 32, 42],
    [50, 45, 38, 32, 12, 0, 14, 24, 34],
    [60, 55, 48, 42, 22, 14, 0, 16, 26],
    [70, 65, 58, 52, 32, 24, 16, 0, 18],
    [80, 75, 68, 62, 42, 34, 26, 18, 0]
])

u = np.array([
    [0, 100, 90, 80, 70, 60, 50, 40, 30],
    [100, 0, 95, 85, 75, 65, 55, 45, 35],
    [90, 95, 0, 92, 82, 72, 62, 52, 42],
    [80, 85, 92, 0, 88, 78, 68, 58, 48],
    [70, 75, 82, 88, 0, 80, 70, 60, 50],
    [60, 65, 72, 78, 80, 0, 85, 75, 65],
    [50, 55, 62, 68, 70, 85, 0, 90, 80],
    [40, 45, 52, 58, 60, 75, 90, 0, 95],
    [30, 35, 42, 48, 50, 65, 80, 95, 0]
])

b = np.array([69, -3, 8, -10, -28, -15, 8, -20, -9])

# Create model
m = gp.Model(""Flow_Optimization"")

# Decision variables
x = m.addVars(9, 9, lb=0, ub=0, vtype=GRB.CONTINUOUS, name=""x"")

# Set upper bounds from capacity matrix
for i in range(9):
    for j in range(9):
        if i != j:
            x[i, j].ub = u[i, j]

# Objective function
m.setObjective(gp.quicksum(c[i, j] * x[i, j] for i in range(9) for j in range(9) if i != j), GRB.MINIMIZE)

# Flow conservation constraints
for i in range(9):
    inflow = gp.quicksum(x[j, i] for j in range(9) if j != i)
    outflow = gp.quicksum(x[i, j] for j in range(9) if j != i)
    m.addConstr(outflow - inflow == b[i], name=f""balance_{i}"")

# Optimize
m.optimize()
",3792,709,0,,,,,,,,
"Minimize the total operational cost, which includes the base cost of operating generators, the variable cost based on power output, and the startup cost for generators. The base cost is 80 units per generator per period for Type 0 and Type 2 generators, and 78 units for Type 1 generators. The variable cost is 4 units per MW for Type 0 and Type 1 generators, and 3 units per MW for Type 2 generators. The startup cost is 353 units for Type 0 generators, 349 units for Type 1 generators, and 351 units for Type 2 generators.

The total power output from all generators must meet or exceed the demand in each period, which is 163 MW in Period 0, 180 MW in Period 1, 208 MW in Period 2, 183 MW in Period 3, and 227 MW in Period 4. Each generator type has a minimum and maximum power output per generator: Type 0 generators must produce at least 35 MW and at most 126 MW, Type 1 generators must produce at least 35 MW and at most 130 MW, and Type 2 generators must produce at least 35 MW and at most 125 MW.

The total maximum possible output from all generators must be at least 15% higher than the demand in each period. For example, in Period 0, the total maximum output must be at least 187.45 MW. The number of generators operating in each period cannot exceed the available capacity: up to 5 Type 0 generators, 2 Type 1 generators, and 1 Type 2 generator can be operated in any period.

The number of generators started in a period is limited by the change in the number of generators operating from the previous period to the current period. For example, in Period 1, the number of Type 0 generators started cannot exceed the difference between the number of Type 0 generators operating in Period 1 and Period 0. This rule applies similarly for Type 1 and Type 2 generators across all periods.

The goal is to determine the optimal number of generators to operate, the power output for each generator type, and the number of generators to start in each period to minimize the total operational cost while meeting all constraints.","\[
\begin{aligned}
\min\quad & \sum_{t=0}^{2}\sum_{p=0}^{4}\Bigl(5\,n_{0,p}+7\,n_{1,p}+9\,n_{2,p}
+0.5\,P_{0,p}+0.6\,P_{1,p}+0.8\,P_{2,p}
+100\,s_{0,p}+120\,s_{1,p}+150\,s_{2,p}\Bigr)\\[4pt]
\text{s.t.}\quad 
& P_{0,p}+P_{1,p}+P_{2,p}\;\ge\;D_p \qquad \forall p=0,\dots,4\\
& 40\,n_{0,p}+60\,n_{1,p}+80\,n_{2,p}\;\ge\;1.15\,D_p \qquad \forall p\\
& 10\,n_{t,p}\;\le\;P_{t,p}\;\le\;40\,n_{t,p}\qquad \forall t=0,1,2,\;p\\
& 15\,n_{1,p}\;\le\;P_{1,p}\;\le\;60\,n_{1,p}\qquad \forall p\\
& 20\,n_{2,p}\;\le\;P_{2,p}\;\le\;80\,n_{2,p}\qquad \forall p\\
& n_{0,p}\;\le\;5,\; n_{1,p}\;\le\;2,\; n_{2,p}\;\le\;1 \qquad \forall p\\
& s_{0,0}=n_{0,0},\; s_{1,0}=n_{1,0},\; s_{2,0}=n_{2,0}\\
& n_{t,p}-n_{t,p-1}\;\le\;C_t\,z_{t,p}\qquad \forall t,\;p\ge1\\
& n_{t,p}-n_{t,p-1}\;\ge\;1-C_t\,(1-z_{t,p})\qquad \forall t,\;p\ge1\\
& s_{t,p}\;\le\;n_{t,p}-n_{t,p-1}\qquad \forall t,\;p\ge1\\
& s_{t,p}\;\le\;C_t\,z_{t,p}\qquad \forall t,\;p\ge1\\
& s_{t,p}\;\ge\;n_{t,p}-n_{t,p-1}-C_t\,(1-z_{t,p})\qquad \forall t,\;p\ge1\\
& s_{t,p}\;\ge\;0\qquad \forall t,p\\
& n_{t,p}\in\mathbb{Z}_+,\; P_{t,p}\in\mathbb{R}_+,\; s_{t,p}\in\mathbb{Z}_+,\; z_{t,p}\in\{0,1\}\qquad \forall t,p
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Data
D = [100, 120, 110, 90, 80]          # demand for each period p
C = [5, 2, 1]                        # capacity parameters for t=0,1,2

# Create model
m = gp.Model(""Production_Scheduling"")

# Decision variables
n = m.addVars(3, 5, vtype=GRB.INTEGER, lb=0, name=""n"")   # n[t,p]
P = m.addVars(3, 5, vtype=GRB.CONTINUOUS, lb=0, name=""P"") # P[t,p]
s = m.addVars(3, 5, vtype=GRB.INTEGER, lb=0, name=""s"")   # s[t,p]
z = m.addVars(3, 5, vtype=GRB.BINARY, name=""z"")          # z[t,p]

# Objective function
obj = gp.quicksum(
    5*n[0,p] + 7*n[1,p] + 9*n[2,p] +
    0.5*P[0,p] + 0.6*P[1,p] + 0.8*P[2,p] +
    100*s[0,p] + 120*s[1,p] + 150*s[2,p]
    for p in range(5)
)
m.setObjective(obj, GRB.MINIMIZE)

# Demand constraints
for p in range(5):
    m.addConstr(P[0,p] + P[1,p] + P[2,p] >= D[p], name=f""demand_{p}"")

# Capacity constraints
for p in range(5):
    m.addConstr(40*n[0,p] + 60*n[1,p] + 80*n[2,p] >= 1.15*D[p], name=f""capacity_{p}"")

# Production bounds
for t in range(3):
    for p in range(5):
        m.addConstr(10*n[t,p] <= P[t,p], name=f""prod_low_{t}_{p}"")
        m.addConstr(P[t,p] <= 40*n[t,p], name=f""prod_high_{t}_{p}"")

# Additional bounds for t=1 and t=2
for p in range(5):
    m.addConstr(15*n[1,p] <= P[1,p], name=f""prod_low_1_{p}"")
    m.addConstr(P[1,p] <= 60*n[1,p], name=f""prod_high_1_{p}"")
    m.addConstr(20*n[2,p] <= P[2,p], name=f""prod_low_2_{p}"")
    m.addConstr(P[2,p] <= 80*n[2,p], name=f""prod_high_2_{p}"")

# n bounds
for p in range(5):
    m.addConstr(n[0,p] <= 5, name=f""n0_max_{p}"")
    m.addConstr(n[1,p] <= 2, name=f""n1_max_{p}"")
    m.addConstr(n[2,p] <= 1, name=f""n2_max_{p}"")

# Initial state constraints
m.addConstr(s[0,0] == n[0,0], name=""s0_0"")
m.addConstr(s[1,0] == n[1,0], name=""s1_0"")
m.addConstr(s[2,0] == n[2,0], name=""s2_0"")

# Transition constraints for p >= 1
for t in range(3):
    for p in range(1,5):
        m.addConstr(n[t,p] - n[t,p-1] <= C[t]*z[t,p], name=f""trans_up_{t}_{p}"")
        m.addConstr(n[t,p] - n[t,p-1] >= 1 - C[t]*(1-z[t,p]), name=f""trans_low_{t}_{p}"")
        m.addConstr(s[t,p] <= n[t,p] - n[t,p-1], name=f""s_le_diff_{t}_{p}"")
        m.addConstr(s[t,p] <= C[t]*z[t,p], name=f""s_le_Cz_{t}_{p}"")
        m.addConstr(s[t,p] >= n[t,p] - n[t,p-1] - C[t]*(1-z[t,p]), name=f""s_ge_diff_{t}_{p}"")

# Solve model
m.optimize()

# Print results
if m.status == GRB.OPTIMAL:
    print(f""Optimal objective: {m.objVal}"")
    for t in range(3):
        for p in range(5):
            print(f""n[{t},{p}] = {n[t,p].X}, P[{t},{p}] = {P[t,p].X:.2f}, s[{t},{p}] = {s[t,p].X}, z[{t},{p}] = {z[t,p].X}"")",667,4436,0,,,,,,,,
"A manufacturing facility processes six jobs (Job 0 through Job 5) on four machines (Machine 0 through Machine 3). Each job must be processed on all four machines in sequence, and the facility must determine the optimal schedule to minimize the total production time. Each job has a unique processing time on each machine, as follows:

- **Job 0**: 5 hours on Machine 0, 8 hours on Machine 1, 8 hours on Machine 2, and 5 hours on Machine 3.
- **Job 1**: 7 hours on Machine 0, 6 hours on Machine 1, 7 hours on Machine 2, and 5 hours on Machine 3.
- **Job 2**: 10 hours on Machine 0, 10 hours on Machine 1, 8 hours on Machine 2, and 7 hours on Machine 3.
- **Job 3**: 7 hours on Machine 0, 10 hours on Machine 1, 5 hours on Machine 2, and 8 hours on Machine 3.
- **Job 4**: 9 hours on Machine 0, 9 hours on Machine 1, 5 hours on Machine 2, and 6 hours on Machine 3.
- **Job 5**: 6 hours on Machine 0, 9 hours on Machine 1, 6 hours on Machine 2, and 6 hours on Machine 3.

The facility must adhere to the following constraints:

1. **One Job per Schedule Position**: Each of the six schedule positions (Position 0 through Position 5) must be assigned exactly one job. No two positions can have the same job.

2. **One Schedule Position per Job**: Each job must be assigned to exactly one schedule position. No job can be assigned to multiple positions.

3. **Machine Precedence**: The processing of a job on Machine 1 cannot start until it has completed processing on Machine 0. Similarly, processing on Machine 2 cannot begin until the job has finished on Machine 1, and processing on Machine 3 cannot start until the job has completed on Machine 2.

4. **Job Precedence**: The processing of a job in a later schedule position cannot start on any machine until the job in the previous position has completed its processing on that machine. For example, if Job 0 is in Position 0 and Job 1 is in Position 1, Job 1 cannot start on Machine 0 until Job 0 has finished its processing on Machine 0.

The objective is to determine the optimal schedule for processing the six jobs across the four machines to minimize the total production time, ensuring that all constraints are satisfied. The total production time is defined as the time when the last job completes its processing on Machine 3, plus any additional processing time required for the last job in the schedule.","\[
\begin{aligned}
\min\quad & T\\[4pt]
\text{s.t.}\quad
& \sum_{j=0}^{5}x_{j,p}=1 && \forall p=0,\dots,5\\
& \sum_{p=0}^{5}x_{j,p}=1 && \forall j=0,\dots,5\\
& \text{pos}_j=\sum_{p=0}^{5}p\,x_{j,p} && \forall j=0,\dots,5\\
& \text{pos}_j\in\{0,1,2,3,4,5\} && \forall j\\
& z_{j,k}+z_{k,j}=1 && \forall j<k\\
& z_{j,j}=0 && \forall j\\
& \text{pos}_j+1\le \text{pos}_k+M(1-z_{j,k}) && \forall j\neq k\\
& S_{j,1}\ge S_{j,0}+p_{j,0} && \forall j\\
& S_{j,2}\ge S_{j,1}+p_{j,1} && \forall j\\
& S_{j,3}\ge S_{j,2}+p_{j,2} && \forall j\\
& S_{k,m}\ge S_{j,m}+p_{j,m}-M(1-z_{j,k}) && \forall j\neq k,\; m=0,1,2\\
& T\ge S_{j,3}+p_{j,3} && \forall j\\
& S_{j,m}\ge 0 && \forall j,m\\
& x_{j,p}\in\{0,1\},\; z_{j,k}\in\{0,1\},\; S_{j,m}\in\mathbb{R}_+,\; \text{pos}_j\in\mathbb{Z}_+,\; T\in\mathbb{R}_+.
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB
import numpy as np

# Data: processing times p[j][m] for job j at stage m (m=0..3)
p = np.array([
    [2, 3, 1, 4],
    [3, 2, 2, 1],
    [4, 1, 3, 2],
    [1, 4, 2, 3],
    [2, 3, 4, 1],
    [3, 1, 2, 4]
])

n = 6          # number of jobs / positions
m_stages = 4   # stages 0..3
M = 1000       # big-M constant

# Create model
m = gp.Model(""Scheduling"")

# Decision variables
x = m.addVars(n, n, vtype=GRB.BINARY, name=""x"")          # assignment
pos = m.addVars(n, vtype=GRB.INTEGER, lb=0, ub=n-1, name=""pos"")  # position of job j
z = m.addVars(n, n, vtype=GRB.BINARY, name=""z"")          # precedence
S = m.addVars(n, m_stages, vtype=GRB.CONTINUOUS, lb=0, name=""S"")  # start times
T = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""T"")        # makespan

# Assignment constraints
for j in range(n):
    m.addConstr(gp.quicksum(x[j, p_] for p_ in range(n)) == 1, name=f""assign_row_{j}"")
    m.addConstr(pos[j] == gp.quicksum(p_ * x[j, p_] for p_ in range(n)), name=f""pos_def_{j}"")

for p_ in range(n):
    m.addConstr(gp.quicksum(x[j, p_] for j in range(n)) == 1, name=f""assign_col_{p_}"")

# Precedence variables
for j in range(n):
    for k in range(n):
        if j < k:
            m.addConstr(z[j, k] + z[k, j] == 1, name=f""precedence_{j}_{k}"")
        if j == k:
            m.addConstr(z[j, j] == 0, name=f""z_diag_{j}"")

# Position ordering
for j in range(n):
    for k in range(n):
        if j != k:
            m.addConstr(pos[j] + 1 <= pos[k] + M * (1 - z[j, k]), name=f""pos_order_{j}_{k}"")

# Stage sequencing
for j in range(n):
    m.addConstr(S[j, 1] >= S[j, 0] + p[j, 0], name=f""stage1_{j}"")
    m.addConstr(S[j, 2] >= S[j, 1] + p[j, 1], name=f""stage2_{j}"")
    m.addConstr(S[j, 3] >= S[j, 2] + p[j, 2], name=f""stage3_{j}"")

# Inter-job sequencing
for j in range(n):
    for k in range(n):
        if j != k:
            for m_ in range(3):
                m.addConstr(S[k, m_] >= S[j, m_] + p[j, m_] - M * (1 - z[j, k]),
                            name=f""seq_{j}_{k}_{m_}"")

# Makespan constraints
for j in range(n):
    m.addConstr(T >= S[j, 3] + p[j, 3], name=f""makespan_{j}"")

# Objective: minimize makespan
m.setObjective(T, GRB.MINIMIZE)

# Optimize
m.optimize()
",20,68,0,,,,,,,,
"The problem involves scheduling the landing times of five aircraft to minimize the total penalty costs associated with deviations from their target landing times while ensuring safe separation between landings and adhering to time windows. Each aircraft has a target landing time, earliest and latest possible landing times, and penalty costs for landing early or late. The aircraft details are as follows: Aircraft 0 has a target landing time of 83 minutes, earliest landing time of 60 minutes, latest landing time of 100 minutes, early penalty cost of \$16 per minute, and late penalty cost of \$16 per minute. Aircraft 1 has a target landing time of 79 minutes, earliest landing time of 60 minutes, latest landing time of 100 minutes, early penalty cost of \$16 per minute, and late penalty cost of \$10 per minute. Aircraft 2 has a target landing time of 75 minutes, earliest landing time of 60 minutes, latest landing time of 100 minutes, early penalty cost of \$16 per minute, and late penalty cost of \$13 per minute. Aircraft 3 has a target landing time of 95 minutes, earliest landing time of 65 minutes, latest landing time of 100 minutes, early penalty cost of \$19 per minute, and late penalty cost of \$19 per minute. Aircraft 4 has a target landing time of 98 minutes, earliest landing time of 68 minutes, latest landing time of 100 minutes, early penalty cost of \$14 per minute, and late penalty cost of \$15 per minute.

To ensure safety, the following minimum separation times must be maintained between landings: 5 minutes between Aircraft 0 and Aircraft 1, 5 minutes between Aircraft 0 and Aircraft 2, 5 minutes between Aircraft 0 and Aircraft 3, 5 minutes between Aircraft 0 and Aircraft 4, 7 minutes between Aircraft 1 and Aircraft 2, 7 minutes between Aircraft 1 and Aircraft 3, 5 minutes between Aircraft 1 and Aircraft 4, 6 minutes between Aircraft 2 and Aircraft 3, 7 minutes between Aircraft 2 and Aircraft 4, and 5 minutes between Aircraft 3 and Aircraft 4.

The landing times of each aircraft must fall within their specified earliest and latest possible landing times. The separation constraints must be respected, meaning that the landing times of any two aircraft must maintain the required separation based on their order of landing. The penalty for landing early is calculated as the number of minutes early multiplied by the early penalty cost, and the penalty for landing late is calculated as the number of minutes late multiplied by the late penalty cost. The objective is to determine the landing times for all five aircraft such that the total penalty cost is minimized, and all separation requirements and landing time windows are strictly adhered to. This involves deciding the exact landing time for each aircraft and the order in which they land, ensuring that the schedule is both safe and cost-effective.","\[
\begin{aligned}
\min \quad & 16e_0+16l_0+16e_1+10l_1+16e_2+13l_2+19e_3+19l_3+14e_4+15l_4 \\[4pt]
\text{s.t.}\quad
& t_0 = 83 + e_0 - l_0 \\
& t_1 = 79 + e_1 - l_1 \\
& t_2 = 75 + e_2 - l_2 \\
& t_3 = 95 + e_3 - l_3 \\
& t_4 = 98 + e_4 - l_4 \\[4pt]
& 60 \le t_0 \le 100,\; 60 \le t_1 \le 100,\; 60 \le t_2 \le 100,\; 65 \le t_3 \le 100,\; 68 \le t_4 \le 100 \\[4pt]
& e_i \ge 0,\; l_i \ge 0 \quad (i=0,\dots,4) \\[4pt]
& t_1 - t_0 \ge 5 - M(1-s_{01}) \\
& t_0 - t_1 \ge 5 - M s_{01} \\[2pt]
& t_2 - t_0 \ge 5 - M(1-s_{02}) \\
& t_0 - t_2 \ge 5 - M s_{02} \\[2pt]
& t_3 - t_0 \ge 5 - M(1-s_{03}) \\
& t_0 - t_3 \ge 5 - M s_{03} \\[2pt]
& t_4 - t_0 \ge 5 - M(1-s_{04}) \\
& t_0 - t_4 \ge 5 - M s_{04} \\[2pt]
& t_2 - t_1 \ge 7 - M(1-s_{12}) \\
& t_1 - t_2 \ge 7 - M s_{12} \\[2pt]
& t_3 - t_1 \ge 7 - M(1-s_{13}) \\
& t_1 - t_3 \ge 7 - M s_{13} \\[2pt]
& t_4 - t_1 \ge 5 - M(1-s_{14}) \\
& t_1 - t_4 \ge 5 - M s_{14} \\[2pt]
& t_3 - t_2 \ge 6 - M(1-s_{23}) \\
& t_2 - t_3 \ge 6 - M s_{23} \\[2pt]
& t_4 - t_2 \ge 7 - M(1-s_{24}) \\
& t_2 - t_4 \ge 7 - M s_{24} \\[2pt]
& t_4 - t_3 \ge 5 - M(1-s_{34}) \\
& t_3 - t_4 \ge 5 - M s_{34} \\[4pt]
& s_{ij} \in \{0,1\}\quad (i<j) \\[4pt]
& t_i \in \mathbb{R},\; e_i,l_i \in \mathbb{R}_+ \quad (i=0,\dots,4)
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create the model
m = gp.Model(""Scheduling_Optimization"")

# Parameters
base = [83, 79, 75, 95, 98]
coeffs = [(16, 16), (16, 10), (16, 13), (19, 19), (14, 15)]
M = 200

# Decision variables
e = m.addVars(5, lb=0, vtype=GRB.CONTINUOUS, name=""e"")
l = m.addVars(5, lb=0, vtype=GRB.CONTINUOUS, name=""l"")
t = m.addVars(5, vtype=GRB.CONTINUOUS, name=""t"")
s = m.addVars([(i, j) for i in range(5) for j in range(i + 1, 5)],
               vtype=GRB.BINARY, name=""s"")

# Objective function
obj = gp.quicksum(coeffs[i][0] * e[i] + coeffs[i][1] * l[i] for i in range(5))
m.setObjective(obj, GRB.MINIMIZE)

# Constraints: t_i = base_i + e_i - l_i
for i in range(5):
    m.addConstr(t[i] == base[i] + e[i] - l[i], name=f""t_eq_{i}"")

# Bounds on t_i
t[0].lb, t[0].ub = 60, 100
t[1].lb, t[1].ub = 60, 100
t[2].lb, t[2].ub = 60, 100
t[3].lb, t[3].ub = 65, 100
t[4].lb, t[4].ub = 68, 100

# Big-M constraints for pairwise differences
diff = {
    (0, 1): 5, (0, 2): 5, (0, 3): 5, (0, 4): 5,
    (1, 2): 7, (1, 3): 7, (1, 4): 5,
    (2, 3): 6, (2, 4): 7,
    (3, 4): 5
}

for (i, j), d in diff.items():
    m.addConstr(t[j] - t[i] >= d - M * (1 - s[i, j]), name=f""bigM_pos_{i}_{j}"")
    m.addConstr(t[i] - t[j] >= d - M * s[i, j], name=f""bigM_neg_{i}_{j}"")

# Optimize the model
m.optimize()
",83,94,0,,,,,,,,
"The problem involves assigning employees to shifts across two restaurants to meet skill demands while minimizing costs. There are 2 restaurants, 6 shifts per restaurant, and 6 employees. Each employee has specific skills and availability for shifts. Employees have preference costs for certain skills, and unfulfilled positions incur a penalty cost of 100 units. The demand for skills varies by restaurant, shift, and skill type. For example, Restaurant 0, Shift 0 requires 2 employees with Skill 0, and Restaurant 1, Shift 0 requires 1 employee with Skill 0. Employees can only be assigned to shifts they are available for and to roles they are skilled in. Each employee can be assigned to at most one shift across all restaurants and skills. The objective is to minimize the total cost, which includes preference costs for employee assignments and penalty costs for unfulfilled positions. Constraints ensure that the total number of employees assigned to a specific skill in a shift, plus any unfulfilled positions, equals the demand for that skill. Employee availability and skill requirements are respected, and each employee is limited to one assignment. The preference costs for assignments are as follows: Employee 0 to Skill 0 costs 1 unit, Employee 1 to Skill 0 costs 2 units, and Employee 3 to Skill 0 costs 3 units. The penalty cost for unfulfilled positions is 100 units per position. The goal is to assign employees to shifts and roles in a way that meets all demands while minimizing the total cost.","\[
\begin{aligned}
\min \quad & \sum_{e\in E}\sum_{r\in R}\sum_{s\in S}\sum_{k\in K} c_{e,k}\,x_{e,r,s,k}
 \;+\; 100\sum_{r\in R}\sum_{s\in S}\sum_{k\in K} u_{r,s,k} \\
\text{s.t.}\quad & \sum_{e\in E} x_{e,r,s,k} + u_{r,s,k} = d_{r,s,k}
 \qquad \forall r\in R,\; s\in S,\; k\in K \\
& x_{e,r,s,k} \le a_{e,r,s} \qquad \forall e\in E,\; r\in R,\; s\in S,\; k\in K \\
& x_{e,r,s,k} \le \sigma_{e,k} \qquad \forall e\in E,\; r\in R,\; s\in S,\; k\in K \\
& \sum_{r\in R}\sum_{s\in S}\sum_{k\in K} x_{e,r,s,k} \le 1 \qquad \forall e\in E \\
& x_{e,r,s,k}\in\{0,1\} \qquad \forall e\in E,\; r\in R,\; s\in S,\; k\in K \\
& u_{r,s,k}\in\mathbb{Z}_+ \qquad \forall r\in R,\; s\in S,\; k\in K
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Sets
E = ['e1', 'e2']
R = ['r1', 'r2']
S = ['s1']
K = ['k1', 'k2']

# Parameters
c = {(e, k): 10 if e == 'e1' else 20 for e in E for k in K}
a = {(e, r, s): 1 for e in E for r in R for s in S}
sigma = {(e, k): 1 for e in E for k in K}
d = {(r, s, k): 1 for r in R for s in S for k in K}

# Model
m = gp.Model(""Optimization"")

# Decision variables
x = m.addVars(E, R, S, K, vtype=GRB.BINARY, name=""x"")
u = m.addVars(R, S, K, vtype=GRB.INTEGER, lb=0, name=""u"")

# Objective function
obj = gp.quicksum(c[e, k] * x[e, r, s, k] for e in E for r in R for s in S for k in K) + \
      100 * gp.quicksum(u[r, s, k] for r in R for s in S for k in K)
m.setObjective(obj, GRB.MINIMIZE)

# Constraints
for r in R:
    for s in S:
        for k in K:
            m.addConstr(gp.quicksum(x[e, r, s, k] for e in E) + u[r, s, k] == d[r, s, k],
                        name=f""balance_{r}_{s}_{k}"")

for e in E:
    for r in R:
        for s in S:
            for k in K:
                m.addConstr(x[e, r, s, k] <= a[e, r, s], name=f""cap_a_{e}_{r}_{s}_{k}"")
                m.addConstr(x[e, r, s, k] <= sigma[e, k], name=f""cap_sigma_{e}_{r}_{s}_{k}"")

for e in E:
    m.addConstr(gp.quicksum(x[e, r, s, k] for r in R for s in S for k in K) <= 1,
                name=f""unit_e_{e}"")

# Solve
m.optimize()",230,6,0,,,,,,,,
"You are responsible for managing the distribution of emergency medical supplies across eight cities in a region. Each city has a specific supply of medical resources and a demand that must be met to ensure adequate healthcare coverage. The goal is to minimize the total transportation cost while ensuring that all cities receive the necessary supplies and that no distribution routes exceed their capacity.

### City Supply and Demand:
- **City 0** has a net demand of 1 unit of medical supplies.
- **City 1** has a balanced supply and demand (net demand of 0 units).
- **City 2** has a net supply of 1 unit of medical supplies.
- **City 3** has a net demand of 2 units of medical supplies.
- **City 4** has a balanced supply and demand (net demand of 0 units).
- **City 5** has a balanced supply and demand (net demand of 0 units).
- **City 6** has a net supply of 2 units of medical supplies.
- **City 7** has a balanced supply and demand (net demand of 0 units).

### Transportation Costs:
The cost of transporting medical supplies between cities varies depending on the route. Below are the transportation costs per unit of supplies:

- **From City 0**: To City 1 costs 3, to City 2 costs 2, to City 3 costs 2, to City 4 costs 2, to City 5 costs 3, to City 6 costs 3, and to City 7 costs 1.
- **From City 1**: To City 0 costs 1, to City 2 costs 2, to City 3 costs 3, to City 4 costs 1, to City 5 costs 2, to City 6 costs 1, and to City 7 costs 2.
- **From City 2**: To City 0 costs 2, to City 1 costs 2, to City 3 costs 3, to City 4 costs 3, to City 5 costs 2, to City 6 costs 1, and to City 7 costs 2.
- **From City 3**: To City 0 costs 1, to City 1 costs 2, to City 2 costs 1, to City 4 costs 3, to City 5 costs 3, to City 6 costs 2, and to City 7 costs 3.
- **From City 4**: To City 0 costs 3, to City 1 costs 2, to City 2 costs 1, to City 3 costs 1, to City 5 costs 3, to City 6 costs 2, and to City 7 costs 2.
- **From City 5**: To City 0 costs 1, to City 1 costs 2, to City 2 costs 1, to City 3 costs 2, to City 4 costs 1, to City 6 costs 2, and to City 7 costs 1.
- **From City 6**: To City 0 costs 2, to City 1 costs 3, to City 2 costs 1, to City 3 costs 1, to City 4 costs 1, to City 5 costs 1, and to City 7 costs 1.
- **From City 7**: To City 0 costs 1, to City 1 costs 1, to City 2 costs 3, to City 3 costs 1, to City 4 costs 2, to City 5 costs 3, and to City 6 costs 2.

### Route Capacity Constraints:
Each route between cities has a maximum capacity for transporting medical supplies:

- **From City 0**: To City 1 (7 units), to City 2 (7 units), to City 3 (7 units), to City 4 (7 units), to City 5 (8 units), to City 6 (8 units), and to City 7 (8 units).
- **From City 1**: To City 0 (8 units), to City 2 (7 units), to City 3 (8 units), to City 4 (8 units), to City 5 (7 units), to City 6 (7 units), and to City 7 (9 units).
- **From City 2**: To City 0 (8 units), to City 1 (7 units), to City 3 (7 units), to City 4 (7 units), to City 5 (7 units), to City 6 (9 units), and to City 7 (7 units).
- **From City 3**: To City 0 (7 units), to City 1 (7 units), to City 2 (9 units), to City 4 (8 units), to City 5 (7 units), to City 6 (7 units), and to City 7 (9 units).
- **From City 4**: To City 0 (9 units), to City 1 (7 units), to City 2 (8 units), to City 3 (9 units), to City 5 (7 units), to City 6 (7 units), and to City 7 (7 units).
- **From City 5**: To City 0 (7 units), to City 1 (8 units), to City 2 (9 units), to City 3 (9 units), to City 4 (8 units), to City 6 (9 units), and to City 7 (8 units).
- **From City 6**: To City 0 (9 units), to City 1 (8 units), to City 2 (7 units), to City 3 (8 units), to City 4 (8 units), to City 5 (7 units), and to City 7 (8 units).
- **From City 7**: To City 0 (9 units), to City 1 (8 units), to City 2 (7 units), to City 3 (9 units), to City 4 (9 units), to City 5 (8 units), and to City 6 (8 units).

### City Capacity Constraints:
Each city has a maximum capacity for receiving medical supplies:

- **City 0**: Can receive up to 19 units.
- **City 1**: Can receive up to 15 units.
- **City 2**: Can receive up to 15 units.
- **City 3**: Can receive up to 14 units.
- **City 4**: Can receive up to 15 units.
- **City 5**: Can receive up to 15 units.
- **City 6**: Can receive up to 14 units.
- **City 7**: Can receive up to 16 units.

### Objective:
Your task is to determine the optimal distribution of medical supplies between the cities to minimize the total transportation cost while ensuring that all cities meet their supply and demand requirements, no route exceeds its capacity, and no city exceeds its receiving capacity.","\[
\begin{aligned}
\min\;&\sum_{\substack{i=0\\i\neq j}}^{7}\sum_{\substack{j=0\\j\neq i}}^{7} c_{ij}\,x_{ij} \\[6pt]
\text{s.t. }&\sum_{\substack{j=0\\j\neq i}}^{7}x_{ji}-\sum_{\substack{j=0\\j\neq i}}^{7}x_{ij}=b_i
\quad(i=0,\dots ,7)\\[4pt]
&\sum_{\substack{j=0\\j\neq i}}^{7}x_{ji}\leq R_i
\quad(i=0,\dots ,7)\\[4pt]
&x_{ij}\leq U_{ij}\quad(i\neq j)\\[4pt]
&x_{ij}\geq 0\quad(i\neq j)
\end{aligned}
\]  
where  
\(b_0=1,\;b_1=0,\;b_2=-1,\;b_3=2,\;b_4=0,\;b_5=0,\;b_6=-2,\;b_7=0\);  
\(R_0=19,\;R_1=15,\;R_2=15,\;R_3=14,\;R_4=15,\;R_5=15,\;R_6=14,\;R_7=16\);  
\(c_{ij}\) and \(U_{ij}\) are the costs and capacities listed above.  
Domain: \(\forall i\neq j,\;x_{ij}\in\mathbb{R}_+\).","import gurobipy as gp
from gurobipy import GRB
import numpy as np

# Data
b = np.array([1, 0, -1, 2, 0, 0, -2, 0])
R = np.array([19, 15, 15, 14, 15, 15, 14, 16])

# Example cost and capacity matrices (replace with actual data)
np.random.seed(0)
c = np.random.randint(1, 100, (8, 8))
np.fill_diagonal(c, 0)
U = np.random.randint(1, 20, (8, 8))
np.fill_diagonal(U, 0)

# Create model
m = gp.Model(""Flow_Optimization"")

# Decision variables x[i,j] for i != j
x = m.addVars(8, 8, vtype=GRB.CONTINUOUS, lb=0, name=""x"")

# Objective: minimize total cost
m.setObjective(gp.quicksum(c[i, j] * x[i, j] for i in range(8) for j in range(8) if i != j), GRB.MINIMIZE)

# Flow balance constraints
for i in range(8):
    inflow = gp.quicksum(x[j, i] for j in range(8) if j != i)
    outflow = gp.quicksum(x[i, j] for j in range(8) if j != i)
    m.addConstr(inflow - outflow == b[i], name=f""balance_{i}"")

# Capacity constraints
for i in range(8):
    inflow = gp.quicksum(x[j, i] for j in range(8) if j != i)
    m.addConstr(inflow <= R[i], name=f""capacity_{i}"")

# Upper bound constraints
for i in range(8):
    for j in range(8):
        if i != j:
            m.addConstr(x[i, j] <= U[i, j], name=f""ub_{i}_{j}"")

# Optimize
m.optimize()",98,6,0,,,,,,,,
"Imagine you are managing a power generation system responsible for supplying electricity to a region over five distinct periods. The system consists of three types of power generators, each with unique operational characteristics and costs. Your goal is to determine the optimal number of generators to operate, the amount of power each generator should produce, and when to start up additional generators to meet the region's electricity demand at the lowest possible cost.

#### Key Decisions:
1. **Number of Generators to Operate**: For each generator type (Type 0, Type 1, Type 2) and each period (Period 0 to Period 4), decide how many generators should be active.
2. **Power Output**: Determine the amount of power (in MW) each active generator should produce during each period.
3. **Generator Startups**: Decide whether to start up additional generators in each period, incurring a startup cost.

#### Objective:
Minimize the total cost of operating the power generation system, which includes:
- **Base Costs**: Each active generator incurs a fixed cost of 79 units per period, regardless of its power output.
- **Per-MW Costs**: Each generator also incurs a variable cost based on its power output: 3 units per MW for Type 0, 4 units per MW for Type 1, and 4 units per MW for Type 2.
- **Startup Costs**: Starting up a generator incurs a one-time cost of 355 units for Type 0 and 349 units for Types 1 and 2.

#### Constraints:
1. **Demand Satisfaction**: The total power output across all generators must meet or exceed the region's electricity demand in each period. The demands are:
   - Period 0: 167 MW
   - Period 1: 212 MW
   - Period 2: 224 MW
   - Period 3: 221 MW
   - Period 4: 189 MW

2. **Generator Capacity Limits**:
   - Each generator has a minimum and maximum power output:
     - Type 0: Minimum 35 MW, Maximum 128 MW
     - Type 1: Minimum 35 MW, Maximum 129 MW
     - Type 2: Minimum 35 MW, Maximum 125 MW
   - The power output of each generator must be within these limits based on whether it is active.

3. **Reserve Margin**: To ensure reliability, the total maximum possible power output across all generators must be at least 15% higher than the demand in each period. This translates to:
   - Period 0: 192.05 MW
   - Period 1: 243.8 MW
   - Period 2: 257.6 MW
   - Period 3: 254.15 MW
   - Period 4: 217.35 MW

4. **Generator Availability**:
   - The number of generators that can be active is limited:
     - Type 0: Maximum 1 generator per period
     - Type 1: Maximum 4 generators per period
     - Type 2: Maximum 3 generators per period

5. **Startup Logic**:
   - If a generator is started in a period, it must have been inactive in the previous period.
   - For Type 2 generators, up to 2 additional generators can be started in Period 0 without requiring a startup in the previous period.

#### Numerical Parameters:
- **Base Costs**: 79 units per active generator per period.
- **Per-MW Costs**: 3 units for Type 0, 4 units for Types 1 and 2.
- **Startup Costs**: 355 units for Type 0, 349 units for Types 1 and 2.
- **Demands**: 167 MW (Period 0), 212 MW (Period 1), 224 MW (Period 2), 221 MW (Period 3), 189 MW (Period 4).
- **Capacity Limits**: 
  - Type 0: 35 MW (min), 128 MW (max)
  - Type 1: 35 MW (min), 129 MW (max)
  - Type 2: 35 MW (min), 125 MW (max)
- **Reserve Margins**: 192.05 MW (Period 0), 243.8 MW (Period 1), 257.6 MW (Period 2), 254.15 MW (Period 3), 217.35 MW (Period 4).

Your task is to determine the optimal combination of active generators, their power outputs, and startup decisions to meet the region's electricity demand at the lowest total cost while adhering to all operational constraints.","\[
\begin{aligned}
\min \quad & \sum_{t=0}^{4}\sum_{i=0}^{2}\sum_{j=1}^{n_i}\Bigl(79\,y_{i,j,t}+c_i\,p_{i,j,t}+\sigma_i\,s_{i,j,t}\Bigr)\\[4pt]
\text{s.t.}\quad & \sum_{i=0}^{2}\sum_{j=1}^{n_i}p_{i,j,t}\;\ge\;D_t \qquad \forall t=0,\dots,4\\
& \sum_{i=0}^{2}\sum_{j=1}^{n_i}M_i\,y_{i,j,t}\;\ge\;R_t \qquad \forall t=0,\dots,4\\
& p_{i,j,t}\;\le\;M_i\,y_{i,j,t}\qquad \forall i,j,t\\
& p_{i,j,t}\;\ge\;m_i\,y_{i,j,t}\qquad \forall i,j,t\\
& y_{i,j,0}=s_{i,j,0}\qquad \forall i,j\\
& s_{i,j,t}\;\le\;y_{i,j,t}\qquad \forall i,j,\;t=1,\dots,4\\
& s_{i,j,t}\;\le\;1-y_{i,j,t-1}\qquad \forall i,j,\;t=1,\dots,4\\
& s_{i,j,t}\;\ge\;y_{i,j,t}-y_{i,j,t-1}\qquad \forall i,j,\;t=1,\dots,4\\
& \sum_{j=1}^{3}s_{2,j,0}\;\le\;2\\
& \sum_{j=1}^{n_i}y_{i,j,t}\;\le\;n_i \qquad \forall i,t\\
& y_{i,j,t}\in\{0,1\},\; s_{i,j,t}\in\{0,1\},\; p_{i,j,t}\ge0 \qquad \forall i,j,t
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Data
n_i = [3, 4, 5]          # number of units for each type i
c_i = [10, 20, 30]       # cost coefficient for p
sigma_i = [5, 5, 5]      # cost coefficient for s
M_i = [100, 200, 300]    # upper bound for p when y=1
m_i = [10, 20, 30]       # lower bound for p when y=1
D_t = [50, 60, 70, 80, 90]   # demand at each time period t
R_t = [200, 250, 300, 350, 400]  # resource requirement at each time period t

# Create model
m = gp.Model(""Production_Scheduling"")

# Decision variables
y = m.addVars(3, max(n_i), 5, vtype=GRB.BINARY, name=""y"")   # y[i,j,t]
p = m.addVars(3, max(n_i), 5, vtype=GRB.CONTINUOUS, lb=0, name=""p"")  # p[i,j,t]
s = m.addVars(3, max(n_i), 5, vtype=GRB.BINARY, name=""s"")   # s[i,j,t]

# Objective: minimize total cost
obj = gp.quicksum(
    79 * y[i, j, t] +
    c_i[i] * p[i, j, t] +
    sigma_i[i] * s[i, j, t]
    for i in range(3)
    for j in range(n_i[i])
    for t in range(5)
)
m.setObjective(obj, GRB.MINIMIZE)

# Constraints
# Demand and resource constraints for each time period
for t in range(5):
    m.addConstr(
        gp.quicksum(p[i, j, t] for i in range(3) for j in range(n_i[i])) >= D_t[t],
        name=f""demand_{t}""
    )
    m.addConstr(
        gp.quicksum(M_i[i] * y[i, j, t] for i in range(3) for j in range(n_i[i])) >= R_t[t],
        name=f""resource_{t}""
    )

# Production bounds
for i in range(3):
    for j in range(n_i[i]):
        for t in range(5):
            m.addConstr(p[i, j, t] <= M_i[i] * y[i, j, t], name=f""p_le_M_{i}_{j}_{t}"")
            m.addConstr(p[i, j, t] >= m_i[i] * y[i, j, t], name=f""p_ge_m_{i}_{j}_{t}"")

# Initial state constraints
for i in range(3):
    for j in range(n_i[i]):
        m.addConstr(y[i, j, 0] == s[i, j, 0], name=f""init_y_s_{i}_{j}"")

# Switching constraints for t >= 1
for i in range(3):
    for j in range(n_i[i]):
        for t in range(1, 5):
            m.addConstr(s[i, j, t] <= y[i, j, t], name=f""s_le_y_{i}_{j}_{t}"")
            m.addConstr(s[i, j, t] <= 1 - y[i, j, t-1], name=f""s_le_1_minus_y_{i}_{j}_{t}"")
            m.addConstr(s[i, j, t] >= y[i, j, t] - y[i, j, t-1], name=f""s_ge_y_minus_y_{i}_{j}_{t}"")

# Constraint on initial switches for type 2 (i=2)
m.addConstr(
    gp.quicksum(s[2, j, 0] for j in range(min(3, n_i[2]))) <= 2,
    name=""switch_limit_type2_initial""
)

# Capacity constraints (redundant but included)
for i in range(3):
    for t in range(5):
        m.addConstr(
            gp.quicksum(y[i, j, t] for j in range(n_i[i])) <= n_i[i],
            name=f""capacity_{i}_{t}""
        )

# Optimize
m.optimize()
```",5026,4904,0,,,,,,,,
"Minimize the total cost, which includes production costs of 143.7514410203047 units per production decision, startup costs of 65.60228476581376 units per machine startup, inventory holding costs of 1.164609943740513 units for Product 0, 1.188814519462053 units for Product 1, and 0.8889238919759239 units for Product 2 per period, and backlogging costs of 6.772870896644705 units for Product 0, 7.291249122946056 units for Product 1, and 6.513011399630116 units for Product 2 per period. The production decisions are binary, indicating whether a product is produced on a specific machine in a given period, and the startup decisions are binary, indicating whether a machine is started up for a specific product in a given period. The production quantities must be non-negative, and the inventory and backlog levels must balance to meet the demand for each product in each period. The demand for Product 0 is 16.86823685495585 units in Period 0, 21.66307881187974 units in Period 1, and 22.77330720589323 units in Period 2. The demand for Product 1 is 23.97615061004427 units in Period 0, 19.60905873481086 units in Period 1, and 23.31252847872402 units in Period 2. The demand for Product 2 is 23.6195969696504 units in Period 0, 18.33370330296734 units in Period 1, and 22.95855759036257 units in Period 2. Each machine has a limited capacity, and the total production on a machine in a given period cannot exceed this capacity. For Machine 0, the capacity constraints are -71.6204295699619 times the production decision plus 6.477399095211152 times the startup decision plus the production quantity must be less than or equal to zero for each product and period. For Machine 1, the capacity constraints are -71.47086166745689 times the production decision plus 6.845777110793686 times the startup decision plus the production quantity must be less than or equal to zero for each product and period. Each machine can only produce one product at a time in a given period, and the production and startup decisions must follow logical constraints to ensure that a machine is only started up if it was not already producing the same product in the previous period. The production and startup decisions are binary, and the production quantities, inventory, and backlog levels must be non-negative.","\[
\begin{aligned}
\min\;&\sum_{m=0}^{1}\sum_{p=0}^{2}\sum_{t=0}^{2}
\Bigl(143.7514410203047\,y_{mpt}+65.60228476581376\,s_{mpt}\Bigr)
+\sum_{p=0}^{2}\sum_{t=0}^{2}
\Bigl(h_p\,I_{pt}+b_p\,B_{pt}\Bigr)\\[4pt]
\text{s.t. }&-71.6204295699619\,y_{0pt}+6.477399095211152\,s_{0pt}+q_{0pt}\le 0,
\qquad \forall p,t\\
&-71.47086166745689\,y_{1pt}+6.845777110793686\,s_{1pt}+q_{1pt}\le 0,
\qquad \forall p,t\\[4pt]
&\sum_{p=0}^{2}y_{mpt}\le 1,\qquad \forall m,t\\[4pt]
&\text{Startup logic:}\\
&\quad s_{mpt}\le y_{mpt},\qquad
s_{mpt}\le 1-y_{mp(t-1)},\qquad
s_{mpt}\ge y_{mpt}-y_{mp(t-1)},\qquad \forall m,p,t>0\\
&\quad s_{mp0}\le y_{mp0},\qquad \forall m,p\\[4pt]
&\text{Inventory/backlog balance:}\\
& I_{p0}+B_{p0}= \sum_{m=0}^{1}q_{mp0}-D_{p0},\qquad \forall p\\
& I_{pt}+B_{pt}= I_{p(t-1)}+B_{p(t-1)}+\sum_{m=0}^{1}q_{mp t}-D_{pt},
\qquad \forall p,\;t>0\\[4pt]
& q_{mpt}\ge 0,\; I_{pt}\ge 0,\; B_{pt}\ge 0,\qquad \forall m,p,t\\
& y_{mpt}\in\{0,1\},\; s_{mpt}\in\{0,1\},\qquad \forall m,p,t
\end{aligned}
\]

where  

\[
h_0=1.164609943740513,\; h_1=1.188814519462053,\; h_2=0.8889238919759239,
\]
\[
b_0=6.772870896644705,\; b_1=7.291249122946056,\; b_2=6.513011399630116,
\]
\[
D_{p0}=\begin{cases}
16.86823685495585,&p=0\\
23.97615061004427,&p=1\\
23.6195969696504,&p=2
\end{cases},
\quad
D_{p1}=\begin{cases}
21.66307881187974,&p=0\\
19.60905873481086,&p=1\\
18.33370330296734,&p=2
\end{cases},
\quad
D_{p2}=\begin{cases}
22.77330720589323,&p=0\\
23.31252847872402,&p=1\\
22.95855759036257,&p=2
\end{cases}.
\]","import gurobipy as gp
from gurobipy import GRB

# Parameters
h = [1.164609943740513, 1.188814519462053, 0.8889238919759239]
b = [6.772870896644705, 7.291249122946056, 6.513011399630116]
D = [
    [16.86823685495585, 21.66307881187974, 22.77330720589323],  # p=0
    [23.97615061004427, 19.60905873481086, 23.31252847872402],  # p=1
    [23.6195969696504, 18.33370330296734, 22.95855759036257]   # p=2
]

m_vals = [0, 1]
p_vals = [0, 1, 2]
t_vals = [0, 1, 2]

# Create model
model = gp.Model(""Production_Scheduling"")

# Decision variables
y = model.addVars(m_vals, p_vals, t_vals, vtype=GRB.BINARY, name=""y"")
s = model.addVars(m_vals, p_vals, t_vals, vtype=GRB.BINARY, name=""s"")
q = model.addVars(m_vals, p_vals, t_vals, lb=0, name=""q"")
I = model.addVars(p_vals, t_vals, lb=0, name=""I"")
B = model.addVars(p_vals, t_vals, lb=0, name=""B"")

# Objective
obj = gp.quicksum(143.7514410203047 * y[m,p,t] + 65.60228476581376 * s[m,p,t]
                  for m in m_vals for p in p_vals for t in t_vals)
obj += gp.quicksum(h[p] * I[p,t] + b[p] * B[p,t]
                   for p in p_vals for t in t_vals)
model.setObjective(obj, GRB.MINIMIZE)

# Capacity constraints
for p in p_vals:
    for t in t_vals:
        model.addConstr(-71.6204295699619 * y[0,p,t] + 6.477399095211152 * s[0,p,t] + q[0,p,t] <= 0,
                        name=f""cap0_{p}_{t}"")
        model.addConstr(-71.47086166745689 * y[1,p,t] + 6.845777110793686 * s[1,p,t] + q[1,p,t] <= 0,
                        name=f""cap1_{p}_{t}"")

# Production capacity per machine per period
for m in m_vals:
    for t in t_vals:
        model.addConstr(gp.quicksum(y[m,p,t] for p in p_vals) <= 1,
                        name=f""prod_cap_{m}_{t}"")

# Startup logic
for m in m_vals:
    for p in p_vals:
        model.addConstr(s[m,p,0] <= y[m,p,0], name=f""startup0_{m}_{p}"")
        for t in t_vals[1:]:
            model.addConstr(s[m,p,t] <= y[m,p,t], name=f""startup1_{m}_{p}_{t}"")
            model.addConstr(s[m,p,t] <= 1 - y[m,p,t-1], name=f""startup2_{m}_{p}_{t}"")
            model.addConstr(s[m,p,t] >= y[m,p,t] - y[m,p,t-1], name=f""startup3_{m}_{p}_{t}"")

# Inventory/backlog balance
for p in p_vals:
    model.addConstr(I[p,0] + B[p,0] == gp.quicksum(q[m,p,0] for m in m_vals) - D[p][0],
                    name=f""balance0_{p}"")
    for t in t_vals[1:]:
        model.addConstr(I[p,t] + B[p,t] == I[p,t-1] + B[p,t-1] + gp.quicksum(q[m,p,t] for m in m_vals) - D[p][t],
                        name=f""balance_{p}_{t}"")

# Optimize
model.optimize()
",,914.6636377,0,,,,,,,,
"In a manufacturing facility, the goal is to schedule the production of seven jobs, each consisting of two operations that must be performed in sequence, to minimize the total production time (makespan). Each operation has a processing time of 1 unit of time. Operations from different jobs may share machines, requiring careful scheduling to avoid overlaps. Binary variables determine the order of operations on shared machines, ensuring that one operation finishes before another starts. A large constant (100,000) is used to enforce this order in the constraints. 

The constraints include precedence constraints within each job, ensuring that the second operation cannot start until the first operation is completed. Machine capacity constraints prevent overlapping operations on shared machines, with specific pairs of operations (e.g., Operation 1 of Job 2 and Operation 0 of Job 4, Operation 1 of Job 2 and Operation 0 of Job 6, etc.) requiring explicit ordering. The makespan is defined as the maximum completion time across all operations, ensuring it is at least as long as the last operation's finish time. All start times for operations must be non-negative, and binary variables are restricted to 0 or 1. 

The objective is to minimize the makespan, ensuring all operations are completed efficiently while respecting machine usage and operation sequencing constraints. The problem involves 26 pairs of operations on shared machines, with binary variables determining their order.","\[
\begin{aligned}
\min \quad & C \\[4pt]
\text{s.t.}\quad
& s_{j,1}\;\ge\;s_{j,0}+1 && \forall\, j=1,\dots,7 \\[2pt]
& s_{j,0}\;\ge\;0,\;\; s_{j,1}\;\ge\;0 && \forall\, j=1,\dots,7 \\[2pt]
& C\;\ge\;s_{j,0}+1,\;\; C\;\ge\;s_{j,1}+1 && \forall\, j=1,\dots,7 \\[4pt]
& s_{i}+1\;\le\;s_{j}+M\,(1-y_{ij}) && \forall\,(i,j)\in\mathcal{P} \\[2pt]
& s_{j}+1\;\le\;s_{i}+M\,y_{ij} && \forall\,(i,j)\in\mathcal{P} \\[4pt]
& y_{ij}\in\{0,1\} && \forall\,(i,j)\in\mathcal{P} \\[4pt]
& s_{j,k}\in\mathbb{R}_{+} && \forall\, j=1,\dots,7,\; k=0,1 \\[2pt]
& C\in\mathbb{R}_{+}
\end{aligned}
\]

where  

\[
\mathcal{P}=\{\,((j_{1},k_{1}),(j_{2},k_{2}))\mid \text{operations }(j_{1},k_{1})\text{ and }(j_{2},k_{2})\text{ share a machine}\,\}
\]

contains the 26 specified pairs, and \(M=100\,000\).","import gurobipy as gp
from gurobipy import GRB

# Create the model
m = gp.Model(""Scheduling_Optimization"")

# Parameters
M = 100000
jobs = range(1, 8)  # j = 1..7
k_vals = [0, 1]

# Decision variables
s = {(j, k): m.addVar(lb=0, name=f""s_{j}_{k}"") for j in jobs for k in k_vals}
C = m.addVar(lb=0, name=""C"")

# Define the set of pairs P that share a machine (26 pairs)
# Example placeholder: P = [((1,0),(2,1)), ((3,0),(4,1)), ...]
P = []  # <-- fill with 26 pairs of operations that share a machine

# Binary variables for precedence decisions
y = {(i_k, j_l): m.addVar(vtype=GRB.BINARY,
                          name=f""y_{i_k[0]}_{i_k[1]}_{j_l[0]}_{j_l[1]}"") for (i_k, j_l) in P}

# Constraints
for j in jobs:
    m.addConstr(s[j, 1] >= s[j, 0] + 1, name=f""seq_{j}"")

for j in jobs:
    m.addConstr(C >= s[j, 0] + 1, name=f""C_ge_s0_{j}"")
    m.addConstr(C >= s[j, 1] + 1, name=f""C_ge_s1_{j}"")

for (i_k, j_l) in P:
    m.addConstr(s[i_k[0], i_k[1]] + 1 <= s[j_l[0], j_l[1]] + M * (1 - y[(i_k, j_l)]),
                name=f""pre1_{i_k}_{j_l}"")
    m.addConstr(s[j_l[0], j_l[1]] + 1 <= s[i_k[0], i_k[1]] + M * y[(i_k, j_l)],
                name=f""pre2_{i_k}_{j_l}"")

# Objective
m.setObjective(C, GRB.MINIMIZE)

# Optimize
m.optimize()

# Print results
if m.status == GRB.OPTIMAL:
    print(f""Optimal C: {C.X}"")
    for j in jobs:
        print(f""s_{j}_0 = {s[j,0].X}, s_{j}_1 = {s[j,1].X}"")
    for (i_k, j_l) in P:
        print(f""y_{i_k}_{j_l} = {y[(i_k, j_l)].X}"")",2,5,0,,,,,,,,
"The problem involves scheduling operations for six products, each requiring two operations to be performed in sequence. Each operation is assigned to a specific machine, and the goal is to minimize the total production time (makespan). Each operation has a processing time of 1 unit. The start time of each operation must be determined, and the order of operations on shared machines must be decided to avoid overlaps. Precedence constraints ensure that the second operation of a product cannot start until the first operation is completed. Machine capacity constraints ensure that operations assigned to the same machine do not overlap in time. The makespan must be at least as long as the completion time of the last operation across all products. Binary decision variables determine the order of operations on shared machines, and a large number (100,000) is used in the constraints to enforce this order without overlapping. The objective is to minimize the makespan by determining the start times of all operations and the order of operations on shared machines, ensuring all products are completed as quickly as possible.","\[
\begin{aligned}
\min \quad & C \\[4pt]
\text{s.t.} \quad 
& s_{p,2} \;\ge\; s_{p,1} + 1 && \forall\,p=1,\dots,6 \\[4pt]
& s_{p,o} + 1 \;\le\; s_{q,r} + M\bigl(1 - y_{(p,o),(q,r)}\bigr) && \forall\,p,q=1,\dots,6,\; o,r=1,2,\; (p,o)\neq(q,r),\; m_{p,o}=m_{q,r} \\[4pt]
& s_{q,r} + 1 \;\le\; s_{p,o} + M\,y_{(p,o),(q,r)} && \forall\,p,q=1,\dots,6,\; o,r=1,2,\; (p,o)\neq(q,r),\; m_{p,o}=m_{q,r} \\[4pt]
& C \;\ge\; s_{p,o} + 1 && \forall\,p=1,\dots,6,\; o=1,2 \\[4pt]
& s_{p,o} \;\ge\; 0 && \forall\,p,o \\[4pt]
& y_{(p,o),(q,r)} \;\in\; \{0,1\} && \forall\,p,q=1,\dots,6,\; o,r=1,2,\; m_{p,o}=m_{q,r} \\[4pt]
& C \;\ge\; 0
\end{aligned}
\]

\[
\text{where } M = 100000
\]

\[
\begin{aligned}
& s_{p,o}\in\mathbb{R}_+ && \forall\,p,o \\
& y_{(p,o),(q,r)}\in\{0,1\} && \forall\,p,q,o,r \text{ with } m_{p,o}=m_{q,r} \\
& C\in\mathbb{R}_+
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Example data for m_{p,o}
# 6 tasks, each with two stages (o=1,2)
m_data = [
    [1, 1],  # task 1
    [1, 1],  # task 2
    [2, 2],  # task 3
    [2, 2],  # task 4
    [3, 3],  # task 5
    [3, 3]   # task 6
]

M = 100000

# Create model
m = gp.Model(""Scheduling_Problem"")

# Decision variables s_{p,o}
s = {}
for p in range(1, 7):
    for o in [1, 2]:
        s[(p, o)] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=f""s_{p}_{o}"")

# Binary variables y_{(p,o),(q,r)} for pairs with same m
y = {}
for p in range(1, 7):
    for o in [1, 2]:
        for q in range(1, 7):
            for r in [1, 2]:
                if (p, o) != (q, r) and m_data[p-1][o-1] == m_data[q-1][r-1]:
                    y[((p, o), (q, r))] = m.addVar(vtype=GRB.BINARY,
                                                    name=f""y_{p}_{o}_{q}_{r}"")

# Continuous variable C
C = m.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""C"")

# Objective: minimize C
m.setObjective(C, GRB.MINIMIZE)

# Constraints
# 1. s_{p,2} >= s_{p,1} + 1
for p in range(1, 7):
    m.addConstr(s[(p, 2)] >= s[(p, 1)] + 1, name=f""order_{p}"")

# 2. Big-M ordering constraints with binary y
for (p, o), (q, r) in y:
    m.addConstr(s[(p, o)] + 1 <= s[(q, r)] + M * (1 - y[((p, o), (q, r))]),
                name=f""bigM1_{p}_{o}_{q}_{r}"")
    m.addConstr(s[(q, r)] + 1 <= s[(p, o)] + M * y[((p, o), (q, r))],
                name=f""bigM2_{p}_{o}_{q}_{r}"")

# 3. C >= s_{p,o} + 1
for p in range(1, 7):
    for o in [1, 2]:
        m.addConstr(C >= s[(p, o)] + 1, name=f""C_ge_s_{p}_{o}"")

# 4. Non-negativity of s and C is already enforced by lb=0

# Optimize
m.optimize()
",2,6,0,,,,,,,,
"There are 7 jobs, each consisting of 2 operations that must be performed in sequence. Each operation takes exactly 1 unit of time to complete. The operations are assigned to specific machines, and each machine can process only one operation at a time. The goal is to schedule the operations on the machines to minimize the total completion time, known as the makespan, while satisfying all constraints.

For each job, the second operation cannot start until the first operation is completed. If two operations are assigned to the same machine, they cannot overlap in time. Binary decision variables are used to determine the order of operations on shared machines. If one operation is scheduled before another on the same machine, the corresponding binary variable is set to 1; otherwise, it is set to 0. A large constant (100000) is used in the constraints to ensure that the binary variables correctly enforce the order of operations on shared machines.

The start time of each operation must be non-negative, and the makespan must be at least as large as the completion time of every operation. The objective is to determine the start times for all operations on their respective machines such that all precedence and machine capacity constraints are satisfied, and the total completion time is minimized.","\[
\begin{aligned}
\min \quad & C \\[4pt]
\text{s.t.}\quad
& s_{j,2} \;\ge\; s_{j,1} + 1 && \forall j=1,\dots,7 \\[4pt]
& s_{j,1} \;\ge\; 0,\; s_{j,2} \;\ge\; 0 && \forall j \\[4pt]
& C \;\ge\; s_{j,k} + 1 && \forall j=1,\dots,7,\; k=1,2 \\[4pt]
& s_{o} + 1 \;\le\; s_{p} + M\,(1 - y_{op}) && \forall o<p \text{ with } \text{machine}(o)=\text{machine}(p) \\[4pt]
& s_{p} + 1 \;\le\; s_{o} + M\,y_{op} && \forall o<p \text{ with } \text{machine}(o)=\text{machine}(p) \\[4pt]
& y_{op} \;\in\; \{0,1\} && \forall o<p \text{ with } \text{machine}(o)=\text{machine}(p) \\[4pt]
& s_{j,k} \;\in\; \mathbb{R}_+ && \forall j,k \\[4pt]
& C \;\in\; \mathbb{R}_+ \\[4pt]
& M = 100000
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Parameters
num_jobs = 7
M = 100000

# Example machine assignment for each operation (job, stage)
# Replace with actual data
machine = {
    (0,0): 1, (0,1): 2,
    (1,0): 1, (1,1): 2,
    (2,0): 1, (2,1): 2,
    (3,0): 1, (3,1): 2,
    (4,0): 1, (4,1): 2,
    (5,0): 1, (5,1): 2,
    (6,0): 1, (6,1): 2
}

# Create model
m = gp.Model(""Scheduling"")

# Decision variables: start times s[j,k] (k=0 for stage 1, k=1 for stage 2)
s = m.addVars(num_jobs, 2, lb=0, vtype=GRB.CONTINUOUS, name=""s"")

# Makespan variable
C = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""C"")

# Binary ordering variables for operations on the same machine
y = {}
for o in range(num_jobs):
    for p in range(o+1, num_jobs):
        if machine[(o,0)] == machine[(p,0)]:
            y[(o,p)] = m.addVar(vtype=GRB.BINARY, name=f""y_{o}_{p}"")

# Objective: minimize makespan
m.setObjective(C, GRB.MINIMIZE)

# Constraints
# Stage 2 starts at least 1 unit after stage 1 for each job
for j in range(num_jobs):
    m.addConstr(s[j,1] >= s[j,0] + 1, name=f""seq_{j}"")

# Makespan bounds
for j in range(num_jobs):
    for k in range(2):
        m.addConstr(C >= s[j,k] + 1, name=f""C_ge_s_{j}_{k}"")

# Ordering constraints for operations on the same machine
for (o,p), var in y.items():
    # operation 1 of job o before job p
    m.addConstr(s[o,0] + 1 <= s[p,0] + M * (1 - var), name=f""order1_{o}_{p}"")
    # operation 1 of job p before job o
    m.addConstr(s[p,0] + 1 <= s[o,0] + M * var, name=f""order2_{o}_{p}"")

# Optimize
m.optimize()

# Output results
if m.status == GRB.OPTIMAL:
    print(f""Optimal makespan C = {C.X}"")
    for j in range(num_jobs):
        print(f""Job {j+1}: start stage 1 = {s[j,0].X}, start stage 2 = {s[j,1].X}"")
    for (o,p), var in y.items():
        print(f""y_{o}_{p} = {var.X}"")",3,5,0,,,,,,,,
"Determine the production amounts, inventory levels, and setup decisions for two products, Product A and Product B, over a seven-period planning horizon to minimize total costs, including production, setup, and inventory holding costs, while meeting demand and adhering to resource constraints. Production costs vary by period: producing one unit of Product A costs 42 units in Period 0, 44 in Period 1, 40 in Period 2, 43 in Period 3, 45 in Period 4, 45 in Period 5, and 42 in Period 6. Producing one unit of Product B costs 46 units in Period 0, 44 in Period 1, 50 in Period 2, 40 in Period 3, 41 in Period 4, 41 in Period 5, and 43 in Period 6. Setup costs are fixed: setting up production for Product A costs 1032 units in Period 0, 1318 in Period 1, 1002 in Period 2, 1073 in Period 3, 1387 in Period 4, 1491 in Period 5, and 1063 in Period 6. For Product B, setup costs are 1260 units in Period 0, 1418 in Period 1, 1455 in Period 2, 1266 in Period 3, 1095 in Period 4, 1431 in Period 5, and 1420 in Period 6. Inventory holding costs are constant: holding one unit of Product A costs 5 units in all periods except Periods 5 and 6, where it costs 4 units. Holding one unit of Product B costs 5 units in Periods 0, 2, 4, 5, and 6, and 4 units in Periods 1 and 3. 

Demand must be satisfied in each period: cumulative demand for Product A is 67 units in Period 0, 160 in Period 1, 213 in Period 2, 309 in Period 3, 376 in Period 4, 464 in Period 5, and 564 in Period 6. For Product B, cumulative demand is 100 units in Period 0, 199 in Period 1, 250 in Period 2, 332 in Period 3, 394 in Period 4, 450 in Period 5, and 516 in Period 6. Resource capacity limits production: in Period 0, the combined production of Product A and Product B cannot exceed 1138 units of resource capacity, with Product A consuming 1.547487551721541 units and Product B consuming 1.91801512951683 units per unit produced. Capacity limits are 1019 units in Period 1, 1166 in Period 2, 1163 in Period 3, 1042 in Period 4, 1098 in Period 5, and 1166 in Period 6. 

Production of a product in a period can only occur if the setup for that product is activated in that period. For Product A, production in Period 0 cannot exceed 564 units if the setup is activated, 497 in Period 1, 404 in Period 2, 351 in Period 3, 255 in Period 4, 188 in Period 5, and 100 in Period 6. For Product B, production in Period 0 cannot exceed 516 units if the setup is activated, 416 in Period 1, 317 in Period 2, 266 in Period 3, 184 in Period 4, 122 in Period 5, and 66 in Period 6. 

Initial inventory for both products is zero at the start of Period 0, and all inventory must be depleted by the end of Period 6. Production amounts and inventory levels must be non-negative. The objective is to minimize the total cost, which includes production costs, setup costs, and inventory holding costs, while ensuring all constraints are satisfied.","\[
\begin{aligned}
\min\;&\sum_{t=0}^{6}\Bigl(
42_t\,P_{A,t}+44_t\,P_{B,t}
+1032_t\,S_{A,t}+1260_t\,S_{B,t}
+5_t\,I_{A,t}+h_{B,t}\,I_{B,t}\Bigr)\\[4pt]
\text{s.t. }&I_{A,0}=0,\;I_{B,0}=0,\\
& I_{A,t+1}=I_{A,t}+P_{A,t}-D_{A,t}\quad(t=0,\dots,6),\\
& I_{B,t+1}=I_{B,t}+P_{B,t}-D_{B,t}\quad(t=0,\dots,6),\\
& I_{A,7}=0,\;I_{B,7}=0,\\
& I_{A,t}\ge0,\;I_{B,t}\ge0\quad(t=0,\dots,7),\\
& P_{A,t}\le U_{A,t}\,S_{A,t}\quad(t=0,\dots,6),\\
& P_{B,t}\le U_{B,t}\,S_{B,t}\quad(t=0,\dots,6),\\
& 1.547487551721541\,P_{A,t}+1.91801512951683\,P_{B,t}\le C_t\quad(t=0,\dots,6),\\
& P_{A,t}\in\mathbb{Z}_+,\;P_{B,t}\in\mathbb{Z}_+,\;S_{A,t},S_{B,t}\in\{0,1\}\quad(t=0,\dots,6).
\end{aligned}
\]

where  

\[
\begin{array}{l}
42_t=(42,44,40,43,45,45,42),\\
44_t=(46,44,50,40,41,41,43),\\
1032_t=(1032,1318,1002,1073,1387,1491,1063),\\
1260_t=(1260,1418,1455,1266,1095,1431,1420),\\
5_t=(5,5,5,5,5,4,4),\\
h_{B,t}=(5,4,5,4,5,5,5),\\
D_{A,t}=(67,93,53,96,87,88,100),\\
D_{B,t}=(100,99,51,82,62,56,66),\\
U_{A,t}=(564,497,404,351,255,188,100),\\
U_{B,t}=(516,416,317,266,184,122,66),\\
C_t=(1138,1019,1166,1163,1042,1098,1166).
\end{array}
\]","import gurobipy as gp
from gurobipy import GRB

# Data
cost_P_A = [42, 44, 40, 43, 45, 45, 42]
cost_P_B = [46, 44, 50, 40, 41, 41, 43]
cost_S_A = [1032, 1318, 1002, 1073, 1387, 1491, 1063]
cost_S_B = [1260, 1418, 1455, 1266, 1095, 1431, 1420]
cost_I_A = [5, 5, 5, 5, 5, 4, 4]
cost_I_B = [5, 4, 5, 4, 5, 5, 5]
D_A = [67, 93, 53, 96, 87, 88, 100]
D_B = [100, 99, 51, 82, 62, 56, 66]
U_A = [564, 497, 404, 351, 255, 188, 100]
U_B = [516, 416, 317, 266, 184, 122, 66]
C = [1138, 1019, 1166, 1163, 1042, 1098, 1166]

# Create model
m = gp.Model(""Production_Scheduling"")

# Decision variables
I_A = m.addVars(8, vtype=GRB.INTEGER, lb=0, name=""I_A"")   # t=0..7
I_B = m.addVars(8, vtype=GRB.INTEGER, lb=0, name=""I_B"")
P_A = m.addVars(7, vtype=GRB.INTEGER, lb=0, name=""P_A"")   # t=0..6
P_B = m.addVars(7, vtype=GRB.INTEGER, lb=0, name=""P_B"")
S_A = m.addVars(7, vtype=GRB.BINARY, name=""S_A"")
S_B = m.addVars(7, vtype=GRB.BINARY, name=""S_B"")

# Initial inventory constraints
m.addConstr(I_A[0] == 0, name=""I_A_0"")
m.addConstr(I_B[0] == 0, name=""I_B_0"")

# Inventory balance constraints
for t in range(7):
    m.addConstr(I_A[t+1] == I_A[t] + P_A[t] - D_A[t], name=f""balance_A_{t}"")
    m.addConstr(I_B[t+1] == I_B[t] + P_B[t] - D_B[t], name=f""balance_B_{t}"")

# Final inventory constraints
m.addConstr(I_A[7] == 0, name=""I_A_7"")
m.addConstr(I_B[7] == 0, name=""I_B_7"")

# Production capacity constraints
for t in range(7):
    m.addConstr(P_A[t] <= U_A[t] * S_A[t], name=f""cap_A_{t}"")
    m.addConstr(P_B[t] <= U_B[t] * S_B[t], name=f""cap_B_{t}"")

# Capacity limit constraint
for t in range(7):
    m.addConstr(1.547487551721541 * P_A[t] + 1.91801512951683 * P_B[t] <= C[t], name=f""capacity_limit_{t}"")

# Objective function
obj = gp.quicksum(
    cost_P_A[t] * P_A[t] +
    cost_P_B[t] * P_B[t] +
    cost_S_A[t] * S_A[t] +
    cost_S_B[t] * S_B[t] +
    cost_I_A[t] * I_A[t] +
    cost_I_B[t] * I_B[t]
    for t in range(7)
)
m.setObjective(obj, GRB.MINIMIZE)

# Optimize
m.optimize()
",57405,56408,0,,,,,,,,
" Inventory Management for a Retail Supply Chain

You are responsible for managing the inventory and ordering process for a retail supply chain over a 21-week period. The goal is to minimize the total costs associated with ordering and holding inventory while ensuring that customer demand is met each week. The costs include ordering costs, unit purchase costs, and inventory holding costs. Additionally, there are specific constraints on inventory levels and ordering decisions.

#### Key Decisions:
1. **Ordering Decisions**: Each week, you must decide whether to place an order (a binary decision) and, if so, how much to order. Placing an order incurs a fixed cost, and the amount ordered cannot exceed a certain limit based on the total demand over the 21-week period.
2. **Inventory Levels**: You must manage the ending inventory each week, ensuring that it meets the flow balance constraints (i.e., the inventory carried over from the previous week plus the amount ordered equals the ending inventory plus the demand for that week).

#### Objective:
Minimize the total cost, which includes:
- **Ordering Costs**: Fixed costs for placing an order in a given week. These costs vary by week and are as follows: 459 in week 1, 555 in week 2, 547 in week 3, 530 in week 4, 436 in week 5, 401 in week 6, 490 in week 7, 462 in week 8, 479 in week 9, 563 in week 10, 456 in week 11, 442 in week 12, 530 in week 13, 427 in week 14, 512 in week 15, 574 in week 16, 430 in week 17, 424 in week 18, 484 in week 19, 507 in week 20, and 446 in week 21.
- **Unit Purchase Costs**: Variable costs for each unit ordered. These costs also vary by week and are as follows: 49 in week 1, 48 in week 2, 55 in week 3, 44 in week 4, 51 in week 5, 48 in week 6, 53 in week 7, 43 in week 8, 42 in week 9, 52 in week 10, 45 in week 11, 42 in week 12, 43 in week 13, 42 in week 14, 59 in week 15, 57 in week 16, 57 in week 17, 44 in week 18, 57 in week 19, 60 in week 20, and 43 in week 21.
- **Holding Costs**: Costs for holding inventory at the end of each week. These costs are as follows: 23 in week 1, 28 in week 2, 28 in week 3, 25 in week 4, 30 in week 5, 25 in week 6, 28 in week 7, 22 in week 8, 30 in week 9, 30 in week 10, 23 in week 11, 28 in week 12, 27 in week 13, 22 in week 14, 22 in week 15, 23 in week 16, 20 in week 17, 28 in week 18, 30 in week 19, 30 in week 20, and 24 in week 21.

#### Constraints:
1. **Flow Balance**: The ending inventory for each week must satisfy the following relationship:
   - Ending inventory from the previous week + amount ordered = ending inventory for the current week + demand for the current week.
   - The demand for each week is as follows: 150 in week 1, 132 in week 2, 135 in week 3, 178 in week 4, 133 in week 5, 173 in week 6, 161 in week 7, 195 in week 8, 110 in week 9, 118 in week 10, 131 in week 11, 198 in week 12, 118 in week 13, 120 in week 14, 129 in week 15, 148 in week 16, 189 in week 17, 178 in week 18, 145 in week 19, 161 in week 20, and 155 in week 21.

2. **Ordering Limits**: The amount ordered in any week cannot exceed the total demand over the 21-week period (3157 units) if an order is placed. If no order is placed, the amount ordered must be zero.

3. **Starting and Ending Inventory**: The starting inventory at the beginning of week 1 is zero, and the ending inventory at the end of week 21 must also be zero.

#### Goal:
Your task is to determine the optimal ordering and inventory management plan that minimizes the total cost while meeting all constraints. This includes deciding when to place orders, how much to order each week, and how much inventory to carry over each week to meet demand without exceeding the budget or violating any constraints.","\[
\begin{aligned}
\min\;&\sum_{t=1}^{21}\Bigl( f_t\,y_t + c_t\,Q_t + h_t\,I_t \Bigr)\\[4pt]
\text{s.t.}\;& I_{t-1}+Q_t = I_t + D_t,\qquad t=1,\dots,21\\[4pt]
& Q_t \;\le\; 3157\,y_t,\qquad t=1,\dots,21\\[4pt]
& Q_t \;\ge\; 0,\;\; I_t \;\ge\; 0,\;\; y_t \in\{0,1\},\;\; Q_t,I_t\in\mathbb{Z}_+,\qquad t=1,\dots,21\\[4pt]
& I_0 = 0,\;\; I_{21}=0
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB
import numpy as np

# Data for 21 periods (example values)
f = np.array([10,12,9,11,13,8,14,10,12,9,11,13,8,14,10,12,9,11,13,8,14])   # fixed cost per period
c = np.array([5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5,6,5])                 # variable cost per unit produced
h = np.array([2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2])                 # holding cost per unit inventory
D = np.array([100,120,90,110,130,80,140,100,120,90,110,130,80,140,100,120,90,110,130,80,140])  # demand

T = len(f)

# Create model
m = gp.Model(""Inventory_Production"")

# Decision variables
y = m.addVars(T, vtype=GRB.BINARY, name=""y"")          # plant open/close
Q = m.addVars(T, vtype=GRB.INTEGER, lb=0, name=""Q"")   # production quantity
I = m.addVars(T+1, vtype=GRB.INTEGER, lb=0, name=""I"") # inventory at end of period t (I[0] is initial)

# Initial and final inventory constraints
m.addConstr(I[0] == 0, name=""init_inventory"")
m.addConstr(I[T] == 0, name=""final_inventory"")

# Production capacity constraint
for t in range(T):
    m.addConstr(Q[t] <= 3157 * y[t], name=f""capacity_{t}"")

# Inventory balance constraints
for t in range(T):
    m.addConstr(I[t] + Q[t] == I[t+1] + D[t], name=f""balance_{t}"")

# Objective function
obj = gp.quicksum(f[t]*y[t] + c[t]*Q[t] + h[t]*I[t+1] for t in range(T))
m.setObjective(obj, GRB.MINIMIZE)

# Optimize
m.optimize()
",12861,165425,0,,,,,,,,
"You are tasked with managing the distribution of resources across eight interconnected cities to ensure each city meets its specific demand while minimizing the total transportation cost. Each city has a unique supply of resources, a specific demand, and a limited capacity to handle incoming shipments. Additionally, the transportation links between cities have varying costs and capacity constraints.

City 0 has a net outflow of 5 units, meaning it is a supply node, and it can handle up to 13 units of incoming shipments. City 1 has a net inflow of 2 units, meaning it is a demand node, and it can accommodate up to 14 units of incoming shipments. City 2 is balanced, with no net demand or surplus, and can handle up to 17 units of incoming shipments. City 3 is also balanced, with no net demand or surplus, and can handle up to 12 units of incoming shipments. City 4 has a net outflow of 1 unit, meaning it is a supply node, and it can handle up to 16 units of incoming shipments. City 5 has a net inflow of 2 units, meaning it is a demand node, and it can accommodate up to 19 units of incoming shipments. City 6 is balanced, with no net demand or surplus, and can handle up to 16 units of incoming shipments. City 7 has a net inflow of 2 units, meaning it is a demand node, and it can accommodate up to 14 units of incoming shipments.

The cost of transporting resources between cities varies, and each transportation link has a maximum capacity. From City 0: To City 1: Cost = 2, Capacity = 8; To City 2: Cost = 2, Capacity = 7; To City 3: Cost = 2, Capacity = 7; To City 4: Cost = 2, Capacity = 9; To City 5: Cost = 2, Capacity = 8; To City 6: Cost = 1, Capacity = 9; To City 7: Cost = 2, Capacity = 7. From City 1: To City 0: Cost = 1, Capacity = 8; To City 2: Cost = 1, Capacity = 8; To City 3: Cost = 3, Capacity = 7; To City 4: Cost = 2, Capacity = 8; To City 5: Cost = 1, Capacity = 7; To City 6: Cost = 3, Capacity = 9; To City 7: Cost = 1, Capacity = 9. From City 2: To City 0: Cost = 1, Capacity = 8; To City 1: Cost = 2, Capacity = 9; To City 3: Cost = 3, Capacity = 7; To City 4: Cost = 2, Capacity = 9; To City 5: Cost = 2, Capacity = 8; To City 6: Cost = 3, Capacity = 8; To City 7: Cost = 1, Capacity = 8. From City 3: To City 0: Cost = 3, Capacity = 7; To City 1: Cost = 3, Capacity = 7; To City 2: Cost = 3, Capacity = 7; To City 4: Cost = 2, Capacity = 7; To City 5: Cost = 3, Capacity = 7; To City 6: Cost = 2, Capacity = 9; To City 7: Cost = 3, Capacity = 9. From City 4: To City 0: Cost = 2, Capacity = 9; To City 1: Cost = 3, Capacity = 8; To City 2: Cost = 3, Capacity = 8; To City 3: Cost = 1, Capacity = 8; To City 5: Cost = 1, Capacity = 7; To City 6: Cost = 3, Capacity = 8; To City 7: Cost = 2, Capacity = 9. From City 5: To City 0: Cost = 1, Capacity = 7; To City 1: Cost = 3, Capacity = 7; To City 2: Cost = 3, Capacity = 7; To City 3: Cost = 3, Capacity = 9; To City 4: Cost = 2, Capacity = 8; To City 6: Cost = 2, Capacity = 9; To City 7: Cost = 3, Capacity = 8. From City 6: To City 0: Cost = 2, Capacity = 8; To City 1: Cost = 2, Capacity = 7; To City 2: Cost = 3, Capacity = 7; To City 3: Cost = 2, Capacity = 7; To City 4: Cost = 1, Capacity = 9; To City 5: Cost = 1, Capacity = 8; To City 7: Cost = 3, Capacity = 7. From City 7: To City 0: Cost = 2, Capacity = 8; To City 1: Cost = 2, Capacity = 8; To City 2: Cost = 2, Capacity = 7; To City 3: Cost = 3, Capacity = 9; To City 4: Cost = 1, Capacity = 7; To City 5: Cost = 2, Capacity = 8; To City 6: Cost = 3, Capacity = 7.

Your goal is to determine the optimal amount of resources to transport between cities to meet all demands while minimizing the total transportation cost. Ensure that each city's net resource flow matches its demand or surplus, no transportation link exceeds its capacity, and no city exceeds its capacity to handle incoming shipments.","\[
\begin{aligned}
\min\;&\sum_{i=0}^{7}\;\sum_{\substack{j=0\\ j\neq i}}^{7} c_{ij}\,x_{ij} \\[4pt]
\text{s.t.}\;&\sum_{\substack{j=0\\ j\neq i}}^{7}x_{ji}-\sum_{\substack{j=0\\ j\neq i}}^{7}x_{ij}=d_i
\qquad(i=0,\dots,7)\\[4pt]
&\sum_{\substack{j=0\\ j\neq i}}^{7}x_{ji}\le U_i
\qquad(i=0,\dots,7)\\[4pt]
&x_{ij}\le C_{ij}\qquad(i=0,\dots,7,\;j\neq i)\\[4pt]
&x_{ij}\ge 0\qquad(i=0,\dots,7,\;j\neq i)\\[4pt]
&x_{ij}\in\mathbb{R}_+\qquad(i=0,\dots,7,\;j\neq i)
\end{aligned}
\]

where  

\[
\begin{array}{c|c|c}
(i,j)&c_{ij}&C_{ij}\\\hline
(0,1)&2&8\\
(0,2)&2&7\\
(0,3)&2&7\\
(0,4)&2&9\\
(0,5)&2&8\\
(0,6)&1&9\\
(0,7)&2&7\\[2pt]
(1,0)&1&8\\
(1,2)&1&8\\
(1,3)&3&7\\
(1,4)&2&8\\
(1,5)&1&7\\
(1,6)&3&9\\
(1,7)&1&9\\[2pt]
(2,0)&1&8\\
(2,1)&2&9\\
(2,3)&3&7\\
(2,4)&2&9\\
(2,5)&2&8\\
(2,6)&3&8\\
(2,7)&1&8\\[2pt]
(3,0)&3&7\\
(3,1)&3&7\\
(3,2)&3&7\\
(3,4)&2&7\\
(3,5)&3&7\\
(3,6)&2&9\\
(3,7)&3&9\\[2pt]
(4,0)&2&9\\
(4,1)&3&8\\
(4,2)&3&8\\
(4,3)&1&8\\
(4,5)&1&7\\
(4,6)&3&8\\
(4,7)&2&9\\[2pt]
(5,0)&1&7\\
(5,1)&3&7\\
(5,2)&3&7\\
(5,3)&3&9\\
(5,4)&2&8\\
(5,6)&2&9\\
(5,7)&3&8\\[2pt]
(6,0)&2&8\\
(6,1)&2&7\\
(6,2)&3&7\\
(6,3)&2&7\\
(6,4)&1&9\\
(6,5)&1&8\\
(6,7)&3&7\\[2pt]
(7,0)&2&8\\
(7,1)&2&8\\
(7,2)&2&7\\
(7,3)&3&9\\
(7,4)&1&7\\
(7,5)&2&8\\
(7,6)&3&7
\end{array}
\]

and  

\[
\begin{array}{c|c}
i & d_i\\\hline
0 & -5\\
1 & 2\\
2 & 0\\
3 & 0\\
4 & -1\\
5 & 2\\
6 & 0\\
7 & 2
\end{array}
\qquad
\begin{array}{c|c}
i & U_i\\\hline
0 & 13\\
1 & 14\\
2 & 17\\
3 & 12\\
4 & 16\\
5 & 19\\
6 & 16\\
7 & 14
\end{array}
\]","import gurobipy as gp
from gurobipy import GRB

# Data
c = [[0]*8 for _ in range(8)]
C = [[0]*8 for _ in range(8)]

# Fill cost and capacity matrices
c[0][1], C[0][1] = 2, 8
c[0][2], C[0][2] = 2, 7
c[0][3], C[0][3] = 2, 7
c[0][4], C[0][4] = 2, 9
c[0][5], C[0][5] = 2, 8
c[0][6], C[0][6] = 1, 9
c[0][7], C[0][7] = 2, 7

c[1][0], C[1][0] = 1, 8
c[1][2], C[1][2] = 1, 8
c[1][3], C[1][3] = 3, 7
c[1][4], C[1][4] = 2, 8
c[1][5], C[1][5] = 1, 7
c[1][6], C[1][6] = 3, 9
c[1][7], C[1][7] = 1, 9

c[2][0], C[2][0] = 1, 8
c[2][1], C[2][1] = 2, 9
c[2][3], C[2][3] = 3, 7
c[2][4], C[2][4] = 2, 9
c[2][5], C[2][5] = 2, 8
c[2][6], C[2][6] = 3, 8
c[2][7], C[2][7] = 1, 8

c[3][0], C[3][0] = 3, 7
c[3][1], C[3][1] = 3, 7
c[3][2], C[3][2] = 3, 7
c[3][4], C[3][4] = 2, 7
c[3][5], C[3][5] = 3, 7
c[3][6], C[3][6] = 2, 9
c[3][7], C[3][7] = 3, 9

c[4][0], C[4][0] = 2, 9
c[4][1], C[4][1] = 3, 8
c[4][2], C[4][2] = 3, 8
c[4][3], C[4][3] = 1, 8
c[4][5], C[4][5] = 1, 7
c[4][6], C[4][6] = 3, 8
c[4][7], C[4][7] = 2, 9

c[5][0], C[5][0] = 1, 7
c[5][1], C[5][1] = 3, 7
c[5][2], C[5][2] = 3, 7
c[5][3], C[5][3] = 3, 9
c[5][4], C[5][4] = 2, 8
c[5][6], C[5][6] = 2, 9
c[5][7], C[5][7] = 3, 8

c[6][0], C[6][0] = 2, 8
c[6][1], C[6][1] = 2, 7
c[6][2], C[6][2] = 3, 7
c[6][3], C[6][3] = 2, 7
c[6][4], C[6][4] = 1, 9
c[6][5], C[6][5] = 1, 8
c[6][7], C[6][7] = 3, 7

c[7][0], C[7][0] = 2, 8
c[7][1], C[7][1] = 2, 8
c[7][2], C[7][2] = 2, 7
c[7][3], C[7][3] = 3, 9
c[7][4], C[7][4] = 1, 7
c[7][5], C[7][5] = 2, 8
c[7][6], C[7][6] = 3, 7

d = [-5, 2, 0, 0, -1, 2, 0, 2]
U = [13, 14, 17, 12, 16, 19, 16, 14]

# Create model
m = gp.Model(""MinCostFlow"")

# Decision variables
x = m.addVars([(i, j) for i in range(8) for j in range(8) if i != j],
              lb=0, vtype=GRB.CONTINUOUS, name=""x"")

# Objective
m.setObjective(gp.quicksum(c[i][j] * x[i, j] for i, j in x.keys()), GRB.MINIMIZE)

# Flow conservation constraints
for i in range(8):
    inflow = gp.quicksum(x[j, i] for j in range(8) if j != i)
    outflow = gp.quicksum(x[i, j] for j in range(8) if j != i)
    m.addConstr(inflow - outflow == d[i], name=f""balance_{i}"")

# Incoming capacity constraints
for i in range(8):
    inflow = gp.quicksum(x[j, i] for j in range(8) if j != i)
    m.addConstr(inflow <= U[i], name=f""max_inflow_{i}"")

# Edge capacity constraints
for i, j in x.keys():
    m.addConstr(x[i, j] <= C[i][j], name=f""cap_{i}_{j}"")

# Optimize
m.optimize()
",11,11,1,,,,,,,,
"The problem involves scheduling operations for five jobs (Job 0 through Job 4) in a manufacturing facility, where each job consists of two operations that must be performed in sequence. Each operation takes exactly 1 unit of time to complete. The facility has a limited number of machines, and multiple operations from different jobs may need to be assigned to the same machine. A machine can only handle one operation at a time, so the order of operations on shared machines must be determined to avoid overlaps. 

The goal is to minimize the total completion time, known as the makespan, which is the time at which the last operation across all jobs finishes. To achieve this, the start times of all operations must be scheduled such that: (1) for each job, the second operation starts only after the first operation is completed; (2) if two operations are assigned to the same machine, one must finish before the other starts; and (3) the makespan is at least as large as the completion time of every operation. 

The order of operations on shared machines is determined using binary decision variables, which indicate whether one operation is scheduled before another. A large constant (100000) is used in the constraints to enforce the sequencing of operations on shared machines. The start times of operations and the makespan are continuous variables, while the binary variables are restricted to values of 0 or 1. The objective is to minimize the makespan, ensuring all jobs are completed as quickly as possible.","\[
\begin{aligned}
\text{minimize}\quad & C \\[4pt]
\text{subject to}\quad
& s_{j,2}\;\ge\;s_{j,1}+1 && \forall j=0,\dots,4 \\[4pt]
& s_{j_2,o_2}\;\ge\;s_{j_1,o_1}+1-M\bigl(1-y_{(j_1,o_1),(j_2,o_2)}\bigr) && \forall (j_1,o_1)<(j_2,o_2) \\[4pt]
& s_{j_1,o_1}\;\ge\;s_{j_2,o_2}+1-M\,y_{(j_1,o_1),(j_2,o_2)} && \forall (j_1,o_1)<(j_2,o_2) \\[4pt]
& C\;\ge\;s_{j,o}+1 && \forall j=0,\dots,4,\; o=1,2 \\[4pt]
& s_{j,o}\in\mathbb{R},\; C\in\mathbb{R},\; y_{(j_1,o_1),(j_2,o_2)}\in\{0,1\}
\end{aligned}
\]  
where \(M=100000\).","import gurobipy as gp
from gurobipy import GRB

# Parameters
M = 100000
num_jobs = 5
orders = [1, 2]  # o = 1, 2

# Create model
m = gp.Model(""Scheduling"")

# Decision variables: s[j,o] real, C real
s = m.addVars(j=range(num_jobs), o=orders, vtype=GRB.CONTINUOUS, name=""s"")
C = m.addVar(vtype=GRB.CONTINUOUS, name=""C"")

# Binary variables y[(idx1, idx2)] for each pair of distinct (j,o) with idx1 < idx2
# Flatten (j,o) to a single index: idx = j*2 + (o-1)
y = {}
for j1 in range(num_jobs):
    for o1 in orders:
        idx1 = j1*2 + (o1-1)
        for j2 in range(num_jobs):
            for o2 in orders:
                idx2 = j2*2 + (o2-1)
                if idx1 < idx2:
                    y[(idx1, idx2)] = m.addVar(vtype=GRB.BINARY, name=f""y_{idx1}_{idx2}"")

# Constraints
# 1. s[j,2] >= s[j,1] + 1 for all j
for j in range(num_jobs):
    m.addConstr(s[j, 2] >= s[j, 1] + 1, name=f""order_{j}"")

# 2. Ordering constraints with big-M
for (idx1, idx2), yvar in y.items():
    # Recover (j1,o1) and (j2,o2) from indices
    j1, o1 = divmod(idx1, 2)
    j2, o2 = divmod(idx2, 2)
    o1 += 1
    o2 += 1
    # s[j2,o2] >= s[j1,o1] + 1 - M*(1 - y)
    m.addConstr(s[j2, o2] >= s[j1, o1] + 1 - M*(1 - yvar), name=f""bigM1_{idx1}_{idx2}"")
    # s[j1,o1] >= s[j2,o2] + 1 - M*y
    m.addConstr(s[j1, o1] >= s[j2, o2] + 1 - M*yvar, name=f""bigM2_{idx1}_{idx2}"")

# 3. C >= s[j,o] + 1 for all j,o
for j in range(num_jobs):
    for o in orders:
        m.addConstr(C >= s[j, o] + 1, name=f""C_ge_s_{j}_{o}"")

# Objective: minimize C
m.setObjective(C, GRB.MINIMIZE)

# Optimize
m.optimize()
",,4,0,,,,,,,,
"There are 2 restaurants, 7 employees, and 2 shifts per day. Each shift requires employees with specific skills, and each employee has a set of skills they are qualified to perform. Employees have preferences for certain skills, and assigning them to tasks they prefer incurs lower costs. The cost of leaving a position unfulfilled is significantly higher, so the goal is to minimize both the preference costs and the number of unfulfilled positions.

Restaurant 0, Shift 0, Skill 0 requires 1 employee. Restaurant 0, Shift 1, Skill 0 requires 1 employee. Restaurant 1, Shift 0, Skill 0 requires 2 employees. Restaurant 1, Shift 1, Skill 0 requires 1 employee.

Employees have varying availability for shifts. For example, Employee 0 is available for Shift 0 but not for Shift 1. Employee 1 is unavailable for Shift 1. Employee 3 is unavailable for Shift 0. Each employee is qualified for specific skills. For instance, Employee 0 is qualified for Skill 0, while Employee 3 is not qualified for Skill 0.

Assigning employees to tasks they prefer incurs lower costs. For example, assigning Employee 0 to Skill 0 costs 1 unit, and assigning Employee 1 to Skill 0 costs 2 units. Each unfulfilled position costs 100 units, which is significantly higher than preference costs.

The goal is to assign employees to specific shifts and restaurants based on their skills and availability while determining the number of unfulfilled positions for each shift and restaurant. The total cost to minimize includes the cost of assigning employees to tasks they prefer and the penalty cost for unfulfilled positions.

The total number of employees assigned to a shift at a restaurant, plus any unfulfilled positions, must equal the demand for that shift and skill. Employees can only be assigned to shifts they are available for and tasks they are qualified for. Each employee can be assigned to at most one shift across all restaurants and skills.

Preference costs for assignments range from 1 to 3 units. The cost of an unfulfilled position is 100 units. Specific demands and constraints are as outlined above.","\[
\begin{aligned}
\text{Sets:}\quad &E=\{0,1,2,3,4,5,6\},\; R=\{0,1\},\; S=\{0,1\} \\[4pt]
\text{Parameters:}\quad 
&d_{0,0}=1,\; d_{0,1}=1,\; d_{1,0}=2,\; d_{1,1}=1 \\[2pt]
& a_{0,0}=1,\; a_{0,1}=0,\; a_{1,0}=1,\; a_{1,1}=0,\; a_{3,0}=0,\; a_{3,1}=1 \\[2pt]
& q_{0}=1,\; q_{3}=0 \\[2pt]
& c_{0}=1,\; c_{1}=2 \\[4pt]
\text{Decision variables:}\quad 
& x_{e,r,s}\in\{0,1\}\;\;\forall e\in E,\; r\in R,\; s\in S \\[2pt]
& u_{r,s}\in\mathbb{Z}_{+}\;\;\forall r\in R,\; s\in S \\[4pt]
\text{Objective:}\quad 
& \min \;\sum_{e\in E}\sum_{r\in R}\sum_{s\in S} c_{e}\,x_{e,r,s}\;+\;100\sum_{r\in R}\sum_{s\in S} u_{r,s} \\[4pt]
\text{Constraints:}\quad 
& \sum_{e\in E} x_{e,r,s} + u_{r,s} = d_{r,s}\;\;\forall r\in R,\; s\in S \\[2pt]
& \sum_{r\in R}\sum_{s\in S} x_{e,r,s} \le 1\;\;\forall e\in E \\[2pt]
& x_{e,r,s} \le a_{e,s}\;\;\forall e\in E,\; r\in R,\; s\in S \\[2pt]
& x_{e,r,s} \le q_{e}\;\;\forall e\in E,\; r\in R,\; s\in S
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Sets
E = [0,1,2,3,4,5,6]
R = [0,1]
S = [0,1]

# Parameters with defaults
d = {(r,s):0 for r in R for s in S}
d[(0,0)] = 1
d[(0,1)] = 1
d[(1,0)] = 2
d[(1,1)] = 1

a = {(e,s):0 for e in E for s in S}
a[(0,0)] = 1
a[(0,1)] = 0
a[(1,0)] = 1
a[(1,1)] = 0
a[(3,0)] = 0
a[(3,1)] = 1

q = {e:1 for e in E}
q[3] = 0

c = {e:0 for e in E}
c[0] = 1
c[1] = 2

# Create model
m = gp.Model(""Optimization_Model"")

# Decision variables
x = m.addVars(E, R, S, vtype=GRB.BINARY, name=""x"")
u = m.addVars(R, S, vtype=GRB.INTEGER, lb=0, name=""u"")

# Objective
obj = gp.quicksum(c[e]*x[e,r,s] for e in E for r in R for s in S) + \
      100*gp.quicksum(u[r,s] for r in R for s in S)
m.setObjective(obj, GRB.MINIMIZE)

# Constraints
for r in R:
    for s in S:
        m.addConstr(gp.quicksum(x[e,r,s] for e in E) + u[r,s] == d[(r,s)], name=f""balance_{r}_{s}"")

for e in E:
    m.addConstr(gp.quicksum(x[e,r,s] for r in R for s in S) <= 1, name=f""one_assignment_{e}"")

for e in E:
    for r in R:
        for s in S:
            m.addConstr(x[e,r,s] <= a[(e,s)], name=f""a_constraint_{e}_{r}_{s}"")
            m.addConstr(x[e,r,s] <= q[e], name=f""q_constraint_{e}_{r}_{s}"")

# Optimize
m.optimize()",303,9,0,,,,,,,,
"Minimize the total operational costs, which include production setup costs, machine startup costs, inventory holding costs, and backlogging costs, while meeting customer demand and adhering to machine capacity constraints. The setup cost is 136.3292413778485 units per production run, and the startup cost is 72.14543590644504 units per machine startup. The inventory holding cost for Product 0 is 1.097996170356003 units per unit per period, and for Product 1, it is 0.9303010222262446 units per unit per period. The backlogging cost for Product 0 is 7.343834540408109 units per unit per period, and for Product 1, it is 6.589388559571906 units per unit per period.

The production system must meet the following demand constraints: for Product 0, the demand is 17.38664149749027 units in Period 0, 18.25024949764659 units in Period 1, and 20.01141977261751 units in Period 2. For Product 1, the demand is 17.8541958922009 units in Period 0, 16.38473840141418 units in Period 1, and 15.49890198357548 units in Period 2.

Machine 0 can handle up to 77.29936140903678 units of production in Period 0, adjusted for startup time, while Machine 1 can handle up to 74.94692092032173 units in the same period. Only one product can be produced on a machine in a given time period. If a machine was not producing in the previous period but is producing in the current period, a startup cost is incurred. Production quantities, inventory levels, and backlogs must be non-negative, and production and startup decisions are binary (0 or 1).

The objective is to determine the optimal production schedule, machine startups, inventory levels, and backlogs to minimize total costs while meeting all operational constraints.","\[
\begin{aligned}
\min\;&136.3292413778485\sum_{m=0}^{1}\sum_{p=0}^{1}\sum_{t=0}^{2} z_{mpt}
      +72.14543590644504\sum_{m=0}^{1}\sum_{t=0}^{2} s_{mt} \\
    &+1.097996170356003\sum_{t=0}^{2} I_{0t}
      +0.9303010222262446\sum_{t=0}^{2} I_{1t} \\
    &+7.343834540408109\sum_{t=0}^{2} B_{0t}
      +6.589388559571906\sum_{t=0}^{2} B_{1t} \\[4pt]
\text{s.t. }&z_{m0t}+z_{m1t}\le1 &&\forall m\in\{0,1\},\,t=0,1,2 \\[2pt]
&x_{mpt}\le c_m\,z_{mpt} &&\forall m\in\{0,1\},\,p\in\{0,1\},\,t=0,1,2 \\[2pt]
&c_0=77.29936140903678,\;c_1=74.94692092032173 \\[2pt]
&I_{p0}+B_{p0}= \sum_{m=0}^{1}x_{mp0}-d_{p0} &&\forall p\in\{0,1\} \\[2pt]
&I_{pt}+B_{pt}= I_{p,t-1}+ \sum_{m=0}^{1}x_{mp t}-d_{pt}+B_{p,t-1} &&\forall p\in\{0,1\},\,t=1,2 \\[2pt]
&s_{m0}= z_{m0,0}+z_{m1,0} &&\forall m\in\{0,1\} \\[2pt]
&s_{mt}\ge z_{m0t}-z_{m0,t-1},\; s_{mt}\ge z_{m1t}-z_{m1,t-1} &&\forall m\in\{0,1\},\,t=1,2 \\[2pt]
&s_{mt}\le z_{m0t}+z_{m1t} &&\forall m\in\{0,1\},\,t=0,1,2 \\[2pt]
&x_{mpt}\ge0,\;I_{pt}\ge0,\;B_{pt}\ge0 &&\forall m,p,t \\[2pt]
&z_{mpt}\in\{0,1\},\;s_{mt}\in\{0,1\} &&\forall m,p,t \\[2pt]
&x_{mpt}\in\mathbb{R}_+ &&\forall m,p,t
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Data
c = [77.29936140903678, 74.94692092032173]          # capacities
d = [[10, 12, 8],                                 # demand for product 0 over 3 periods
     [9, 11, 7]]                                   # demand for product 1 over 3 periods

# Create model
m = gp.Model(""Production_Scheduling"")

# Decision variables
z = m.addVars(2, 2, 3, vtype=GRB.BINARY, name=""z"")   # z[m,p,t]
s = m.addVars(2, 3, vtype=GRB.BINARY, name=""s"")     # s[m,t]
x = m.addVars(2, 2, 3, vtype=GRB.CONTINUOUS, name=""x"")  # x[m,p,t]
I = m.addVars(2, 3, vtype=GRB.CONTINUOUS, name=""I"")  # I[p,t]
B = m.addVars(2, 3, vtype=GRB.CONTINUOUS, name=""B"")  # B[p,t]

# Objective
obj = (
    136.3292413778485 * gp.quicksum(z[m,p,t] for m in range(2) for p in range(2) for t in range(3)) +
    72.14543590644504 * gp.quicksum(s[m,t] for m in range(2) for t in range(3)) +
    1.097996170356003 * gp.quicksum(I[0,t] for t in range(3)) +
    0.9303010222262446 * gp.quicksum(I[1,t] for t in range(3)) +
    7.343834540408109 * gp.quicksum(B[0,t] for t in range(3)) +
    6.589388559571906 * gp.quicksum(B[1,t] for t in range(3))
)
m.setObjective(obj, GRB.MINIMIZE)

# Constraints
# 1. z_{m0t} + z_{m1t} <= 1
for m in range(2):
    for t in range(3):
        m.addConstr(z[m,0,t] + z[m,1,t] <= 1, name=f""z_sum_{m}_{t}"")

# 2. x_{mpt} <= c_m * z_{mpt}
for m in range(2):
    for p in range(2):
        for t in range(3):
            m.addConstr(x[m,p,t] <= c[m] * z[m,p,t], name=f""x_cap_{m}_{p}_{t}"")

# 3. I_{p0} + B_{p0} = sum_m x_{mp0} - d_{p0}
for p in range(2):
    m.addConstr(I[p,0] + B[p,0] == gp.quicksum(x[m,p,0] for m in range(2)) - d[p][0],
                 name=f""inventory_balance_{p}_0"")

# 4. For t=1,2: I_{pt} + B_{pt} = I_{p,t-1} + sum_m x_{mp t} - d_{pt} + B_{p,t-1}
for p in range(2):
    for t in range(1,3):
        m.addConstr(
            I[p,t] + B[p,t] == I[p,t-1] + gp.quicksum(x[m,p,t] for m in range(2)) - d[p][t] + B[p,t-1],
            name=f""inventory_balance_{p}_{t}""
        )

# 5. s_{m0} = z_{m0,0} + z_{m1,0}
for m in range(2):
    m.addConstr(s[m,0] == z[m,0,0] + z[m,1,0], name=f""s_start_{m}"")

# 6. For t=1,2: s_{mt} >= z_{m0t} - z_{m0,t-1}, s_{mt} >= z_{m1t} - z_{m1,t-1}
for m in range(2):
    for t in range(1,3):
        m.addConstr(s[m,t] >= z[m,0,t] - z[m,0,t-1], name=f""s_change0_{m}_{t}"")
        m.addConstr(s[m,t] >= z[m,1,t] - z[m,1,t-1], name=f""s_change1_{m}_{t}"")

# 7. s_{mt} <= z_{m0t} + z_{m1t}
for m in range(2):
    for t in range(3):
        m.addConstr(s[m,t] <= z[m,0,t] + z[m,1,t], name=f""s_upper_{m}_{t}"")

# 8. Non-negativity of x, I, B is implicit from variable type

# Solve
m.optimize()
",,525.013011,0,,,,,,,,
"Minimize the total operational cost, which includes the base cost of operating generators, the cost of power output, and the startup cost of generators. The base cost for operating a Type 0 generator is 79 units per period, Type 1 is 80 units, and Type 2 is 78 units. The cost of power output is 4 units per MW for Type 0, 3 units per MW for Type 1, and 4 units per MW for Type 2. The startup cost is 349 units for Type 0, 354 units for Type 1, and 354 units for Type 2. The total power output from all generators must meet or exceed the demand in each period: 176 MW in Period 0, 160 MW in Period 1, 178 MW in Period 2, 210 MW in Period 3, and 171 MW in Period 4. Each generator type has minimum and maximum output limits: Type 0 generators must produce at least 34 MW and no more than 130 MW, Type 1 generators must produce at least 34 MW and no more than 130 MW, and Type 2 generators must produce at least 35 MW and no more than 128 MW. The total maximum possible output from all generators must be at least 202.4 MW in Period 0, 184 MW in Period 1, 204.7 MW in Period 2, 241.5 MW in Period 3, and 196.65 MW in Period 4. The number of generators that can be operated is limited by the available units: up to 2 Type 0 generators, up to 5 Type 1 generators, and up to 1 Type 2 generator in each period. The number of generators started in a period cannot exceed the number of generators that were not operating in the previous period. The solution must determine the optimal number of generators to operate, the power output from each generator, and the number of generators to start in each period to minimize the total operational cost while meeting the power demand and adhering to all operational constraints.","\[
\begin{aligned}
\min\;&\sum_{p=0}^{4}\sum_{t=0}^{2}\Bigl(79\,\mathbf{1}_{t=0}+80\,\mathbf{1}_{t=1}+78\,\mathbf{1}_{t=2}\Bigr)N_{t,p}
+\sum_{p=0}^{4}\sum_{t=0}^{2}\Bigl(4\,\mathbf{1}_{t=0}+3\,\mathbf{1}_{t=1}+4\,\mathbf{1}_{t=2}\Bigr)P_{t,p}\\
&+\sum_{p=0}^{4}\sum_{t=0}^{2}\Bigl(349\,\mathbf{1}_{t=0}+354\,\mathbf{1}_{t=1}+354\,\mathbf{1}_{t=2}\Bigr)S_{t,p}\\[4pt]
\text{s.t. }&\sum_{t=0}^{2}P_{t,p}\;\ge\;D_p\qquad(p=0,\dots,4)\\
&P_{t,p}\;\ge\;N_{t,p}\,P^{\min}_t\qquad(t=0,1,2;\;p=0,\dots,4)\\
&P_{t,p}\;\le\;N_{t,p}\,P^{\max}_t\qquad(t=0,1,2;\;p=0,\dots,4)\\
&N_{t,p}\;\le\;U_t\qquad(t=0,1,2;\;p=0,\dots,4)\\
&S_{t,p}\;\le\;N_{t,p}-N_{t,p-1}\qquad(t=0,1,2;\;p=1,\dots,4)\\
&S_{t,0}\;\le\;N_{t,0}\qquad(t=0,1,2)\\
&N_{t,p}\;\ge\;S_{t,p}\qquad(t=0,1,2;\;p=0,\dots,4)\\
&\sum_{t=0}^{2}N_{t,p}\,P^{\max}_t\;\ge\;M_p\qquad(p=0,\dots,4)\\
&N_{t,p},S_{t,p}\in\mathbb{Z}_+,\;P_{t,p}\in\mathbb{R}_+,
\end{aligned}
\]

where  

\[
\begin{aligned}
&P^{\min}_0=34,\;P^{\min}_1=34,\;P^{\min}_2=35,\\
&P^{\max}_0=130,\;P^{\max}_1=130,\;P^{\max}_2=128,\\
&U_0=2,\;U_1=5,\;U_2=1,\\
&D_0=176,\;D_1=160,\;D_2=178,\;D_3=210,\;D_4=171,\\
&M_0=202.4,\;M_1=184,\;M_2=204.7,\;M_3=241.5,\;M_4=196.65.
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Data
Pmin = [34, 34, 35]
Pmax = [130, 130, 128]
U = [2, 5, 1]
D = [176, 160, 178, 210, 171]
M = [202.4, 184, 204.7, 241.5, 196.65]

cost_N = [79, 80, 78]   # cost for N_t,p
cost_P = [4, 3, 4]      # cost for P_t,p
cost_S = [349, 354, 354]  # cost for S_t,p

t_range = range(3)
p_range = range(5)

# Create model
m = gp.Model(""Power_Unit_Commitment"")

# Decision variables
N = m.addVars(t_range, p_range, vtype=GRB.INTEGER, lb=0, name=""N"")
P = m.addVars(t_range, p_range, vtype=GRB.CONTINUOUS, lb=0, name=""P"")
S = m.addVars(t_range, p_range, vtype=GRB.INTEGER, lb=0, name=""S"")

# Objective
obj = gp.quicksum(cost_N[t]*N[t,p] + cost_P[t]*P[t,p] + cost_S[t]*S[t,p]
                  for t in t_range for p in p_range)
m.setObjective(obj, GRB.MINIMIZE)

# Constraints
# Demand constraints
for p in p_range:
    m.addConstr(gp.quicksum(P[t,p] for t in t_range) >= D[p], name=f""demand_{p}"")

# Power limits
for t in t_range:
    for p in p_range:
        m.addConstr(P[t,p] >= N[t,p]*Pmin[t], name=f""pmin_{t}_{p}"")
        m.addConstr(P[t,p] <= N[t,p]*Pmax[t], name=f""pmax_{t}_{p}"")

# Unit limits
for t in t_range:
    for p in p_range:
        m.addConstr(N[t,p] <= U[t], name=f""unit_limit_{t}_{p}"")

# Startup constraints
for t in t_range:
    for p in p_range:
        if p == 0:
            m.addConstr(S[t,p] <= N[t,p], name=f""startup_0_{t}"")
        else:
            m.addConstr(S[t,p] <= N[t,p] - N[t,p-1], name=f""startup_{p}_{t}"")

# Startup <= unit
for t in t_range:
    for p in p_range:
        m.addConstr(N[t,p] >= S[t,p], name=f""startup_le_unit_{t}_{p}"")

# Minimum generation requirement
for p in p_range:
    m.addConstr(gp.quicksum(N[t,p]*Pmax[t] for t in t_range) >= M[p], name=f""min_gen_{p}"")

# Optimize
m.optimize()",3485,4193,0,,,,,,,,
"You are tasked with planning the most efficient delivery route for a logistics company that serves seven cities: City 0, City 1, City 2, City 3, City 4, City 5, and City 6. The goal is to minimize the total transportation cost while ensuring that each city is visited exactly once and that the delivery route forms a complete tour without any subtours. The delivery vehicle must return to the starting city after visiting all others.

The cost of traveling between each pair of cities varies. From City 0: to City 1 costs 277, to City 2 costs 304, to City 3 costs 280, to City 4 costs 321, to City 5 costs 285, and to City 6 costs 300. From City 1: to City 0 costs 280, to City 2 costs 317, to City 3 costs 301, to City 4 costs 306, to City 5 costs 312, and to City 6 costs 290. From City 2: to City 0 costs 304, to City 1 costs 318, to City 3 costs 283, to City 4 costs 289, to City 5 costs 301, and to City 6 costs 277. From City 3: to City 0 costs 304, to City 1 costs 282, to City 2 costs 290, to City 4 costs 307, to City 5 costs 291, and to City 6 costs 290. From City 4: to City 0 costs 322, to City 1 costs 291, to City 2 costs 277, to City 3 costs 300, to City 5 costs 318, and to City 6 costs 280. From City 5: to City 0 costs 308, to City 1 costs 297, to City 2 costs 288, to City 3 costs 314, to City 4 costs 290, and to City 6 costs 320. From City 6: to City 0 costs 316, to City 1 costs 313, to City 2 costs 301, to City 3 costs 324, to City 4 costs 280, and to City 5 costs 303.

Each city must be visited exactly once. The delivery vehicle must arrive at each city from exactly one other city and depart to exactly one other city. The delivery route must form a single tour, meaning the vehicle cannot split into smaller loops or subtours. To enforce this, each city is assigned a position in the tour, with positions ranging from 1 to 7, ensuring a valid sequence. The positions must follow a logical sequence without gaps or repetitions. The route between any two cities is binary: it is either included (1) or excluded (0) in the final tour.

The objective is to minimize the total transportation cost for the delivery route while satisfying all constraints. The solution must account for all the costs and constraints outlined above.","\[
\begin{aligned}
\min\;&\sum_{i=0}^{6}\;\sum_{\substack{j=0\\ j\neq i}}^{6} c_{ij}\,x_{ij} \\[4pt]
\text{s.t.}\;&\sum_{\substack{j=0\\ j\neq i}}^{6} x_{ij}=1 &&\forall\,i=0,\dots,6 &&\text{(outgoing)}\\
&\sum_{\substack{i=0\\ i\neq j}}^{6} x_{ij}=1 &&\forall\,j=0,\dots,6 &&\text{(incoming)}\\
&u_{0}=1 &&\text{(fix start position)}\\
&u_{i}-u_{j}+7\,x_{ij}\le 6 &&\forall\,i\neq j,\; i,j=0,\dots,6 &&\text{(MTZ subtour elimination)}\\[4pt]
&x_{ij}\in\{0,1\} &&\forall\,i\neq j\\
&u_{i}\in\mathbb{Z},\;1\le u_{i}\le 7 &&\forall\,i=0,\dots,6
\end{aligned}
\]

where the cost coefficients \(c_{ij}\) are given by  

\[
\begin{array}{c|cccccc}
c_{ij}&1&2&3&4&5&6\\\hline
0&277&304&280&321&285&300\\
1&280&317&301&306&312&290\\
2&304&318&283&289&301&277\\
3&304&282&290&307&291&290\\
4&322&291&277&300&318&280\\
5&308&297&288&314&290&320\\
6&316&313&301&324&280&303
\end{array}
\]","import gurobipy as gp
from gurobipy import GRB

# Cost matrix (7x7) with zeros on the diagonal
c = [
    [0,   277, 304, 280, 321, 285, 300],
    [280, 0,   317, 301, 306, 312, 290],
    [304, 318, 0,   283, 289, 301, 277],
    [304, 282, 290, 0,   307, 291, 290],
    [322, 291, 277, 300, 0,   318, 280],
    [308, 297, 288, 314, 290, 0,   320],
    [316, 313, 301, 324, 280, 303, 0  ]
]

N = 7  # number of nodes

m = gp.Model(""TSP_MTZ"")

# Decision variables
x = m.addVars(N, N, vtype=GRB.BINARY, name=""x"")
u = m.addVars(N, vtype=GRB.INTEGER, lb=1, ub=N, name=""u"")

# Objective: minimize total cost
m.setObjective(gp.quicksum(c[i][j] * x[i, j] for i in range(N) for j in range(N) if i != j), GRB.MINIMIZE)

# Outgoing constraints: each node has exactly one outgoing edge
for i in range(N):
    m.addConstr(gp.quicksum(x[i, j] for j in range(N) if i != j) == 1, name=f""out_{i}"")

# Incoming constraints: each node has exactly one incoming edge
for j in range(N):
    m.addConstr(gp.quicksum(x[i, j] for i in range(N) if i != j) == 1, name=f""in_{j}"")

# Fix start position
m.addConstr(u[0] == 1, name=""start"")

# MTZ subtour elimination constraints
for i in range(N):
    for j in range(N):
        if i != j:
            m.addConstr(u[i] - u[j] + N * x[i, j] <= N - 1, name=f""mtz_{i}_{j}"")

# Optimize
m.optimize()
",,1987,0,,,,,,,,
"You are tasked with optimizing the placement of emergency response centers across a network of five critical locations (Node 0, Node 1, Node 2, Node 3, and Node 4) to maximize the overall coverage and effectiveness of the response system. Each location has unique characteristics, and the goal is to select exactly three locations to establish these centers. The effectiveness of the system is measured by the combined coverage scores between the selected centers, which are determined by predefined pairwise scores representing the strategic importance of connecting each pair of locations.

#### Key Decisions:
1. **Selecting Locations**: You must choose exactly three out of the five locations to establish emergency response centers. Each location is represented by a binary decision: if a center is established at a location, it is selected (1); otherwise, it is not (0).
2. **Pairwise Coverage**: For each pair of selected locations, the coverage score is determined by the predefined pairwise importance values. These scores reflect the strategic benefit of having both locations in the network.

#### Objective:
Maximize the total coverage score across all pairs of selected locations. The coverage scores for each pair are as follows:
- Node 0 and Node 1: 24  
- Node 0 and Node 2: 21  
- Node 0 and Node 3: 16  
- Node 0 and Node 4: 15  
- Node 1 and Node 0: 21  
- Node 1 and Node 2: 19  
- Node 1 and Node 3: 24  
- Node 1 and Node 4: 23  
- Node 2 and Node 0: 21  
- Node 2 and Node 1: 17  
- Node 2 and Node 3: 25  
- Node 2 and Node 4: 19  
- Node 3 and Node 0: 18  
- Node 3 and Node 1: 24  
- Node 3 and Node 2: 17  
- Node 3 and Node 4: 17  
- Node 4 and Node 0: 15  
- Node 4 and Node 1: 18  
- Node 4 and Node 2: 15  
- Node 4 and Node 3: 24  

#### Constraints:
1. **Selection of Centers**: Exactly three locations must be selected to establish emergency response centers. This means the sum of selected locations must equal three.
2. **Pairwise Coverage Activation**: For any pair of locations, the coverage score is only counted if both locations in the pair are selected. This ensures that the coverage score is only applied to active pairs.
3. **Logical Relationships**:
   - If a location is not selected, no coverage scores involving that location can be counted.
   - If both locations in a pair are selected, the coverage score for that pair is fully counted.
   - If only one location in a pair is selected, the coverage score for that pair is not counted.

#### Numerical Parameters:
- The pairwise coverage scores are explicitly provided for all possible pairs of locations, as listed above.
- The total number of selected locations must be exactly three.

#### Summary:
Your task is to select three out of the five locations to establish emergency response centers such that the total coverage score, based on the predefined pairwise importance values, is maximized. The selection must adhere to the constraints ensuring that only active pairs of selected locations contribute to the coverage score.","\[
\begin{aligned}
\max \quad & 24z_{01}+21z_{02}+16z_{03}+15z_{04} \\
& +21z_{10}+19z_{12}+24z_{13}+23z_{14} \\
& +21z_{20}+17z_{21}+25z_{23}+19z_{24} \\
& +18z_{30}+24z_{31}+17z_{32}+17z_{34} \\
& +15z_{40}+18z_{41}+15z_{42}+24z_{43} \\[4pt]
\text{s.t.}\quad & y_0+y_1+y_2+y_3+y_4 = 3, \\[4pt]
& z_{ij}\le y_i \quad \forall\, i\neq j, \\[2pt]
& z_{ij}\le y_j \quad \forall\, i\neq j, \\[2pt]
& z_{ij}\ge y_i+y_j-1 \quad \forall\, i\neq j, \\[4pt]
& y_i\in\{0,1\}\quad i=0,\dots,4, \\[2pt]
& z_{ij}\in\{0,1\}\quad i\neq j.
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""PairSelection"")

# Decision variables y_i
y = m.addVars(5, vtype=GRB.BINARY, name=""y"")

# Decision variables z_ij for i != j
z = {}
for i in range(5):
    for j in range(5):
        if i != j:
            z[i, j] = m.addVar(vtype=GRB.BINARY, name=f""z_{i}{j}"")

# Objective coefficients
coeff = {
    (0, 1): 24, (0, 2): 21, (0, 3): 16, (0, 4): 15,
    (1, 0): 21, (1, 2): 19, (1, 3): 24, (1, 4): 23,
    (2, 0): 21, (2, 1): 17, (2, 3): 25, (2, 4): 19,
    (3, 0): 18, (3, 1): 24, (3, 2): 17, (3, 4): 17,
    (4, 0): 15, (4, 1): 18, (4, 2): 15, (4, 3): 24
}

# Set objective
m.setObjective(gp.quicksum(coeff[i, j] * z[i, j] for (i, j) in coeff), GRB.MAXIMIZE)

# Constraint: sum of y_i equals 3
m.addConstr(gp.quicksum(y[i] for i in range(5)) == 3, ""sum_y"")

# Constraints linking z and y
for i in range(5):
    for j in range(5):
        if i != j:
            m.addConstr(z[i, j] <= y[i], name=f""z_le_yi_{i}_{j}"")
            m.addConstr(z[i, j] <= y[j], name=f""z_le_yj_{i}_{j}"")
            m.addConstr(z[i, j] >= y[i] + y[j] - 1, name=f""z_ge_yi_yj_{i}_{j}"")

# Optimize
m.optimize()

# Output results
if m.status == GRB.OPTIMAL:
    print(""Optimal objective:"", m.objVal)
    print(""Selected y:"", [y[i].X for i in range(5)])
    selected_pairs = [(i, j) for (i, j) in coeff if z[i, j].X > 0.5]
    print(""Selected pairs:"", selected_pairs)",130,130,1,,,,,,,,
"The problem involves scheduling operations for 7 products, each requiring 2 operations to be performed in sequence. Each operation has a fixed processing time of 1 unit of time. The operations must be scheduled on shared machines, where each machine can handle only one operation at a time. The order of operations on shared machines is determined by binary decision variables, which decide whether one operation is performed before another. 

The goal is to minimize the total production time, known as the makespan, ensuring that all products are completed as quickly as possible. The makespan must be at least as long as the completion time of the last operation across all products. 

Constraints include precedence constraints, ensuring that the second operation of each product cannot start until the first operation is completed. Machine capacity constraints ensure that no two operations on the same machine overlap in time. These constraints are enforced using binary variables that determine the order of operations on shared machines. A large constant (100000) is used in the machine capacity constraints to ensure that the constraints are satisfied when the binary variables determine the order of operations. 

The start times of all operations must be non-negative, and the binary variables must take values of either 0 or 1. The objective is to minimize the makespan, ensuring that all operations are scheduled efficiently without violating the precedence and machine capacity constraints.","\[
\begin{aligned}
\min \quad & C \\[4pt]
\text{s.t.}\quad
& s_{i2} \;\ge\; s_{i1} + 1 && \forall\, i=1,\dots,7 \\[2pt]
& C \;\ge\; s_{i1} + 1 && \forall\, i=1,\dots,7 \\[2pt]
& C \;\ge\; s_{i2} + 1 && \forall\, i=1,\dots,7 \\[4pt]
& s_{p} + 1 \;\le\; s_{q} + M\,(1 - y_{pq}) && \forall\, p<q,\; p,q=1,\dots,14 \\[2pt]
& s_{q} + 1 \;\le\; s_{p} + M\,y_{pq} && \forall\, p<q,\; p,q=1,\dots,14 \\[4pt]
& s_{i1},\,s_{i2} \;\ge\; 0 && \forall\, i=1,\dots,7 \\[2pt]
& y_{pq} \;\in\; \{0,1\} && \forall\, p<q,\; p,q=1,\dots,14 \\[2pt]
& C \;\ge\; 0
\end{aligned}
\]

\[
\begin{aligned}
& s_{i1},\,s_{i2} \in \mathbb{R}_{+}\quad (i=1,\dots,7)\\
& y_{pq} \in \{0,1\}\quad (p<q,\; p,q=1,\dots,14)\\
& C \in \mathbb{R}_{+}\\
& M = 100000
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Scheduling"")

# Parameters
M = 100000

# Decision variables
s1 = m.addVars(7, lb=0, vtype=GRB.CONTINUOUS, name=""s1"")
s2 = m.addVars(7, lb=0, vtype=GRB.CONTINUOUS, name=""s2"")
C  = m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""C"")

# Binary ordering variables for all pairs of 14 s variables
y = {(p, q): m.addVar(vtype=GRB.BINARY, name=f""y_{p}_{q}"") 
     for p in range(14) for q in range(p+1, 14)}

# Combine all s variables into a single list for ordering constraints
s_all = [s1[i] for i in range(7)] + [s2[i] for i in range(7)]

# Constraints
for i in range(7):
    m.addConstr(s2[i] >= s1[i] + 1, name=f""order_{i}"")
    m.addConstr(C >= s1[i] + 1, name=f""C_ge_s1_{i}"")
    m.addConstr(C >= s2[i] + 1, name=f""C_ge_s2_{i}"")

for p in range(14):
    for q in range(p+1, 14):
        m.addConstr(s_all[p] + 1 <= s_all[q] + M * (1 - y[(p, q)]),
                    name=f""seq1_{p}_{q}"")
        m.addConstr(s_all[q] + 1 <= s_all[p] + M * y[(p, q)],
                    name=f""seq2_{p}_{q}"")

# Objective
m.setObjective(C, GRB.MINIMIZE)

# Optimize
m.optimize()",2,4,0,,,,,,,,
"You are responsible for managing the distribution of resources across nine interconnected cities. Each city has a specific supply or demand for resources, and your goal is to ensure that all cities receive the resources they need while minimizing the total transportation cost. The transportation costs vary depending on the route taken between cities, and each route has a maximum capacity limit that cannot be exceeded.

#### City Requirements:
- **City 0** has a surplus of 42 units of resources that need to be distributed to other cities.
- **City 1** requires an additional 3 units of resources to meet its demand.
- **City 2** has a surplus of 11 units of resources.
- **City 3** requires an additional 21 units of resources.
- **City 4** has a surplus of 4 units of resources.
- **City 5** has a surplus of 3 units of resources.
- **City 6** requires an additional 19 units of resources.
- **City 7** requires an additional 24 units of resources.
- **City 8** has a surplus of 7 units of resources.

#### Transportation Costs:
The cost of transporting resources between cities varies. Below are the costs for each possible route:
- From **City 0** to other cities:  
  - To **City 1**: 8 units  
  - To **City 2**: 9 units  
  - To **City 3**: 8 units  
  - To **City 4**: 9 units  
  - To **City 5**: 8 units  
  - To **City 6**: 10 units  
  - To **City 7**: 7 units  
  - To **City 8**: 10 units  

- From **City 1** to other cities:  
  - To **City 0**: 6 units  
  - To **City 2**: 7 units  
  - To **City 3**: 6 units  
  - To **City 4**: 6 units  
  - To **City 5**: 6 units  
  - To **City 6**: 9 units  
  - To **City 7**: 10 units  
  - To **City 8**: 8 units  

- From **City 2** to other cities:  
  - To **City 0**: 9 units  
  - To **City 1**: 9 units  
  - To **City 3**: 8 units  
  - To **City 4**: 6 units  
  - To **City 5**: 8 units  
  - To **City 6**: 10 units  
  - To **City 7**: 7 units  
  - To **City 8**: 10 units  

- From **City 3** to other cities:  
  - To **City 0**: 8 units  
  - To **City 1**: 6 units  
  - To **City 2**: 10 units  
  - To **City 4**: 9 units  
  - To **City 5**: 10 units  
  - To **City 6**: 8 units  
  - To **City 7**: 10 units  
  - To **City 8**: 9 units  

- From **City 4** to other cities:  
  - To **City 0**: 6 units  
  - To **City 1**: 8 units  
  - To **City 2**: 9 units  
  - To **City 3**: 8 units  
  - To **City 5**: 10 units  
  - To **City 6**: 9 units  
  - To **City 7**: 7 units  
  - To **City 8**: 9 units  

- From **City 5** to other cities:  
  - To **City 0**: 10 units  
  - To **City 1**: 6 units  
  - To **City 2**: 7 units  
  - To **City 3**: 9 units  
  - To **City 4**: 8 units  
  - To **City 6**: 10 units  
  - To **City 7**: 7 units  
  - To **City 8**: 10 units  

- From **City 6** to other cities:  
  - To **City 0**: 10 units  
  - To **City 1**: 10 units  
  - To **City 2**: 10 units  
  - To **City 3**: 6 units  
  - To **City 4**: 9 units  
  - To **City 5**: 9 units  
  - To **City 7**: 7 units  
  - To **City 8**: 8 units  

- From **City 7** to other cities:  
  - To **City 0**: 6 units  
  - To **City 1**: 10 units  
  - To **City 2**: 9 units  
  - To **City 3**: 8 units  
  - To **City 4**: 8 units  
  - To **City 5**: 9 units  
  - To **City 6**: 8 units  
  - To **City 8**: 7 units  

- From **City 8** to other cities:  
  - To **City 0**: 10 units  
  - To **City 1**: 6 units  
  - To **City 2**: 8 units  
  - To **City 3**: 10 units  
  - To **City 4**: 7 units  
  - To **City 5**: 6 units  
  - To **City 6**: 9 units  
  - To **City 7**: 10 units  

#### Capacity Constraints:
Each route between cities has a maximum capacity limit, which cannot be exceeded:
- **City 0** to **City 1**: 40 units  
- **City 0** to **City 2**: 56 units  
- **City 0** to **City 3**: 41 units  
- **City 0** to **City 4**: 49 units  
- **City 0** to **City 5**: 50 units  
- **City 0** to **City 6**: 36 units  
- **City 0** to **City 7**: 59 units  
- **City 0** to **City 8**: 55 units  

- **City 1** to **City 0**: 33 units  
- **City 1** to **City 2**: 33 units  
- **City 1** to **City 3**: 56 units  
- **City 1** to **City 4**: 46 units  
- **City 1** to **City 5**: 38 units  
- **City 1** to **City 6**: 53 units  
- **City 1** to **City 7**: 51 units  
- **City 1** to **City 8**: 59 units  

- **City 2** to **City 0**: 59 units  
- **City 2** to **City 1**: 52 units  
- **City 2** to **City 3**: 41 units  
- **City 2** to **City 4**: 38 units  
- **City 2** to **City 5**: 36 units  
- **City 2** to **City 6**: 45 units  
- **City 2** to **City 7**: 32 units  
- **City 2** to **City 8**: 41 units  

- **City 3** to **City 0**: 30 units  
- **City 3** to **City 1**: 32 units  
- **City 3** to **City 2**: 47 units  
- **City 3** to **City 4**: 57 units  
- **City 3** to **City 5**: 39 units  
- **City 3** to **City 6**: 34 units  
- **City 3** to **City 7**: 32 units  
- **City 3** to **City 8**: 46 units  

- **City 4** to **City 0**: 55 units  
- **City 4** to **City 1**: 40 units  
- **City 4** to **City 2**: 55 units  
- **City 4** to **City 3**: 41 units  
- **City 4** to **City 5**: 59 units  
- **City 4** to **City 6**: 51 units  
- **City 4** to **City 7**: 35 units  
- **City 4** to **City 8**: 53 units  

- **City 5** to **City 0**: 34 units  
- **City 5** to **City 1**: 41 units  
- **City 5** to **City 2**: 35 units  
- **City 5** to **City 3**: 43 units  
- **City 5** to **City 4**: 41 units  
- **City 5** to **City 6**: 43 units  
- **City 5** to **City 7**: 40 units  
- **City 5** to **City 8**: 41 units  

- **City 6** to **City 0**: 34 units  
- **City 6** to **City 1**: 32 units  
- **City 6** to **City 2**: 47 units  
- **City 6** to **City 3**: 43 units  
- **City 6** to **City 4**: 46 units  
- **City 6** to **City 5**: 34 units  
- **City 6** to **City 7**: 60 units  
- **City 6** to **City 8**: 59 units  

- **City 7** to **City 0**: 31 units  
- **City 7** to **City 1**: 42 units  
- **City 7** to **City 2**: 30 units  
- **City 7** to **City 3**: 34 units  
- **City 7** to **City 4**: 52 units  
- **City 7** to **City 5**: 45 units  
- **City 7** to **City 6**: 43 units  
- **City 7** to **City 8**: 50 units  

- **City 8** to **City 0**: 49 units  
- **City 8** to **City 1**: 31 units  
- **City 8** to **City 2**: 53 units  
- **City 8** to **City 3**: 46 units  
- **City 8** to **City 4**: 42 units  
- **City 8** to **City 5**: 36 units  
- **City 8** to **City 6**: 30 units  
- **City 8** to **City 7**: 41 units  

#### Objective:
Your task is to determine the optimal amount of resources to transport between cities to meet all demands while minimizing the total transportation cost. Ensure that the transportation does not exceed the capacity limits of any route and that all cities' resource requirements are satisfied.

What is the minimum total cost to achieve this distribution?","\[
\begin{aligned}
\text{minimize}\quad & \sum_{i=0}^{8}\;\sum_{\substack{j=0\\ j\neq i}}^{8} c_{i,j}\,x_{i,j} \\[4pt]
\text{subject to}\quad & \sum_{\substack{j=0\\ j\neq i}}^{8} x_{i,j}\;-\;\sum_{\substack{k=0\\ k\neq i}}^{8} x_{k,i}\;=\;s_i
\quad\forall\,i\in\{0,\dots,8\} \\[4pt]
& x_{i,j}\;\le\;\text{cap}_{i,j}\quad\forall\,i,j\in\{0,\dots,8\},\;i\neq j \\[4pt]
& x_{i,j}\;\in\;\mathbb{R}_+\quad\forall\,i,j\in\{0,\dots,8\},\;i\neq j
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB
import numpy as np

# Data
c = np.array([
    [0, 12, 7, 9, 3, 8, 5, 6, 4],
    [12, 0, 10, 2, 11, 4, 9, 7, 3],
    [7, 10, 0, 8, 5, 6, 12, 4, 9],
    [9, 2, 8, 0, 7, 5, 3, 11, 6],
    [3, 11, 5, 7, 0, 10, 4, 8, 2],
    [8, 4, 6, 5, 10, 0, 11, 3, 7],
    [5, 9, 12, 3, 4, 11, 0, 10, 8],
    [6, 7, 4, 11, 8, 3, 10, 0, 9],
    [4, 3, 9, 6, 2, 7, 8, 9, 0]
])
cap = np.full((9, 9), 20)
np.fill_diagonal(cap, 0)
s = np.array([5, -3, 2, -4, 1, 0, -2, 3, -2])

# Create model
m = gp.Model(""Flow_Optimization"")

# Decision variables x[i,j] for i != j
x = {}
for i in range(9):
    for j in range(9):
        if i != j:
            x[i, j] = m.addVar(vtype=GRB.CONTINUOUS, lb=0, ub=cap[i, j], name=f""x_{i}_{j}"")

m.update()

# Objective: minimize total cost
m.setObjective(gp.quicksum(c[i, j] * x[i, j] for i in range(9) for j in range(9) if i != j), GRB.MINIMIZE)

# Flow conservation constraints
for i in range(9):
    inflow = gp.quicksum(x[k, i] for k in range(9) if k != i)
    outflow = gp.quicksum(x[i, j] for j in range(9) if j != i)
    m.addConstr(outflow - inflow == s[i], name=f""balance_{i}"")

# Optimize
m.optimize()

# Print solution
for i in range(9):
    for j in range(9):
        if i != j:
            val = x[i, j].X
            if val > 1e-6:
                print(f""x_{i}_{j} = {val}"")",69,533,0,,,,,,,,
"The manufacturing facility produces seven distinct products (Jobs 0 through 6) using four specialized machines (Machine 0, Machine 1, Machine 2, and Machine 3). Each product must pass through all four machines in a specific sequence, and the goal is to schedule production to minimize the total completion time (makespan), ensuring all products are completed as quickly as possible. The objective is to minimize the sum of the start time of the last product on Machine 3 and the weighted completion times of specific jobs in the final position. Each product must be assigned to exactly one position in the production sequence on each machine, and each position on each machine can only be assigned to one product. The start time of a product on a machine cannot begin until the product has completed processing on the previous machine, and the start time of a product in a later position on a machine cannot begin until the product in the previous position has completed processing on that machine. Processing times for each product on each machine are as follows: Job 0 takes 10 units on Machine 0, 5 units on Machine 1, 5 units on Machine 2, and 7 units on Machine 3; Job 1 takes 6 units on Machine 0, 5 units on Machine 1, 10 units on Machine 2, and 9 units on Machine 3; Job 2 takes 9 units on Machine 0, 8 units on Machine 1, 6 units on Machine 2, and 9 units on Machine 3; Job 3 takes 6 units on Machine 0, 5 units on Machine 1, 9 units on Machine 2, and 6 units on Machine 3; Job 4 takes 5 units on Machine 0, 8 units on Machine 1, 5 units on Machine 2, and 5 units on Machine 3; Job 5 takes 9 units on Machine 0, 10 units on Machine 1, 5 units on Machine 2, and 10 units on Machine 3; Job 6 takes 7 units on Machine 0, 6 units on Machine 1, 10 units on Machine 2, and 5 units on Machine 3. The objective function includes weighted coefficients for specific jobs in the final position, such as 7 for Job 0 in position 6, 9 for Job 1 in position 6, 9 for Job 2 in position 6, 6 for Job 3 in position 6, 5 for Job 4 in position 6, 10 for Job 5 in position 6, and 5 for Job 6 in position 6. The constraints ensure that each job is assigned to exactly one position on each machine, each position on each machine is assigned to exactly one job, and the start times respect the precedence relationships between machines and positions. The variables include binary assignment variables for each job and position on each machine, and continuous start time variables for each position on each machine. The bounds ensure that all start times are non-negative, and the binary variables are restricted to 0 or 1.","\[
\begin{aligned}
\text{minimize}\quad & s_{3,6} \;+\; \sum_{j=0}^{6} w_j\,\bigl(s_{3,6}+p_{j,3}\bigr)\,x_{j,6} \\[4pt]
\text{subject to}\quad & \sum_{p=0}^{6} x_{j,p}=1 && \forall j=0,\dots,6 \\[2pt]
& \sum_{j=0}^{6} x_{j,p}=1 && \forall p=0,\dots,6 \\[2pt]
& s_{m,p}\;\ge\; s_{m-1,p}\;+\;\sum_{j=0}^{6} p_{j,m-1}\,x_{j,p} && \forall m=1,2,3,\; p=0,\dots,6 \\[2pt]
& s_{m,p}\;\ge\; s_{m,p-1}\;+\;\sum_{j=0}^{6} p_{j,m}\,x_{j,p-1} && \forall m=0,1,2,3,\; p=1,\dots,6 \\[2pt]
& s_{m,p}\;\ge\;0 && \forall m=0,1,2,3,\; p=0,\dots,6 \\[2pt]
& x_{j,p}\in\{0,1\} && \forall j=0,\dots,6,\; p=0,\dots,6 \\[2pt]
& s_{m,p}\in\mathbb{R}_+ && \forall m=0,1,2,3,\; p=0,\dots,6
\end{aligned}
\] where $p_{j,m}$ are the given processing times and $w_0=7,\;w_1=9,\;w_2=9,\;w_3=6,\;w_4=5,\;w_5=10,\;w_6=5$.","import gurobipy as gp
from gurobipy import GRB

# Data
w = [7, 9, 9, 6, 5, 10, 5]  # weights for jobs 0..6
# processing times p[j][m] for job j on machine m (m=0..3)
p = [
    [2, 3, 1, 4],
    [3, 2, 4, 1],
    [4, 1, 3, 2],
    [1, 4, 2, 3],
    [2, 3, 4, 1],
    [3, 1, 2, 4],
    [4, 2, 1, 3]
]

# Create model
m = gp.Model(""Scheduling_Problem"")

# Decision variables
x = m.addVars(7, 7, vtype=GRB.BINARY, name=""x"")          # x[j,p]
s = m.addVars(4, 7, vtype=GRB.CONTINUOUS, lb=0, name=""s"")  # s[m,p]

# Assignment constraints: each job assigned to exactly one position
for j in range(7):
    m.addConstr(gp.quicksum(x[j, p_] for p_ in range(7)) == 1, name=f""job_assign_{j}"")

# Each position assigned exactly one job
for p_ in range(7):
    m.addConstr(gp.quicksum(x[j, p_] for j in range(7)) == 1, name=f""pos_assign_{p_}"")

# Constraints on s[m,p]
# 1. s_{m,p} >= s_{m-1,p} + sum_j p_{j,m-1} * x_{j,p}  for m=1,2,3 and p=0..6
for m_ in range(1, 4):
    for p_ in range(7):
        m.addConstr(
            s[m_, p_] >= s[m_ - 1, p_] + gp.quicksum(p[j][m_ - 1] * x[j, p_] for j in range(7)),
            name=f""s_inc_m{m_}_p{p_}""
        )

# 2. s_{m,p} >= s_{m,p-1} + sum_j p_{j,m} * x_{j,p-1}  for m=0..3 and p=1..6
for m_ in range(4):
    for p_ in range(1, 7):
        m.addConstr(
            s[m_, p_] >= s[m_, p_ - 1] + gp.quicksum(p[j][m_] * x[j, p_ - 1] for j in range(7)),
            name=f""s_inc_m{m_}_p{p_}""
        )

# Objective: minimize s_{3,6} + sum_j w_j * (s_{3,6} + p_{j,3}) * x_{j,6}
obj = s[3, 6] + gp.quicksum(w[j] * (s[3, 6] + p[j][3]) * x[j, 6] for j in range(7))
m.setObjective(obj, GRB.MINIMIZE)

# Optimize
m.optimize()
",147,72,0,,,,,,,,
"The goal is to minimize the total travel distance for a delivery route across six cities: City 0, City 1, City 2, City 3, City 4, and City 5. Each city must be visited exactly once, and the route must form a complete loop without any smaller loops (subtours). The distances between cities are as follows: from City 0 to City 1 (318 units), City 2 (278 units), City 3 (304 units), City 4 (287 units), and City 5 (277 units); from City 1 to City 0 (285 units), City 2 (277 units), City 3 (322 units), City 4 (277 units), and City 5 (306 units); from City 2 to City 0 (275 units), City 1 (302 units), City 3 (299 units), City 4 (277 units), and City 5 (291 units); from City 3 to City 0 (282 units), City 1 (292 units), City 2 (276 units), City 4 (283 units), and City 5 (304 units); from City 4 to City 0 (277 units), City 1 (301 units), City 2 (291 units), City 3 (306 units), and City 5 (325 units); from City 5 to City 0 (325 units), City 1 (319 units), City 2 (306 units), City 3 (279 units), and City 4 (275 units). 

Each city must have exactly one incoming and one outgoing route. To prevent subtours, each city is assigned a position number: City 0 is fixed at position 0, and the position numbers for the other cities must be between 1 and 5. If a route is taken from City i to City j, the position number of City j must be greater than the position number of City i. The decision to travel from one city to another is represented by binary variables, where 1 indicates the route is taken and 0 indicates it is not. The objective is to determine the optimal sequence of cities to visit, ensuring each city is visited exactly once, the route forms a complete loop without subtours, and the total distance traveled is minimized.","\[
\begin{aligned}
\min\;&\sum_{i=0}^{5}\sum_{\substack{j=0\\ j\neq i}}^{5} d_{ij}\,x_{ij} \\[4pt]
\text{s.t. }&\sum_{\substack{j=0\\ j\neq i}}^{5} x_{ij}=1 &&\forall\,i=0,\dots,5 &&\text{(outgoing)}\\
&\sum_{\substack{i=0\\ i\neq j}}^{5} x_{ij}=1 &&\forall\,j=0,\dots,5 &&\text{(incoming)}\\
&u_i-u_j+5\,x_{ij}\le 4 &&\forall\,i,j\in\{1,\dots,5\},\,i\neq j &&\text{(MTZ)}\\
&u_0=0 &&\\
&u_i\in\{1,2,3,4,5\} &&\forall\,i=1,\dots,5 &&\text{(position)}\\
&x_{ij}\in\{0,1\} &&\forall\,i\neq j &&\text{(binary)}\\
\end{aligned}
\]

where the distances \(d_{ij}\) are given by  

\[
\begin{array}{c|cccccc}
 &0&1&2&3&4&5\\\hline
0&-&318&278&304&287&277\\
1&285&-&277&322&277&306\\
2&275&302&-&299&277&291\\
3&282&292&276&-&283&304\\
4&277&301&291&306&-&325\\
5&325&319&306&279&275&-\\
\end{array}
\]","import gurobipy as gp
from gurobipy import GRB

# Distance matrix
d = [
    [0, 318, 278, 304, 287, 277],
    [285, 0, 277, 322, 277, 306],
    [275, 302, 0, 299, 277, 291],
    [282, 292, 276, 0, 283, 304],
    [277, 301, 291, 306, 0, 325],
    [325, 319, 306, 279, 275, 0]
]

m = gp.Model(""TSP_MTZ"")

# Decision variables x[i,j] binary for i!=j
x = m.addVars(6, 6, vtype=GRB.BINARY, name=""x"")
# Position variables u[i] integer
u = m.addVars(6, vtype=GRB.INTEGER, name=""u"")

# Objective: minimize total distance
m.setObjective(gp.quicksum(d[i][j] * x[i, j] for i in range(6) for j in range(6) if i != j), GRB.MINIMIZE)

# Outgoing constraints: each node has exactly one outgoing edge
for i in range(6):
    m.addConstr(gp.quicksum(x[i, j] for j in range(6) if i != j) == 1, name=f""out_{i}"")

# Incoming constraints: each node has exactly one incoming edge
for j in range(6):
    m.addConstr(gp.quicksum(x[i, j] for i in range(6) if i != j) == 1, name=f""in_{j}"")

# MTZ constraints for nodes 1..5 (index 1..5)
for i in range(1, 6):
    for j in range(1, 6):
        if i != j:
            m.addConstr(u[i] - u[j] + 5 * x[i, j] <= 4, name=f""mtz_{i}_{j}"")

# Fix u[0] = 0
m.addConstr(u[0] == 0, name=""u0"")

# Bounds for u[1..5]
for i in range(1, 6):
    m.addConstr(u[i] >= 1, name=f""u_low_{i}"")
    m.addConstr(u[i] <= 5, name=f""u_up_{i}"")

m.optimize()",1679,1679,1,,,,,,,,
"Cell Tower Deployment for Regional Coverage

You are tasked with optimizing the deployment of cell towers across a region to maximize population coverage while adhering to a strict budget constraint. The region is divided into 33 distinct areas, each with a specific population size that needs to be served. Your goal is to determine which cell towers to build and which areas to cover to ensure the maximum number of people have access to cellular service.

#### Key Decisions:
1. **Which cell towers to build**: There are 29 potential cell tower locations, each with a unique construction cost. You must decide whether to build each tower (a binary decision: build or not build).
2. **Which areas to cover**: Each of the 33 areas can be either covered or not covered by the deployed cell towers. Coverage for an area is only possible if at least one of the cell towers that can serve it is built.

#### Objective:
Maximize the total population covered by the deployed cell towers. The population sizes for the 33 areas are as follows:
- Area 0: 3,522 people  
- Area 1: 2,492 people  
- Area 2: 2,865 people  
- Area 3: 2,596 people  
- Area 4: 2,194 people  
- Area 5: 4,001 people  
- Area 6: 3,027 people  
- Area 7: 2,581 people  
- Area 8: 4,848 people  
- Area 9: 2,814 people  
- Area 10: 3,543 people  
- Area 11: 2,234 people  
- Area 12: 2,960 people  
- Area 13: 4,297 people  
- Area 14: 2,792 people  
- Area 15: 4,520 people  
- Area 16: 2,685 people  
- Area 17: 2,022 people  
- Area 18: 4,858 people  
- Area 19: 4,814 people  
- Area 20: 3,432 people  
- Area 21: 3,730 people  
- Area 22: 2,526 people  
- Area 23: 3,277 people  
- Area 24: 4,363 people  
- Area 25: 2,622 people  
- Area 26: 3,740 people  
- Area 27: 4,594 people  
- Area 28: 3,193 people  
- Area 29: 4,275 people  
- Area 30: 4,407 people  
- Area 31: 3,809 people  
- Area 32: 2,163 people  

#### Constraints:
1. **Coverage Requirements**: For an area to be considered covered, at least one of the cell towers that can serve it must be built. The specific combinations of cell towers that can cover each area are provided in the data. For example:
   - Area 0 can be covered if any of the following towers are built: Tower 3, Tower 5, Tower 7, Tower 10, Tower 11, Tower 13, Tower 15, Tower 17, Tower 19, Tower 22, Tower 23, Tower 26, Tower 27, or Tower 28.
   - Similar constraints apply to all 33 areas, with each area having a unique set of towers that can provide coverage.

2. **Budget Constraint**: The total cost of building the selected cell towers must not exceed the available budget of 3,059 units. The construction costs for the 29 towers are as follows:
   - Tower 0: 303 units  
   - Tower 1: 378 units  
   - Tower 2: 327 units  
   - Tower 3: 444 units  
   - Tower 4: 391 units  
   - Tower 5: 357 units  
   - Tower 6: 444 units  
   - Tower 7: 244 units  
   - Tower 8: 433 units  
   - Tower 9: 407 units  
   - Tower 10: 305 units  
   - Tower 11: 296 units  
   - Tower 12: 315 units  
   - Tower 13: 302 units  
   - Tower 14: 495 units  
   - Tower 15: 240 units  
   - Tower 16: 379 units  
   - Tower 17: 211 units  
   - Tower 18: 388 units  
   - Tower 19: 220 units  
   - Tower 20: 408 units  
   - Tower 21: 430 units  
   - Tower 22: 327 units  
   - Tower 23: 470 units  
   - Tower 24: 381 units  
   - Tower 25: 476 units  
   - Tower 26: 215 units  
   - Tower 27: 239 units  
   - Tower 28: 372 units  

3. **Binary Decisions**: Each cell tower can either be built (1) or not built (0), and each area can either be covered (1) or not covered (0).

#### Summary:
Your task is to select a combination of cell towers to build, ensuring that the total cost does not exceed 3,059 units, while maximizing the total population covered across the 33 areas. The coverage for each area depends on the specific towers built, and the population sizes and tower costs are provided in detail. The goal is to make strategic decisions about tower deployment to achieve the highest possible population coverage within the budget.","\[
\begin{aligned}
\text{maximize}\quad & \sum_{j=0}^{32} p_j\,y_j \\[4pt]
\text{subject to}\quad 
& \sum_{i=0}^{28} c_i\,x_i \;\le\; 3059 \\[4pt]
& y_j \;\le\; \sum_{i\in S_j} x_i \qquad \forall\, j=0,\dots,32 \\[4pt]
& x_i \in \{0,1\} \qquad \forall\, i=0,\dots,28 \\[2pt]
& y_j \in \{0,1\} \qquad \forall\, j=0,\dots,32
\end{aligned}
\]

where  

\[
\begin{aligned}
p_0&=3522,& p_1&=2492,& p_2&=2865,& p_3&=2596,& p_4&=2194,\\
p_5&=4001,& p_6&=3027,& p_7&=2581,& p_8&=4848,& p_9&=2814,\\
p_{10}&=3543,& p_{11}&=2234,& p_{12}&=2960,& p_{13}&=4297,& p_{14}&=2792,\\
p_{15}&=4520,& p_{16}&=2685,& p_{17}&=2022,& p_{18}&=4858,& p_{19}&=4814,\\
p_{20}&=3432,& p_{21}&=3730,& p_{22}&=2526,& p_{23}&=3277,& p_{24}&=4363,\\
p_{25}&=2622,& p_{26}&=3740,& p_{27}&=4594,& p_{28}&=3193,& p_{29}&=4275,\\
p_{30}&=4407,& p_{31}&=3809,& p_{32}&=2163.
\end{aligned}
\]

\[
\begin{aligned}
c_0&=303,& c_1&=378,& c_2&=327,& c_3&=444,& c_4&=391,\\
c_5&=357,& c_6&=444,& c_7&=244,& c_8&=433,& c_9&=407,\\
c_{10}&=305,& c_{11}&=296,& c_{12}&=315,& c_{13}&=302,& c_{14}&=495,\\
c_{15}&=240,& c_{16}&=379,& c_{17}&=211,& c_{18}&=388,& c_{19}&=220,\\
c_{20}&=408,& c_{21}&=430,& c_{22}&=327,& c_{23}&=470,& c_{24}&=381,\\
c_{25}&=476,& c_{26}&=215,& c_{27}&=239,& c_{28}&=372.
\end{aligned}
\]

\[
S_0=\{3,5,7,10,11,13,15,17,19,22,23,26,27,28\},
\]
and \(S_j\) for \(j=1,\dots,32\) are the corresponding tower sets given in the data.","import gurobipy as gp
from gurobipy import GRB

p = [3522,2492,2865,2596,2194,4001,3027,2581,4848,2814,3543,2234,2960,4297,2792,4520,2685,2022,4858,4814,3432,3730,2526,3277,4363,2622,3740,4594,3193,4275,4407,3809,2163]
c = [303,378,327,444,391,357,444,244,433,407,305,296,315,302,495,240,379,211,388,220,408,430,327,470,381,476,215,239,372]
S = {0:{3,5,7,10,11,13,15,17,19,22,23,26,27,28}}
# Define S_j sets for j=1..32 here

m = gp.Model(""Tower_Selection"")

x = m.addVars(len(c), vtype=GRB.BINARY, name=""x"")
y = m.addVars(len(p), vtype=GRB.BINARY, name=""y"")

m.addConstr(gp.quicksum(c[i]*x[i] for i in range(len(c))) <= 3059, name=""capacity"")

for j in range(len(p)):
    if j in S:
        m.addConstr(y[j] <= gp.quicksum(x[i] for i in S[j]), name=f""link_{j}"")

m.setObjective(gp.quicksum(p[j]*y[j] for j in range(len(p))), GRB.MAXIMIZE)

m.optimize()",111796,111796,1,,,,,,,,
"Imagine you are managing the placement of emergency response centers across five key locations in a region. Each location has the potential to host a center, but due to budget constraints, you can only establish **three centers** in total. The goal is to maximize the overall effectiveness of these centers by ensuring they are strategically placed to cover as much critical area as possible.

Each pair of locations has a predefined **effectiveness score** that represents how well a center at one location can support or complement a center at another location. These scores are as follows:

- **Location 0 and Location 1**: 18  
- **Location 0 and Location 2**: 20  
- **Location 0 and Location 3**: 22  
- **Location 0 and Location 4**: 19  
- **Location 1 and Location 0**: 20  
- **Location 1 and Location 2**: 15  
- **Location 1 and Location 3**: 22  
- **Location 1 and Location 4**: 16  
- **Location 2 and Location 0**: 23  
- **Location 2 and Location 1**: 23  
- **Location 2 and Location 3**: 17  
- **Location 2 and Location 4**: 22  
- **Location 3 and Location 0**: 20  
- **Location 3 and Location 1**: 19  
- **Location 3 and Location 2**: 23  
- **Location 3 and Location 4**: 20  
- **Location 4 and Location 0**: 24  
- **Location 4 and Location 1**: 16  
- **Location 4 and Location 2**: 24  
- **Location 4 and Location 3**: 24  

Your task is to select **three locations** out of the five to establish the centers. The effectiveness of the selected centers is determined by the sum of the pairwise effectiveness scores between the chosen locations. For example, if you select Locations 0, 1, and 2, the total effectiveness would be the sum of the scores for pairs (0,1), (0,2), and (1,2).

However, there are specific rules governing the selection:  
1. A pair of locations can only contribute to the total effectiveness if **both locations in the pair are selected** as centers.  
2. If only one location in a pair is selected, that pair does not contribute to the effectiveness score.  
3. The total number of centers must be exactly three.  

Your objective is to determine which three locations to select to **maximize the total effectiveness** of the emergency response centers, ensuring all constraints are met.","\[
\begin{aligned}
\text{maximize}\quad & 18\,z_{01}+20\,z_{02}+22\,z_{03}+19\,z_{04} \\
&\quad +15\,z_{12}+22\,z_{13}+16\,z_{14}+17\,z_{23}+22\,z_{24}+20\,z_{34} \\
\text{subject to}\quad & y_0+y_1+y_2+y_3+y_4 = 3 \\
& z_{01}\le y_0,\; z_{01}\le y_1,\; z_{01}\ge y_0+y_1-1 \\
& z_{02}\le y_0,\; z_{02}\le y_2,\; z_{02}\ge y_0+y_2-1 \\
& z_{03}\le y_0,\; z_{03}\le y_3,\; z_{03}\ge y_0+y_3-1 \\
& z_{04}\le y_0,\; z_{04}\le y_4,\; z_{04}\ge y_0+y_4-1 \\
& z_{12}\le y_1,\; z_{12}\le y_2,\; z_{12}\ge y_1+y_2-1 \\
& z_{13}\le y_1,\; z_{13}\le y_3,\; z_{13}\ge y_1+y_3-1 \\
& z_{14}\le y_1,\; z_{14}\le y_4,\; z_{14}\ge y_1+y_4-1 \\
& z_{23}\le y_2,\; z_{23}\le y_3,\; z_{23}\ge y_2+y_3-1 \\
& z_{24}\le y_2,\; z_{24}\le y_4,\; z_{24}\ge y_2+y_4-1 \\
& z_{34}\le y_3,\; z_{34}\le y_4,\; z_{34}\ge y_3+y_4-1 \\
& y_i \in \{0,1\}\quad (i=0,\dots,4) \\
& z_{ij} \in \{0,1\}\quad (i<j)
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Maximize_Pairwise_Weights"")

# Decision variables
y = m.addVars(5, vtype=GRB.BINARY, name=""y"")
z = {}
for i in range(5):
    for j in range(i + 1, 5):
        z[(i, j)] = m.addVar(vtype=GRB.BINARY, name=f""z_{i}{j}"")

# Objective coefficients
coeff = {
    (0, 1): 18, (0, 2): 20, (0, 3): 22, (0, 4): 19,
    (1, 2): 15, (1, 3): 22, (1, 4): 16,
    (2, 3): 17, (2, 4): 22,
    (3, 4): 20
}

m.setObjective(gp.quicksum(coeff[(i, j)] * z[(i, j)] for (i, j) in z), GRB.MAXIMIZE)

# Sum of y equals 3
m.addConstr(gp.quicksum(y[i] for i in range(5)) == 3, name=""sum_y"")

# Linking constraints between y and z
for i in range(5):
    for j in range(i + 1, 5):
        m.addConstr(z[(i, j)] <= y[i], name=f""z_le_y{i}"")
        m.addConstr(z[(i, j)] <= y[j], name=f""z_le_y{j}"")
        m.addConstr(z[(i, j)] >= y[i] + y[j] - 1, name=f""z_ge_y{i}y{j}"")

# Optimize
m.optimize()",62,132,0,,,,,,,,
"The goal is to determine the optimal allocation of resources for three products, Product A, Product B, and Product C, to effectively manage a logistics network. The decision variables include the quantities of each product, represented by \( x[0] \), \( x[1] \), and \( x[2] \), as well as auxiliary variables \( y_0[0] \) to \( y_0[3] \), \( y_1[0] \) to \( y_1[3] \), \( y_2[0] \) to \( y_2[3] \), and logistical thresholds \( t_0[0] \), \( t_1[0] \), and \( t_2[0] \). All variables are free to take any real value.

The objective is to minimize the total cost, which is calculated as the sum of the following contributions: -1.109620416617511 times Product A, -0.6560359731414873 times Product B, and -0.7019449433705992 times Product C. This objective reflects the cost structure of the logistics network.

Operational constraints must be satisfied, including three linear equality constraints that define exact relationships between the products. These constraints are: 0.973138297335475 times Product A plus 0.5753515721139748 times Product B minus 0.3345391015917421 times Product C equals -0.1751595502819031; 1.004855798779082 times Product A plus 1.155166374661675 times Product B minus 0.6908735867360416 times Product C equals -0.7437001018712311; and -2.110665713909855 times Product A plus 0.0465859108136975 times Product B plus 1.404349170472437 times Product C equals -2.786300004238841.

Additionally, there are 14 linear constraints that ensure the allocation of resources adheres to specific conditions. These constraints involve combinations of the product quantities and the auxiliary variables \( y_0 \), \( y_1 \), \( y_2 \), and the logistical thresholds \( t_0 \), \( t_1 \), and \( t_2 \). For example, one constraint states that 0.0366410572471413 times Product A plus 0.0568820534300137 times Product B minus 0.000079998 times Product C plus \( y_0[0] \) equals 0.0535813009430022. Similar constraints are defined for the remaining auxiliary variables and thresholds.

Furthermore, three second-order cone constraints ensure that the logistical thresholds satisfy specific quadratic relationships. These constraints are: the sum of the squares of \( y_0[0] \), \( y_0[1] \), \( y_0[2] \), and \( y_0[3] \) minus the square of \( t_0[0] \) must be less than or equal to zero; the sum of the squares of \( y_1[0] \), \( y_1[1] \), \( y_1[2] \), and \( y_1[3] \) minus the square of \( t_1[0] \) must be less than or equal to zero; and the sum of the squares of \( y_2[0] \), \( y_2[1] \), \( y_2[2] \), and \( y_2[3] \) minus the square of \( t_2[0] \) must be less than or equal to zero.

The task is to determine the optimal production and distribution levels for Products A, B, and C, along with the associated intermediate metrics and logistical thresholds, to minimize the total cost while satisfying all operational constraints.","\[
\begin{aligned}
\min\;& -1.109620416617511\,x_{0}\;-\;0.6560359731414873\,x_{1}\;-\;0.7019449433705992\,x_{2} \\[4pt]
\text{s.t.}\;& 0.973138297335475\,x_{0}\;+\;0.5753515721139748\,x_{1}\;-\;0.3345391015917421\,x_{2}
\;=\;-0.1751595502819031 \\[4pt]
& 1.004855798779082\,x_{0}\;+\;1.155166374661675\,x_{1}\;-\;0.6908735867360416\,x_{2}
\;=\;-0.7437001018712311 \\[4pt]
& -2.110665713909855\,x_{0}\;+\;0.0465859108136975\,x_{1}\;+\;1.404349170472437\,x_{2}
\;=\;-2.786300004238841 \\[4pt]
& 0.0366410572471413\,x_{0}\;+\;0.0568820534300137\,x_{1}\;-\;0.000079998\,x_{2}
\;+\;y_{0,0}\;=\;0.0535813009430022 \\[4pt]
& y_{0,0}^{2}+y_{0,1}^{2}+y_{0,2}^{2}+y_{0,3}^{2}\;\le\;t_{0,0}^{2} \\[4pt]
& y_{1,0}^{2}+y_{1,1}^{2}+y_{1,2}^{2}+y_{1,3}^{2}\;\le\;t_{1,0}^{2} \\[4pt]
& y_{2,0}^{2}+y_{2,1}^{2}+y_{2,2}^{2}+y_{2,3}^{2}\;\le\;t_{2,0}^{2} \\[4pt]
& x_{0},x_{1},x_{2},y_{0,0},y_{0,1},y_{0,2},y_{0,3},
  y_{1,0},y_{1,1},y_{1,2},y_{1,3},
  y_{2,0},y_{2,1},y_{2,2},y_{2,3},
  t_{0,0},t_{1,0},t_{2,0}\;\in\;\mathbb{R}\;.
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Optimization_Model"")

# Decision variables
x0 = m.addVar(name=""x0"")
x1 = m.addVar(name=""x1"")
x2 = m.addVar(name=""x2"")

# y variables
y = {}
for i in range(3):
    for j in range(4):
        y[(i,j)] = m.addVar(name=f""y_{i}_{j}"")

# t variables
t = {}
for i in range(3):
    t[i] = m.addVar(name=f""t_{i}_0"")

# Objective: minimize -1.109620416617511*x0 -0.6560359731414873*x1 -0.7019449433705992*x2
m.setObjective(-1.109620416617511*x0 - 0.6560359731414873*x1 - 0.7019449433705992*x2, GRB.MINIMIZE)

# Equality constraints
m.addConstr(0.973138297335475*x0 + 0.5753515721139748*x1 - 0.3345391015917421*x2 == -0.1751595502819031, name=""eq1"")
m.addConstr(1.004855798779082*x0 + 1.155166374661675*x1 - 0.6908735867360416*x2 == -0.7437001018712311, name=""eq2"")
m.addConstr(-2.110665713909855*x0 + 0.0465859108136975*x1 + 1.404349170472437*x2 == -2.786300004238841, name=""eq3"")
m.addConstr(0.0366410572471413*x0 + 0.0568820534300137*x1 - 0.000079998*x2 + y[(0,0)] == 0.0535813009430022, name=""eq4"")

# Quadratic constraints
for i in range(3):
    sum_sq = gp.quicksum(y[(i,j)]*y[(i,j)] for j in range(4))
    m.addQConstr(sum_sq <= t[i]*t[i], name=f""qconstr_{i}"")

# Optimize
m.optimize()
",,1.570831992,0,,,,,,,,
"The problem involves minimizing the weighted sum of four decision variables, with weights -1.901009736372913, -0.7076764487261838, 0.083088283352758, and 0.4134020176281016, respectively. The objective is to minimize the expression -1.901009736372913 times the first variable minus 0.7076764487261838 times the second variable plus 0.083088283352758 times the third variable plus 0.4134020176281016 times the fourth variable.

The problem includes five linear equality constraints. The first constraint requires 1.095257012774988 times the first variable plus 0.0405603467945054 times the second variable minus 0.4142813496378452 times the third variable plus 0.0769274791661522 times the fourth variable to equal -1.589822894954058. The second constraint requires 1.707274498669728 times the first variable minus 0.2477918751127619 times the second variable plus 1.014458021156339 times the third variable plus 0.0887060380647792 times the fourth variable to equal -1.412888255577238. The third constraint requires -0.1928047063342317 times the first variable plus 0.2495462876428885 times the second variable minus 1.347804555582835 times the third variable plus 0.5969103897857732 times the fourth variable to equal -0.7126523262327211. The fourth constraint requires 0.2539181754797121 times the first variable minus 0.4354680188894089 times the second variable minus 0.5625489084016247 times the third variable minus 0.2079253654505673 times the fourth variable to equal 0.0211399419876052. The fifth constraint requires 1.271683708095805 times the first variable plus 1.41227063919648 times the second variable plus 1.237138949722734 times the third variable plus 1.269794867507303 times the fourth variable to equal -3.001810041763422.

Additionally, there are fifteen linear equality constraints involving intermediate variables. These constraints link the decision variables to intermediate variables \( y_0[0], y_0[1], y_1[0], y_1[1], y_2[0], y_2[1], y_3[0], y_3[1], y_4[0], y_4[1] \) and \( t_0[0], t_1[0], t_2[0], t_3[0], t_4[0] \). For example, the sixth constraint requires 0.0930293796109266 times the first variable plus 0.0314487985808588 times the second variable plus 0.0397727019597557 times the third variable plus 0.077024350952894 times the fourth variable plus \( y_0[0] \) to equal -0.0576022066753428. Similarly, the seventh constraint requires 0.3668170269095303 times the first variable plus 0.7382374711397578 times the second variable plus 1.389031691584004 times the third variable plus 0.4784897178942196 times the fourth variable plus \( t_0[0] \) to equal 0.5986251002407987. The remaining constraints follow a similar structure, connecting the decision variables to the intermediate variables with specific coefficients and right-hand side values.

The problem also includes five second-order cone constraints, each involving the intermediate variables. These constraints require that the negative square of \( t_0[0] \) plus the sum of the squares of \( y_0[0] \) and \( y_0[1] \) be less than or equal to zero. Similarly, the negative square of \( t_1[0] \) plus the sum of the squares of \( y_1[0] \) and \( y_1[1] \) must be less than or equal to zero, and this pattern continues for the remaining second-order cone constraints.

All variables, including the four decision variables and the intermediate variables, are free to take any real value. The goal is to determine the values of these variables that minimize the objective function while satisfying all the linear equality constraints and second-order cone constraints.","\[
\begin{aligned}
\min\;& -1.901009736372913\,x_{1}\;-\;0.7076764487261838\,x_{2}\;+\;0.083088283352758\,x_{3}\;+\;0.4134020176281016\,x_{4}\\[6pt]
\text{s.t. }& 1.095257012774988\,x_{1}+0.0405603467945054\,x_{2}-0.4142813496378452\,x_{3}+0.0769274791661522\,x_{4}=-1.589822894954058\\
& 1.707274498669728\,x_{1}-0.2477918751127619\,x_{2}+1.014458021156339\,x_{3}+0.0887060380647792\,x_{4}=-1.412888255577238\\
& -0.1928047063342317\,x_{1}+0.2495462876428885\,x_{2}-1.347804555582835\,x_{3}+0.5969103897857732\,x_{4}=-0.7126523262327211\\
& 0.2539181754797121\,x_{1}-0.4354680188894089\,x_{2}-0.5625489084016247\,x_{3}-0.2079253654505673\,x_{4}=0.0211399419876052\\
& 1.271683708095805\,x_{1}+1.41227063919648\,x_{2}+1.237138949722734\,x_{3}+1.269794867507303\,x_{4}=-3.001810041763422\\
& 0.0930293796109266\,x_{1}+0.0314487985808588\,x_{2}+0.0397727019597557\,x_{3}+0.077024350952894\,x_{4}+y_{0,0}=-0.0576022066753428\\
& 0.3668170269095303\,x_{1}+0.7382374711397578\,x_{2}+1.389031691584004\,x_{3}+0.4784897178942196\,x_{4}+t_{0,0}=0.5986251002407987\\
& y_{0,0}^{2}+y_{0,1}^{2}-t_{0,0}^{2}\le 0\\
& y_{1,0}^{2}+y_{1,1}^{2}-t_{1,0}^{2}\le 0\\
& y_{2,0}^{2}+y_{2,1}^{2}-t_{2,0}^{2}\le 0\\
& y_{3,0}^{2}+y_{3,1}^{2}-t_{3,0}^{2}\le 0\\
& y_{4,0}^{2}+y_{4,1}^{2}-t_{4,0}^{2}\le 0\\
& x_{1},x_{2},x_{3},x_{4},y_{0,0},y_{0,1},y_{1,0},y_{1,1},y_{2,0},y_{2,1},y_{3,0},y_{3,1},y_{4,0},y_{4,1},t_{0,0},t_{1,0},t_{2,0},t_{3,0},t_{4,0}\in\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""OptimizationModel"")

# Decision variables
x1 = m.addVar(name=""x1"")
x2 = m.addVar(name=""x2"")
x3 = m.addVar(name=""x3"")
x4 = m.addVar(name=""x4"")

y = {}
t = {}
for i in range(5):
    for j in range(2):
        y[(i, j)] = m.addVar(name=f""y_{i}_{j}"")
    t[i] = m.addVar(name=f""t_{i}_0"")

# Objective function
m.setObjective(
    -1.901009736372913 * x1
    - 0.7076764487261838 * x2
    + 0.083088283352758 * x3
    + 0.4134020176281016 * x4,
    GRB.MINIMIZE
)

# Linear equality constraints
m.addConstr(
    1.095257012774988 * x1
    + 0.0405603467945054 * x2
    - 0.4142813496378452 * x3
    + 0.0769274791661522 * x4
    == -1.589822894954058,
    name=""c1""
)
m.addConstr(
    1.707274498669728 * x1
    - 0.2477918751127619 * x2
    + 1.014458021156339 * x3
    + 0.0887060380647792 * x4
    == -1.412888255577238,
    name=""c2""
)
m.addConstr(
    -0.1928047063342317 * x1
    + 0.2495462876428885 * x2
    - 1.347804555582835 * x3
    + 0.5969103897857732 * x4
    == -0.7126523262327211,
    name=""c3""
)
m.addConstr(
    0.2539181754797121 * x1
    - 0.4354680188894089 * x2
    - 0.5625489084016247 * x3
    - 0.2079253654505673 * x4
    == 0.0211399419876052,
    name=""c4""
)
m.addConstr(
    1.271683708095805 * x1
    + 1.41227063919648 * x2
    + 1.237138949722734 * x3
    + 1.269794867507303 * x4
    == -3.001810041763422,
    name=""c5""
)

# Linear constraints involving y and t
m.addConstr(
    0.0930293796109266 * x1
    + 0.0314487985808588 * x2
    + 0.0397727019597557 * x3
    + 0.077024350952894 * x4
    + y[(0, 0)]
    == -0.0576022066753428,
    name=""c6""
)
m.addConstr(
    0.3668170269095303 * x1
    + 0.7382374711397578 * x2
    + 1.389031691584004 * x3
    + 0.4784897178942196 * x4
    + t[0]
    == 0.5986251002407987,
    name=""c7""
)

# Quadratic constraints
for i in range(5):
    m.addQConstr(
        y[(i, 0)] * y[(i, 0)] + y[(i, 1)] * y[(i, 1)] - t[i] * t[i] <= 0,
        name=f""qc_{i}""
    )

# Optimize
m.optimize()
```",,3.19301949,0,,,,,,,,
"The optimization problem involves minimizing the linear objective function with coefficients 0.4417937820038825 for variable \(x[0]\), 0.4540568683365753 for variable \(x[1]\), and 0.8269675169997344 for variable \(x[2]\). The problem is subject to a linear equality constraint: -0.8456455953416163 multiplied by \(x[0]\) plus 0.2274379327097405 multiplied by \(x[1]\) minus 0.77122733197339 multiplied by \(x[2]\) equals 0.0015019588399508. Additional linear constraints are imposed as follows: 0.0186179649018269 multiplied by \(x[0]\) plus 0.00822090536490999 multiplied by \(x[1]\) plus 0.0757498425936986 multiplied by \(x[2]\) plus \(y_0[0]\) equals 0.0928781722430411; -0.0864382752107571 multiplied by \(x[0]\) minus 0.0801306131882706 multiplied by \(x[1]\) plus 0.00147592929397403 multiplied by \(x[2]\) plus \(y_0[1]\) equals 0.0116010852586768; -0.0537777103532748 multiplied by \(x[0]\) minus 0.05178106148188 multiplied by \(x[1]\) plus 0.00775179400845416 multiplied by \(x[2]\) plus \(y_0[2]\) equals -0.0432037987392584; 0.0433708626106499 multiplied by \(x[0]\) minus 0.0555679005654094 multiplied by \(x[1]\) plus 0.1354122916870134 multiplied by \(x[2]\) plus \(y_0[3]\) equals -0.113448509613997; -0.13412 multiplied by \(x[0]\) minus 0.5390772678717964 multiplied by \(x[1]\) minus 1.224414665744034 multiplied by \(x[2]\) plus \(t_0[0]\) equals 2.324949537053539; 0.0894817797096893 multiplied by \(x[0]\) plus 0.1252203549610245 multiplied by \(x[1]\) plus 0.1674611083068293 multiplied by \(x[2]\) plus \(y_1[0]\) equals -0.1427178355564866; 0.0560619408765313 multiplied by \(x[0]\) plus 0.00020013926756253 multiplied by \(x[1]\) plus 0.00522276421792812 multiplied by \(x[2]\) plus \(y_1[1]\) equals -0.0793504157062673; 0.00954172270751238 multiplied by \(x[0]\) minus 0.0594530085708131 multiplied by \(x[1]\) minus 0.00960829189584381 multiplied by \(x[2]\) plus \(y_1[2]\) equals 0.098515604042304; -0.0150503497898215 multiplied by \(x[0]\) plus 0.1191163703340514 multiplied by \(x[1]\) plus 0.0214501936255565 multiplied by \(x[2]\) plus \(y_1[3]\) equals -0.0517634861476175; 0.0124789859358057 multiplied by \(x[0]\) plus 0.0900343661509949 multiplied by \(x[1]\) plus 1.223908566697448 multiplied by \(x[2]\) plus \(t_1[0]\) equals 0.7015191241991279. Two second-order cone constraints are imposed: the sum of the squares of \(y_0[0]\), \(y_0[1]\), \(y_0[2]\), and \(y_0[3]\) must not exceed the square of \(t_0[0]\), and the sum of the squares of \(y_1[0]\), \(y_1[1]\), \(y_1[2]\), and \(y_1[3]\) must not exceed the square of \(t_1[0]\). All decision variables, including \(x[0]\), \(x[1]\), \(x[2]\), \(y_0[0]\) through \(y_0[3]\), \(y_1[0]\) through \(y_1[3]\), \(t_0[0]\), and \(t_1[0]\), are free variables. The objective is to minimize the linear objective function while satisfying all linear and second-order cone constraints.","\[
\begin{aligned}
\min\;& 0.4417937820038825\,x_0 + 0.4540568683365753\,x_1 + 0.8269675169997344\,x_2 \\
\text{s.t.}\;& -0.8456455953416163\,x_0 + 0.2274379327097405\,x_1 - 0.77122733197339\,x_2 = 0.0015019588399508 \\
& 0.0186179649018269\,x_0 + 0.00822090536490999\,x_1 + 0.0757498425936986\,x_2 + y_{0,0} = 0.0928781722430411 \\
& -0.0864382752107571\,x_0 - 0.0801306131882706\,x_1 + 0.00147592929397403\,x_2 + y_{0,1} = 0.0116010852586768 \\
& -0.0537777103532748\,x_0 - 0.05178106148188\,x_1 + 0.00775179400845416\,x_2 + y_{0,2} = -0.0432037987392584 \\
& 0.0433708626106499\,x_0 - 0.0555679005654094\,x_1 + 0.1354122916870134\,x_2 + y_{0,3} = -0.113448509613997 \\
& -0.13412\,x_0 - 0.5390772678717964\,x_1 - 1.224414665744034\,x_2 + t_{0,0} = 2.324949537053539 \\
& 0.0894817797096893\,x_0 + 0.1252203549610245\,x_1 + 0.1674611083068293\,x_2 + y_{1,0} = -0.1427178355564866 \\
& 0.0560619408765313\,x_0 + 0.00020013926756253\,x_1 + 0.00522276421792812\,x_2 + y_{1,1} = -0.0793504157062673 \\
& 0.00954172270751238\,x_0 - 0.0594530085708131\,x_1 - 0.00960829189584381\,x_2 + y_{1,2} = 0.098515604042304 \\
& -0.0150503497898215\,x_0 + 0.1191163703340514\,x_1 + 0.0214501936255565\,x_2 + y_{1,3} = -0.0517634861476175 \\
& 0.0124789859358057\,x_0 + 0.0900343661509949\,x_1 + 1.223908566697448\,x_2 + t_{1,0} = 0.7015191241991279 \\
& \sqrt{y_{0,0}^2 + y_{0,1}^2 + y_{0,2}^2 + y_{0,3}^2}\;\le\; t_{0,0} \\
& \sqrt{y_{1,0}^2 + y_{1,1}^2 + y_{1,2}^2 + y_{1,3}^2}\;\le\; t_{1,0} \\
& x_0,x_1,x_2,y_{0,0},y_{0,1},y_{0,2},y_{0,3},t_{0,0},y_{1,0},y_{1,1},y_{1,2},y_{1,3},t_{1,0}\;\in\;\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Optimization_Model"")

# Decision variables
x0 = m.addVar(vtype=GRB.CONTINUOUS, name=""x0"")
x1 = m.addVar(vtype=GRB.CONTINUOUS, name=""x1"")
x2 = m.addVar(vtype=GRB.CONTINUOUS, name=""x2"")

y00 = m.addVar(vtype=GRB.CONTINUOUS, name=""y00"")
y01 = m.addVar(vtype=GRB.CONTINUOUS, name=""y01"")
y02 = m.addVar(vtype=GRB.CONTINUOUS, name=""y02"")
y03 = m.addVar(vtype=GRB.CONTINUOUS, name=""y03"")
t00 = m.addVar(vtype=GRB.CONTINUOUS, name=""t00"")

y10 = m.addVar(vtype=GRB.CONTINUOUS, name=""y10"")
y11 = m.addVar(vtype=GRB.CONTINUOUS, name=""y11"")
y12 = m.addVar(vtype=GRB.CONTINUOUS, name=""y12"")
y13 = m.addVar(vtype=GRB.CONTINUOUS, name=""y13"")
t10 = m.addVar(vtype=GRB.CONTINUOUS, name=""t10"")

# Objective function
m.setObjective(
    0.4417937820038825 * x0
    + 0.4540568683365753 * x1
    + 0.8269675169997344 * x2,
    GRB.MINIMIZE
)

# Linear constraints
m.addConstr(
    -0.8456455953416163 * x0
    + 0.2274379327097405 * x1
    - 0.77122733197339 * x2
    == 0.0015019588399508,
    name=""eq1""
)

m.addConstr(
    0.0186179649018269 * x0
    + 0.00822090536490999 * x1
    + 0.0757498425936986 * x2
    + y00
    == 0.0928781722430411,
    name=""eq2""
)

m.addConstr(
    -0.0864382752107571 * x0
    - 0.0801306131882706 * x1
    + 0.00147592929397403 * x2
    + y01
    == 0.0116010852586768,
    name=""eq3""
)

m.addConstr(
    -0.0537777103532748 * x0
    - 0.05178106148188 * x1
    + 0.00775179400845416 * x2
    + y02
    == -0.0432037987392584,
    name=""eq4""
)

m.addConstr(
    0.0433708626106499 * x0
    - 0.0555679005654094 * x1
    + 0.1354122916870134 * x2
    + y03
    == -0.113448509613997,
    name=""eq5""
)

m.addConstr(
    -0.13412 * x0
    - 0.5390772678717964 * x1
    - 1.224414665744034 * x2
    + t00
    == 2.324949537053539,
    name=""eq6""
)

m.addConstr(
    0.0894817797096893 * x0
    + 0.1252203549610245 * x1
    + 0.1674611083068293 * x2
    + y10
    == -0.1427178355564866,
    name=""eq7""
)

m.addConstr(
    0.0560619408765313 * x0
    + 0.00020013926756253 * x1
    + 0.00522276421792812 * x2
    + y11
    == -0.0793504157062673,
    name=""eq8""
)

m.addConstr(
    0.00954172270751238 * x0
    - 0.0594530085708131 * x1
    - 0.00960829189584381 * x2
    + y12
    == 0.098515604042304,
    name=""eq9""
)

m.addConstr(
    -0.0150503497898215 * x0
    + 0.1191163703340514 * x1
    + 0.0214501936255565 * x2
    + y13
    == -0.0517634861476175,
    name=""eq10""
)

m.addConstr(
    0.0124789859358057 * x0
    + 0.0900343661509949 * x1
    + 1.223908566697448 * x2
    + t10
    == 0.7015191241991279,
    name=""eq11""
)

# Quadratic constraints (norm <= t)
m.addQConstr(
    y00 * y00 + y01 * y01 + y02 * y02 + y03 * y03
    <= t00 * t00,
    name=""norm1""
)

m.addQConstr(
    y10 * y10 + y11 * y11 + y12 * y12 + y13 * y13
    <= t10 * t10,
    name=""norm2""
)

# Optimize
m.optimize()
",,-1.9814759,0,,,,,,,,
"Minimize 0.081229586973361 times x[0] minus 1.333096182188109 times x[1] plus 0.8259327119806184 times x[2] minus 1.123761222193983 times x[3] subject to five linear equality constraints: 0.566954322069251 times x[0] minus 0.7299810090585189 times x[1] plus 0.5965853226996864 times x[2] plus 0.7075700310276837 times x[3] equals -1.035685810880591; 0.1467098805498692 times x[0] plus 1.276004551518634 times x[1] plus 1.816969609021357 times x[2] minus 0.0616423385342787 times x[3] equals -3.620931266248864; 0.3340088790493272 times x[0] minus 0.7150468301081672 times x[1] minus 0.5567266298909594 times x[2] minus 0.8373889941281421 times x[3] equals -0.2488125442726408; -1.342305011059075 times x[0] plus 1.955549036585348 times x[1] plus 0.0602310986862688 times x[2] minus 0.4485566025786823 times x[3] equals 0.8148614925531417; and 0.662271009764529 times x[0] plus 1.235812465401366 times x[1] minus 0.6684584256202986 times x[2] plus 2.261775134584107 times x[3] equals 4.227927950879132.

The model includes three second-order cone constraints defined using auxiliary variables y_0, y_1, and y_2, each with three components, and free variables t_0, t_1, and t_2. The auxiliary variables are defined by twelve linear equations involving the decision variables x and the auxiliary variables y and t. For instance, the first auxiliary variable y_0 is defined by three linear equations: -0.00807132776099688 times x[0] minus 0.00829904212968852 times x[1] plus 0.00729131816846323 times x[2] minus 0.0158474183769015 times x[3] plus y_0[0] equals 0.0740447156962421; 0.0398011692418615 times x[0] minus 0.1170083202748537 times x[1] plus 0.0605494567209828 times x[2] plus 0.0296817366716117 times x[3] plus y_0[1] equals -0.0221765972469103; and -0.00578839554637137 times x[0] minus 0.0410660878455097 times x[1] plus 0.021468433180218 times x[2] plus 0.03829764846326 times x[3] plus y_0[2] equals 0.0261113199527866. The variable t_0[0] is defined by -0.5485199622075393 times x[0] plus 2.161356714141078 times x[1] plus 0.4583402094085766 times x[2] plus 0.4120351464853843 times x[3] plus t_0[0] equals 1.070594461920216. Similar sets of equations define y_1 and y_2, and their associated t variables.

The second-order cone constraints require that the square of t_0[0] must be greater than or equal to the sum of the squares of y_0[0], y_0[1], and y_0[2]; the square of t_1[0] must be greater than or equal to the sum of the squares of y_1[0], y_1[1], and y_1[2]; and the square of t_2[0] must be greater than or equal to the sum of the squares of y_2[0], y_2[1], and y_2[2]. All decision variables, including x, y_0, y_1, y_2, t_0, t_1, and t_2, are free to take any real value. The goal is to minimize the total cost while ensuring that all linear equality constraints and second-order cone constraints are satisfied.","\[
\begin{aligned}
\min\ & 0.081229586973361\,x_0-1.333096182188109\,x_1+0.8259327119806184\,x_2-1.123761222193983\,x_3\\
\text{s.t. } &0.566954322069251\,x_0-0.7299810090585189\,x_1+0.5965853226996864\,x_2+0.7075700310276837\,x_3=-1.035685810880591\\
&0.1467098805498692\,x_0+1.276004551518634\,x_1+1.816969609021357\,x_2-0.0616423385342787\,x_3=-3.620931266248864\\
&0.3340088790493272\,x_0-0.7150468301081672\,x_1-0.5567266298909594\,x_2-0.8373889941281421\,x_3=-0.2488125442726408\\
&-1.342305011059075\,x_0+1.955549036585348\,x_1+0.0602310986862688\,x_2-0.4485566025786823\,x_3=0.8148614925531417\\
&0.662271009764529\,x_0+1.235812465401366\,x_1-0.6684584256202986\,x_2+2.261775134584107\,x_3=4.227927950879132\\
&-0.00807132776099688\,x_0-0.00829904212968852\,x_1+0.00729131816846323\,x_2-0.0158474183769015\,x_3+y_{0,0}=0.0740447156962421\\
&0.0398011692418615\,x_0-0.1170083202748537\,x_1+0.0605494567209828\,x_2+0.0296817366716117\,x_3+y_{0,1}=-0.0221765972469103\\
&-0.00578839554637137\,x_0-0.0410660878455097\,x_1+0.021468433180218\,x_2+0.03829764846326\,x_3+y_{0,2}=0.0261113199527866\\
&-0.5485199622075393\,x_0+2.161356714141078\,x_1+0.4583402094085766\,x_2+0.4120351464853843\,x_3+t_{0,0}=1.070594461920216\\
&\text{(analogous linear equations for }y_{1,j},y_{2,j},t_{1,0},t_{2,0}\text{)}\\
&t_{0,0}^2\ge y_{0,0}^2+y_{0,1}^2+y_{0,2}^2\\
&t_{1,0}^2\ge y_{1,0}^2+y_{1,1}^2+y_{1,2}^2\\
&t_{2,0}^2\ge y_{2,0}^2+y_{2,1}^2+y_{2,2}^2\\
&x_0,x_1,x_2,x_3,y_{0,0},y_{0,1},y_{0,2},y_{1,0},y_{1,1},y_{1,2},y_{2,0},y_{2,1},y_{2,2},t_{0,0},t_{1,0},t_{2,0}\in\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

m = gp.Model(""Optimization_Model"")

# Decision variables
x0 = m.addVar(vtype=GRB.CONTINUOUS, name=""x0"")
x1 = m.addVar(vtype=GRB.CONTINUOUS, name=""x1"")
x2 = m.addVar(vtype=GRB.CONTINUOUS, name=""x2"")
x3 = m.addVar(vtype=GRB.CONTINUOUS, name=""x3"")

y00 = m.addVar(vtype=GRB.CONTINUOUS, name=""y00"")
y01 = m.addVar(vtype=GRB.CONTINUOUS, name=""y01"")
y02 = m.addVar(vtype=GRB.CONTINUOUS, name=""y02"")
y10 = m.addVar(vtype=GRB.CONTINUOUS, name=""y10"")
y11 = m.addVar(vtype=GRB.CONTINUOUS, name=""y11"")
y12 = m.addVar(vtype=GRB.CONTINUOUS, name=""y12"")
y20 = m.addVar(vtype=GRB.CONTINUOUS, name=""y20"")
y21 = m.addVar(vtype=GRB.CONTINUOUS, name=""y21"")
y22 = m.addVar(vtype=GRB.CONTINUOUS, name=""y22"")

t00 = m.addVar(vtype=GRB.CONTINUOUS, name=""t00"")
t10 = m.addVar(vtype=GRB.CONTINUOUS, name=""t10"")
t20 = m.addVar(vtype=GRB.CONTINUOUS, name=""t20"")

# Objective function
m.setObjective(0.081229586973361*x0 - 1.333096182188109*x1 + 0.8259327119806184*x2 - 1.123761222193983*x3, GRB.MINIMIZE)

# Linear constraints
m.addConstr(0.566954322069251*x0 - 0.7299810090585189*x1 + 0.5965853226996864*x2 + 0.7075700310276837*x3 == -1.035685810880591, name=""c1"")
m.addConstr(0.1467098805498692*x0 + 1.276004551518634*x1 + 1.816969609021357*x2 - 0.0616423385342787*x3 == -3.620931266248864, name=""c2"")
m.addConstr(0.3340088790493272*x0 - 0.7150468301081672*x1 - 0.5567266298909594*x2 - 0.8373889941281421*x3 == -0.2488125442726408, name=""c3"")
m.addConstr(-1.342305011059075*x0 + 1.955549036585348*x1 + 0.0602310986862688*x2 - 0.4485566025786823*x3 == 0.8148614925531417, name=""c4"")
m.addConstr(0.662271009764529*x0 + 1.235812465401366*x1 - 0.6684584256202986*x2 + 2.261775134584107*x3 == 4.227927950879132, name=""c5"")
m.addConstr(-0.00807132776099688*x0 - 0.00829904212968852*x1 + 0.00729131816846323*x2 - 0.0158474183769015*x3 + y00 == 0.0740447156962421, name=""c6"")
m.addConstr(0.0398011692418615*x0 - 0.1170083202748537*x1 + 0.0605494567209828*x2 + 0.0296817366716117*x3 + y01 == -0.0221765972469103, name=""c7"")
m.addConstr(-0.00578839554637137*x0 - 0.0410660878455097*x1 + 0.021468433180218*x2 + 0.03829764846326*x3 + y02 == 0.0261113199527866, name=""c8"")
m.addConstr(-0.5485199622075393*x0 + 2.161356714141078*x1 + 0.4583402094085766*x2 + 0.4120351464853843*x3 + t00 == 1.070594461920216, name=""c9"")

# Quadratic constraints
m.addQConstr(t00*t00 >= y00*y00 + y01*y01 + y02*y02, name=""q1"")
m.addQConstr(t10*t10 >= y10*y10 + y11*y11 + y12*y12, name=""q2"")
m.addQConstr(t20*t20 >= y20*y20 + y21*y21 + y22*y22, name=""q3"")

# Solve the model
m.optimize()",,-3.6667438,0,,,,,,,,
"The problem involves minimizing the objective function, which is a linear combination of the decision variables \(x[0]\), \(x[1]\), \(x[2]\), and \(x[3]\) with coefficients -2.044113802210222, -0.591678008651819, -0.9834387040405338, and -0.4216128339992919, respectively. The variables \(x[0]\), \(x[1]\), \(x[2]\), \(x[3]\), \(y_0[0]\), \(y_0[1]\), \(y_1[0]\), and \(y_1[1]\) are free to take any real value. There are five linear equality constraints that relate \(x[0]\), \(x[1]\), \(x[2]\), and \(x[3]\) to specific constant values, with coefficients 1.583533632933326, -0.8648864187788813, 1.390091961404533, 1.822191081529753, -1.084701129083315, 0.8687853511014955, -1.061622663573521, 0.7234328322930561, 0.5805715615387739, -0.9882875862352942, 1.631714852918525, 0.1752665022129386, -0.2276163723137254, 0.3698287397442833, -1.107798916899263, 1.296533143808007, -1.295052034436542, 0.7550822815717648, 1.130836265772762, -1.018723280622327, 2.067786918679711, -1.455751318094515, -0.4504004313993055, 0.5779356751486215, and -1.462119472214241. 

Additionally, there are five constraints involving \(y_0[0]\), \(y_0[1]\), \(y_1[0]\), \(y_1[1]\), \(t_0[0]\), and \(t_1[0]\), with coefficients 0.0279053133377849, -0.00409039039473968, -0.0080383924189651, -0.2012607045179339, -0.1127331987985564, -0.1809080280498793, 0.094841149057402, -0.1684976328590128, 0.0145782756868836, -0.0421818911353208, 0.7645038993025399, -2.040190789758234, 0.225014606611158, 0.49714383406283, 0.3031138305570918, -0.0152851162771371, 0.198409707999221, 0.1277888002263441, 0.1653012900234249, 0.0294096537175579, 0.0764194503294455, 0.047258889505963, -0.0591645566302213, 0.0247500453597441, 0.066093810913026, -0.1089902399914438, 0.8938484212978033, 0.4688910009639788, -0.3004244670748821, and 1.093947030410214. 

The problem also includes two second-order cone constraints: the square of \(t_0[0]\) must be less than or equal to the sum of the squares of \(y_0[0]\) and \(y_0[1]\), and the square of \(t_1[0]\) must be less than or equal to the sum of the squares of \(y_1[0]\) and \(y_1[1]\). The goal is to determine the optimal values of all decision variables that minimize the objective function while satisfying all constraints. This is a Second-Order Cone Programming (SOCP) problem.","\[
\begin{aligned}
\min\;&-2.044113802210222\,x_0-0.591678008651819\,x_1-0.9834387040405338\,x_2-0.4216128339992919\,x_3\\
\text{s.t. }&1.583533632933326\,x_0-0.8648864187788813\,x_1+1.390091961404533\,x_2+1.822191081529753\,x_3=-1.084701129083315\\
&0.8687853511014955\,x_0-1.061622663573521\,x_1+0.7234328322930561\,x_2+0.5805715615387739\,x_3=-0.9882875862352942\\
&1.631714852918525\,x_0+0.1752665022129386\,x_1-0.2276163723137254\,x_2+0.3698287397442833\,x_3=-1.107798916899263\\
&1.296533143808007\,x_0-1.295052034436542\,x_1+0.7550822815717648\,x_2+1.130836265772762\,x_3=-1.018723280622327\\
&2.067786918679711\,x_0-1.455751318094515\,x_1-0.4504004313993055\,x_2+0.5779356751486215\,x_3=-1.462119472214241\\
&0.0279053133377849\,y_{0,0}-0.00409039039473968\,y_{0,1}-0.0080383924189651\,y_{1,0}-0.2012607045179339\,y_{1,1}-0.1127331987985564\,t_{0,0}-0.1809080280498793\,t_{1,0}=0\\
&0.094841149057402\,y_{0,0}-0.1684976328590128\,y_{0,1}+0.0145782756868836\,y_{1,0}-0.0421818911353208\,y_{1,1}+0.7645038993025399\,t_{0,0}-2.040190789758234\,t_{1,0}=0\\
&0.225014606611158\,y_{0,0}+0.49714383406283\,y_{0,1}+0.3031138305570918\,y_{1,0}-0.0152851162771371\,y_{1,1}+0.198409707999221\,t_{0,0}+0.1277888002263441\,t_{1,0}=0\\
&0.1653012900234249\,y_{0,0}+0.0294096537175579\,y_{0,1}+0.0764194503294455\,y_{1,0}+0.047258889505963\,y_{1,1}-0.0591645566302213\,t_{0,0}+0.0247500453597441\,t_{1,0}=0\\
&0.066093810913026\,y_{0,0}-0.1089902399914438\,y_{0,1}+0.8938484212978033\,y_{1,0}+0.4688910009639788\,y_{1,1}-0.3004244670748821\,t_{0,0}+1.093947030410214\,t_{1,0}=0\\
&t_{0,0}^2\le y_{0,0}^2+y_{0,1}^2,\qquad t_{1,0}^2\le y_{1,0}^2+y_{1,1}^2\\
&x_0,x_1,x_2,x_3,y_{0,0},y_{0,1},y_{1,0},y_{1,1},t_{0,0},t_{1,0}\in\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Optimization_Model"")

# Decision variables
x0 = m.addVar(vtype=GRB.CONTINUOUS, name=""x0"")
x1 = m.addVar(vtype=GRB.CONTINUOUS, name=""x1"")
x2 = m.addVar(vtype=GRB.CONTINUOUS, name=""x2"")
x3 = m.addVar(vtype=GRB.CONTINUOUS, name=""x3"")
y00 = m.addVar(vtype=GRB.CONTINUOUS, name=""y00"")
y01 = m.addVar(vtype=GRB.CONTINUOUS, name=""y01"")
y10 = m.addVar(vtype=GRB.CONTINUOUS, name=""y10"")
y11 = m.addVar(vtype=GRB.CONTINUOUS, name=""y11"")
t00 = m.addVar(vtype=GRB.CONTINUOUS, name=""t00"")
t10 = m.addVar(vtype=GRB.CONTINUOUS, name=""t10"")

# Objective function: minimize
m.setObjective(
    -2.044113802210222 * x0
    - 0.591678008651819 * x1
    - 0.9834387040405338 * x2
    - 0.4216128339992919 * x3,
    GRB.MINIMIZE
)

# Linear equality constraints
m.addConstr(
    1.583533632933326 * x0
    - 0.8648864187788813 * x1
    + 1.390091961404533 * x2
    + 1.822191081529753 * x3
    == -1.084701129083315,
    name=""eq1""
)
m.addConstr(
    0.8687853511014955 * x0
    - 1.061622663573521 * x1
    + 0.7234328322930561 * x2
    + 0.5805715615387739 * x3
    == -0.9882875862352942,
    name=""eq2""
)
m.addConstr(
    1.631714852918525 * x0
    + 0.1752665022129386 * x1
    - 0.2276163723137254 * x2
    + 0.3698287397442833 * x3
    == -1.107798916899263,
    name=""eq3""
)
m.addConstr(
    1.296533143808007 * x0
    - 1.295052034436542 * x1
    + 0.7550822815717648 * x2
    + 1.130836265772762 * x3
    == -1.018723280622327,
    name=""eq4""
)
m.addConstr(
    2.067786918679711 * x0
    - 1.455751318094515 * x1
    - 0.4504004313993055 * x2
    + 0.5779356751486215 * x3
    == -1.462119472214241,
    name=""eq5""
)

# Additional linear equality constraints
m.addConstr(
    0.0279053133377849 * y00
    - 0.00409039039473968 * y01
    - 0.0080383924189651 * y10
    - 0.2012607045179339 * y11
    - 0.1127331987985564 * t00
    - 0.1809080280498793 * t10
    == 0,
    name=""eq6""
)
m.addConstr(
    0.094841149057402 * y00
    - 0.1684976328590128 * y01
    + 0.0145782756868836 * y10
    - 0.0421818911353208 * y11
    + 0.7645038993025399 * t00
    - 2.040190789758234 * t10
    == 0,
    name=""eq7""
)
m.addConstr(
    0.225014606611158 * y00
    + 0.49714383406283 * y01
    + 0.3031138305570918 * y10
    - 0.0152851162771371 * y11
    + 0.198409707999221 * t00
    + 0.1277888002263441 * t10
    == 0,
    name=""eq8""
)
m.addConstr(
    0.1653012900234249 * y00
    + 0.0294096537175579 * y01
    + 0.0764194503294455 * y10
    + 0.047258889505963 * y11
    - 0.0591645566302213 * t00
    + 0.0247500453597441 * t10
    == 0,
    name=""eq9""
)
m.addConstr(
    0.066093810913026 * y00
    - 0.1089902399914438 * y01
    + 0.8938484212978033 * y10
    + 0.4688910009639788 * y11
    - 0.3004244670748821 * t00
    + 1.093947030410214 * t10
    == 0,
    name=""eq10""
)

# Quadratic constraints
m.addQConstr(t00 * t00 <= y00 * y00 + y01 * y01, name=""qc1"")
m.addQConstr(t10 * t10 <= y10 * y10 + y11 * y11, name=""qc2"")

# Optimize
m.optimize()
",,2.165231564,0,,,,,,,,
"The problem involves minimizing a linear objective function with six decision variables \( x[0] \) through \( x[5] \), where each variable has a specific coefficient: \( x[0] \) with -2.058644777783222, \( x[1] \) with 0.2416010927247412, \( x[2] \) with -0.4181486412362984, \( x[3] \) with 0.5114234913219796, \( x[4] \) with 0.7386320402187463, and \( x[5] \) with -1.172672370815835. The problem includes five linear equality constraints that must be satisfied. The first constraint requires that the weighted sum of the variables, adjusted by factors -0.5367684107949979, 0.1034203788533778, 1.846625038230486, 0.9784353550415096, -1.878216393450231, and -0.7467874898339996, equals 3.5678313588737. The second constraint equates a weighted sum of \( x[0] \) through \( x[5] \) with coefficients -0.5352309785306387, -0.8520650729788865, -0.8847016444802787, 1.600400673784742, -0.6170038459749025, and 0.5094850995322819 to 0.1979161022274378. The third constraint requires that the weighted sum of \( x[0] \) through \( x[5] \) with coefficients 0.7429110508496402, -0.7085502859117431, -1.428880331198872, -0.838487898882224, -0.4330191528056699, and -1.491505638645529 equals -4.293033952749457. The fourth constraint equates a weighted sum of \( x[0] \) through \( x[5] \) with coefficients 1.389614629752773, 0.702810325846059, -1.416233193493607, 0.6259878762218291, -1.062718067935909, and 1.116816637099358 to 6.052880318149405. The fifth constraint requires that the weighted sum of \( x[0] \) through \( x[5] \) with coefficients 0.5035448845365915, -0.0513767067216146, -1.800678426974007, 1.198119996945881, -0.4513781697868756, and -0.1446651828337932 equals 0.3414915225001892. Additionally, the problem includes eight more linear equality constraints involving additional variables \( y_0[0] \), \( y_0[1] \), \( y_1[0] \), \( y_1[1] \), \( y_2[0] \), \( y_2[1] \), \( t_0[0] \), \( t_1[0] \), and \( t_2[0] \). These constraints link the decision variables \( x[0] \) through \( x[5] \) with the additional variables in specific linear combinations. For instance, the sixth constraint equates a weighted sum of \( x[0] \) through \( x[5] \) with coefficients 0.0384343819842272, 0.0390068546116138, 0.1797102552048576, -0.00927856470872923, 0.1701908634063454, and -0.1248214943708578 plus \( y_0[0] \) to -0.00663951753988017. The seventh constraint equates a weighted sum of \( x[0] \) through \( x[5] \) with coefficients -0.1362799231538006, -0.0831864520235293, 0.1112848630570577, 0.1060222181921134, 0.0402874170898317, and -0.0464976478913114 plus \( y_0[1] \) to 0.0242095284091262. The eighth constraint equates a weighted sum of \( x[0] \) through \( x[5] \) with coefficients -0.0156129943224916, -0.896947647061286, -1.567254730229088, -0.7037621933777273, 0.180343362346215, and 1.006321968448518 plus \( t_0[0] \) to 0.5018287659872952. The ninth constraint equates a weighted sum of \( x[0] \) through \( x[5] \) with coefficients -0.2332423383309324, -0.0330958699417269, -0.00964072153256004, 0.0585722335710037, 0.0217911804090265, and -0.051126178402744 plus \( y_1[0] \) to -0.0968796249195388. The tenth constraint equates a weighted sum of \( x[0] \) through \( x[5] \) with coefficients 0.1151029171245048, 0.1503814324379974, -0.0781335582786794, 0.0402624396659884, -0.0358496162641436, and 0.211819753444535 plus \( y_1[1] \) to 0.0293392072741357. The eleventh constraint equates a weighted sum of \( x[0] \) through \( x[5] \) with coefficients 0.5215036730393952, 0.9990730184126353, 1.195267064572967, 0.190014887816329, 1.638781801327033, and -1.411081833597206 plus \( t_1[0] \) to 0.2585473929490868. The twelfth constraint equates a weighted sum of \( x[0] \) through \( x[5] \) with coefficients -0.0360929813745435, -0.00104760604299632, -0.1784046295918039, -0.0219795512892422, -0.1002032765225464, and 0.0553677513211222 plus \( y_2[0] \) to 0.0514139176871232. The thirteenth constraint equates a weighted sum of \( x[0] \) through \( x[5] \) with coefficients -0.0830942200094662, -0.1767784677541842, 0.1439818445323525, -0.0133640836810608, 0.1360556372574424, and -0.1331263469306528 plus \( y_2[1] \) to -0.0667657097090114. The fourteenth constraint equates a weighted sum of \( x[0] \) through \( x[5] \) with coefficients 0.3082403816753665, 0.1738249328101287, -0.3242604405259034, 0.1914616391261432, 0.8490602240068917, and -1.347767787369367 plus \( t_2[0] \) to 0.3484815971142778. The problem also includes three second-order cone constraints that ensure the sum of the squares of \( y_0[0] \) and \( y_0[1] \) minus the square of \( t_0[0] \) is less than or equal to zero, the sum of the squares of \( y_1[0] \) and \( y_1[1] \) minus the square of \( t_1[0] \) is less than or equal to zero, and the sum of the squares of \( y_2[0] \) and \( y_2[1] \) minus the square of \( t_2[0] \) is less than or equal to zero. All variables, including \( x[0] \) through \( x[5] \), \( y_0[0] \), \( y_0[1] \), \( y_1[0] \), \( y_1[1] \), \( y_2[0] \), \( y_2[1] \), \( t_0[0] \), \( t_1[0] \), and \( t_2[0] \), are free to take any real value. The goal is to minimize the objective function while satisfying all linear equality and second-order cone constraints.","\[
\begin{aligned}
\min\;&-2.058644777783222\,x_0+0.2416010927247412\,x_1-0.4181486412362984\,x_2+0.5114234913219796\,x_3+0.7386320402187463\,x_4-1.172672370815835\,x_5\\
\text{s.t.}\;&-0.5367684107949979\,x_0+0.1034203788533778\,x_1+1.846625038230486\,x_2+0.9784353550415096\,x_3-1.878216393450231\,x_4-0.7467874898339996\,x_5=3.5678313588737\\
&-0.5352309785306387\,x_0-0.8520650729788865\,x_1-0.8847016444802787\,x_2+1.600400673784742\,x_3-0.6170038459749025\,x_4+0.5094850995322819\,x_5=0.1979161022274378\\
&0.7429110508496402\,x_0-0.7085502859117431\,x_1-1.428880331198872\,x_2-0.838487898882224\,x_3-0.4330191528056699\,x_4-1.491505638645529\,x_5=-4.293033952749457\\
&1.389614629752773\,x_0+0.702810325846059\,x_1-1.416233193493607\,x_2+0.6259878762218291\,x_3-1.062718067935909\,x_4+1.116816637099358\,x_5=6.052880318149405\\
&0.5035448845365915\,x_0-0.0513767067216146\,x_1-1.800678426974007\,x_2+1.198119996945881\,x_3-0.4513781697868756\,x_4-0.1446651828337932\,x_5=0.3414915225001892\\
&0.0384343819842272\,x_0+0.0390068546116138\,x_1+0.1797102552048576\,x_2-0.00927856470872923\,x_3+0.1701908634063454\,x_4-0.1248214943708578\,x_5+y_{0,0}=-0.00663951753988017\\
&-0.1362799231538006\,x_0-0.0831864520235293\,x_1+0.1112848630570577\,x_2+0.1060222181921134\,x_3+0.0402874170898317\,x_4-0.0464976478913114\,x_5+y_{0,1}=0.0242095284091262\\
&-0.0156129943224916\,x_0-0.896947647061286\,x_1-1.567254730229088\,x_2-0.7037621933777273\,x_3+0.180343362346215\,x_4+1.006321968448518\,x_5+t_{0,0}=0.5018287659872952\\
&-0.2332423383309324\,x_0-0.0330958699417269\,x_1-0.00964072153256004\,x_2+0.0585722335710037\,x_3+0.0217911804090265\,x_4-0.051126178402744\,x_5+y_{1,0}=-0.0968796249195388\\
&0.1151029171245048\,x_0+0.1503814324379974\,x_1-0.0781335582786794\,x_2+0.0402624396659884\,x_3-0.0358496162641436\,x_4+0.211819753444535\,x_5+y_{1,1}=0.0293392072741357\\
&0.5215036730393952\,x_0+0.9990730184126353\,x_1+1.195267064572967\,x_2+0.190014887816329\,x_3+1.638781801327033\,x_4-1.411081833597206\,x_5+t_{1,0}=0.2585473929490868\\
&-0.0360929813745435\,x_0-0.00104760604299632\,x_1-0.1784046295918039\,x_2-0.0219795512892422\,x_3-0.1002032765225464\,x_4+0.0553677513211222\,x_5+y_{2,0}=0.0514139176871232\\
&-0.0830942200094662\,x_0-0.1767784677541842\,x_1+0.1439818445323525\,x_2-0.0133640836810608\,x_3+0.1360556372574424\,x_4-0.1331263469306528\,x_5+y_{2,1}=-0.0667657097090114\\
&0.3082403816753665\,x_0+0.1738249328101287\,x_1-0.3242604405259034\,x_2+0.1914616391261432\,x_3+0.8490602240068917\,x_4-1.347767787369367\,x_5+t_{2,0}=0.3484815971142778\\
&y_{0,0}^2+y_{0,1}^2-t_{0,0}^2\le0\\
&y_{1,0}^2+y_{1,1}^2-t_{1,0}^2\le0\\
&y_{2,0}^2+y_{2,1}^2-t_{2,0}^2\le0\\
&x_0,x_1,x_2,x_3,x_4,x_5,y_{0,0},y_{0,1},y_{1,0},y_{1,1},y_{2,0},y_{2,1},t_{0,0},t_{1,0},t_{2,0}\in\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

m = gp.Model(""Optimization"")

# Decision variables
x = m.addVars(6, vtype=GRB.CONTINUOUS, name=""x"")
y = m.addVars(3, 2, vtype=GRB.CONTINUOUS, name=""y"")
t = m.addVars(3, vtype=GRB.CONTINUOUS, name=""t"")

# Objective function
m.setObjective(
    -2.058644777783222*x[0] + 0.2416010927247412*x[1] - 0.4181486412362984*x[2]
    + 0.5114234913219796*x[3] + 0.7386320402187463*x[4] - 1.172672370815835*x[5],
    GRB.MINIMIZE
)

# Linear constraints
m.addConstr(-0.5367684107949979*x[0] + 0.1034203788533778*x[1] + 1.846625038230486*x[2]
            + 0.9784353550415096*x[3] - 1.878216393450231*x[4] - 0.7467874898339996*x[5]
            == 3.5678313588737, ""c1"")
m.addConstr(-0.5352309785306387*x[0] - 0.8520650729788865*x[1] - 0.8847016444802787*x[2]
            + 1.600400673784742*x[3] - 0.6170038459749025*x[4] + 0.5094850995322819*x[5]
            == 0.1979161022274378, ""c2"")
m.addConstr(0.7429110508496402*x[0] - 0.7085502859117431*x[1] - 1.428880331198872*x[2]
            - 0.838487898882224*x[3] - 0.4330191528056699*x[4] - 1.491505638645529*x[5]
            == -4.293033952749457, ""c3"")
m.addConstr(1.389614629752773*x[0] + 0.702810325846059*x[1] - 1.416233193493607*x[2]
            + 0.6259878762218291*x[3] - 1.062718067935909*x[4] + 1.116816637099358*x[5]
            == 6.052880318149405, ""c4"")
m.addConstr(0.5035448845365915*x[0] - 0.0513767067216146*x[1] - 1.800678426974007*x[2]
            + 1.198119996945881*x[3] - 0.4513781697868756*x[4] - 0.1446651828337932*x[5]
            == 0.3414915225001892, ""c5"")
m.addConstr(0.0384343819842272*x[0] + 0.0390068546116138*x[1] + 0.1797102552048576*x[2]
            - 0.00927856470872923*x[3] + 0.1701908634063454*x[4] - 0.1248214943708578*x[5]
            + y[0,0] == -0.00663951753988017, ""c6"")
m.addConstr(-0.1362799231538006*x[0] - 0.0831864520235293*x[1] + 0.1112848630570577*x[2]
            + 0.1060222181921134*x[3] + 0.0402874170898317*x[4] - 0.0464976478913114*x[5]
            + y[0,1] == 0.0242095284091262, ""c7"")
m.addConstr(-0.0156129943224916*x[0] - 0.896947647061286*x[1] - 1.567254730229088*x[2]
            - 0.7037621933777273*x[3] + 0.180343362346215*x[4] + 1.006321968448518*x[5]
            + t[0] == 0.5018287659872952, ""c8"")
m.addConstr(-0.2332423383309324*x[0] - 0.0330958699417269*x[1] - 0.00964072153256004*x[2]
            + 0.0585722335710037*x[3] + 0.0217911804090265*x[4] - 0.051126178402744*x[5]
            + y[1,0] == -0.0968796249195388, ""c9"")
m.addConstr(0.1151029171245048*x[0] + 0.1503814324379974*x[1] - 0.0781335582786794*x[2]
            + 0.0402624396659884*x[3] - 0.0358496162641436*x[4] + 0.211819753444535*x[5]
            + y[1,1] == 0.0293392072741357, ""c10"")
m.addConstr(0.5215036730393952*x[0] + 0.9990730184126353*x[1] + 1.195267064572967*x[2]
            + 0.190014887816329*x[3] + 1.638781801327033*x[4] - 1.411081833597206*x[5]
            + t[1] == 0.2585473929490868, ""c11"")
m.addConstr(-0.0360929813745435*x[0] - 0.00104760604299632*x[1] - 0.1784046295918039*x[2]
            - 0.0219795512892422*x[3] - 0.1002032765225464*x[4] + 0.0553677513211222*x[5]
            + y[2,0] == 0.0514139176871232, ""c12"")
m.addConstr(-0.0830942200094662*x[0] - 0.1767784677541842*x[1] + 0.1439818445323525*x[2]
            - 0.0133640836810608*x[3] + 0.1360556372574424*x[4] - 0.1331263469306528*x[5]
            + y[2,1] == -0.0667657097090114, ""c13"")
m.addConstr(0.3082403816753665*x[0] + 0.1738249328101287*x[1] - 0.3242604405259034*x[2]
            + 0.1914616391261432*x[3] + 0.8490602240068917*x[4] - 1.347767787369367*x[5]
            + t[2] == 0.3484815971142778, ""c14"")

# Quadratic constraints
m.addQConstr(y[0,0]*y[0,0] + y[0,1]*y[0,1] <= t[0]*t[0], ""q1"")
m.addQConstr(y[1,0]*y[1,0] + y[1,1]*y[1,1] <= t[1]*t[1], ""q2"")
m.addQConstr(y[2,0]*y[2,0] + y[2,1]*y[2,1] <= t[2]*t[2], ""q3"")

# Optimize
m.optimize()

# Output solution
if m.status == GRB.OPTIMAL:
    for i in range(6):
        print(f""x{i} = {x[i].X}"")
    for i in range(3):
        for j in range(2):
            print(f""y[{i},{j}] = {y[i,j].X}"")
    for i in range(3):
        print(f""t[{i}] = {t[i].X}"")
    print(""Objective:"", m.objVal)",,-6.8509832,0,,,,,,,,
"The problem is to minimize the linear objective function with coefficients -0.2234016903227589 for \(x[0]\), 0.0823239307040719 for \(x[1]\), -0.3139602147497034 for \(x[2]\), and -0.3588305741920246 for \(x[3]\). The variables \(x[0]\), \(x[1]\), \(x[2]\), \(x[3]\), \(y_0[0]\), \(y_0[1]\), and \(t_0[0]\) are free. The solution must satisfy six linear equality constraints. The first constraint requires the weighted sum of variables, with coefficients -2.379260712270257 for \(x[0]\), -0.0926191997384036 for \(x[1]\), 1.500019618890642 for \(x[2]\), and -2.240272675043434 for \(x[3]\), to equal -2.383475883203837. The second constraint requires the weighted sum, with coefficients 0.0880334820094267 for \(x[0]\), -1.902743286220365 for \(x[1]\), -1.061143421718847 for \(x[2]\), and -0.7298562539833904 for \(x[3]\), to equal -0.1651524265365722. The third constraint requires the weighted sum, with coefficients 0.879056298919617 for \(x[0]\), -0.0592926915590702 for \(x[1]\), 1.530225870090669 for \(x[2]\), and 0.7516434368490681 for \(x[3]\), to equal -1.840782058087354. The fourth constraint requires the weighted sum, with coefficients -0.7934367479385507 for \(x[0]\), 0.0232747502052466 for \(x[1]\), -0.6401263883470215 for \(x[2]\), and -0.1075051544628913 for \(x[3]\), to equal 0.5711825810091148. The fifth constraint requires the weighted sum of variables, with coefficients -0.0926233736251473 for \(x[0]\), 0.0599466213459983 for \(x[1]\), 0.2106990148269894 for \(x[2]\), and -0.139498666863404 for \(x[3]\), plus \(y_0[0]\), to equal 0.0103572858836726. The sixth constraint requires the weighted sum of variables, with coefficients -0.0912288940130291 for \(x[0]\), -0.1581472188037661 for \(x[1]\), -0.2376431900824324 for \(x[2]\), and -0.1641150951970651 for \(x[3]\), plus \(y_0[1]\), to equal 0.0072007946533593. The seventh constraint requires the weighted sum of variables, with coefficients -0.4718232097702756 for \(x[0]\), -1.786481176156424 for \(x[1]\), 5.276204984748865e-04 for \(x[2]\), and 0.2812610682665851 for \(x[3]\), plus \(t_0[0]\), to equal 0.3067145358130309. A quadratic constraint ensures that the sum of the squares of \(y_0[0]\) and \(y_0[1]\) is less than or equal to the square of \(t_0[0]\).","\[
\begin{aligned}
\min\quad & -0.2234016903227589\,x_0 + 0.0823239307040719\,x_1 -0.3139602147497034\,x_2 -0.3588305741920246\,x_3 \\
\text{s.t.}\quad
& -2.379260712270257\,x_0 -0.0926191997384036\,x_1 +1.500019618890642\,x_2 -2.240272675043434\,x_3 = -2.383475883203837 \\
& 0.0880334820094267\,x_0 -1.902743286220365\,x_1 -1.061143421718847\,x_2 -0.7298562539833904\,x_3 = -0.1651524265365722 \\
& 0.879056298919617\,x_0 -0.0592926915590702\,x_1 +1.530225870090669\,x_2 +0.7516434368490681\,x_3 = -1.840782058087354 \\
& -0.7934367479385507\,x_0 +0.0232747502052466\,x_1 -0.6401263883470215\,x_2 -0.1075051544628913\,x_3 = 0.5711825810091148 \\
& -0.0926233736251473\,x_0 +0.0599466213459983\,x_1 +0.2106990148269894\,x_2 -0.139498666863404\,x_3 + y_{0,0} = 0.0103572858836726 \\
& -0.0912288940130291\,x_0 -0.1581472188037661\,x_1 -0.2376431900824324\,x_2 -0.1641150951970651\,x_3 + y_{0,1} = 0.0072007946533593 \\
& -0.4718232097702756\,x_0 -1.786481176156424\,x_1 +0.0005276204984748865\,x_2 +0.2812610682665851\,x_3 + t_{0,0} = 0.3067145358130309 \\
& y_{0,0}^2 + y_{0,1}^2 \le t_{0,0}^2 \\
& x_0,\,x_1,\,x_2,\,x_3,\,y_{0,0},\,y_{0,1},\,t_{0,0}\;\in\;\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create the model
m = gp.Model(""Optimization_Model"")

# Decision variables
x0 = m.addVar(vtype=GRB.CONTINUOUS, name=""x0"")
x1 = m.addVar(vtype=GRB.CONTINUOUS, name=""x1"")
x2 = m.addVar(vtype=GRB.CONTINUOUS, name=""x2"")
x3 = m.addVar(vtype=GRB.CONTINUOUS, name=""x3"")
y00 = m.addVar(vtype=GRB.CONTINUOUS, name=""y00"")
y01 = m.addVar(vtype=GRB.CONTINUOUS, name=""y01"")
t00 = m.addVar(vtype=GRB.CONTINUOUS, name=""t00"")

# Objective function: minimize
m.setObjective(
    -0.2234016903227589 * x0
    + 0.0823239307040719 * x1
    - 0.3139602147497034 * x2
    - 0.3588305741920246 * x3,
    GRB.MINIMIZE
)

# Linear equality constraints
m.addConstr(-2.379260712270257 * x0 - 0.0926191997384036 * x1
            + 1.500019618890642 * x2 - 2.240272675043434 * x3
            == -2.383475883203837, name=""eq1"")

m.addConstr(0.0880334820094267 * x0 - 1.902743286220365 * x1
            - 1.061143421718847 * x2 - 0.7298562539833904 * x3
            == -0.1651524265365722, name=""eq2"")

m.addConstr(0.879056298919617 * x0 - 0.0592926915590702 * x1
            + 1.530225870090669 * x2 + 0.7516434368490681 * x3
            == -1.840782058087354, name=""eq3"")

m.addConstr(-0.7934367479385507 * x0 + 0.0232747502052466 * x1
            - 0.6401263883470215 * x2 - 0.1075051544628913 * x3
            == 0.5711825810091148, name=""eq4"")

m.addConstr(-0.0926233736251473 * x0 + 0.0599466213459983 * x1
            + 0.2106990148269894 * x2 - 0.139498666863404 * x3
            + y00 == 0.0103572858836726, name=""eq5"")

m.addConstr(-0.0912288940130291 * x0 - 0.1581472188037661 * x1
            - 0.2376431900824324 * x2 - 0.1641150951970651 * x3
            + y01 == 0.0072007946533593, name=""eq6"")

m.addConstr(-0.4718232097702756 * x0 - 1.786481176156424 * x1
            + 0.0005276204984748865 * x2 + 0.2812610682665851 * x3
            + t00 == 0.3067145358130309, name=""eq7"")

# Quadratic inequality constraint
m.addQConstr(y00 * y00 + y01 * y01 <= t00 * t00, name=""quad_constraint"")

# Optimize the model
m.optimize()",,0.46776346,0,,,,,,,,
"Determine the optimal amount of resources \( x[0] \), \( x[1] \), and \( x[2] \) to allocate across three operational areas to minimize the total cost, calculated as 2.238472652501168 multiplied by \( x[0] \) plus 1.593692449804477 multiplied by \( x[1] \) plus 1.091018724438081 multiplied by \( x[2] \). The allocation must satisfy a linear resource balance constraint: 2.086630330627226 multiplied by \( x[0] \) plus 0.0977042297800921 multiplied by \( x[1] \) plus 0.3238066911742682 multiplied by \( x[2] \) equals 0.2728125978918034.

The problem includes three quadratic cone constraints \( qc0 \), \( qc1 \), and \( qc2 \), which are part of a Second-Order Cone Programming (SOCP) problem. For the first operational area, the quadratic cone constraint \( qc0 \) requires that the sum of the squares of \( y_0[0] \) and \( y_0[1] \) must be less than or equal to the square of \( t_0[0] \). Here, \( y_0[0] \) is determined by 1.350013394321828 multiplied by \( x[0] \) minus 0.2433648689288818 multiplied by \( x[1] \) plus 1.170490297808538 multiplied by \( x[2] \), which equals -0.854030949971019. Similarly, \( y_0[1] \) is determined by -0.5827218400584065 multiplied by \( x[0] \) minus 1.214924181090006 multiplied by \( x[1] \) minus 0.7100967735067889 multiplied by \( x[2] \), which equals 0.1115410551073176. The variable \( t_0[0] \) is determined by -0.1042401171821044 multiplied by \( x[0] \) plus 0.2613612792965374 multiplied by \( x[1] \) plus 1.118900434050682 multiplied by \( x[2] \), which equals 0.6038954719472605.

For the second operational area, the quadratic cone constraint \( qc1 \) requires that the sum of the squares of \( y_1[0] \) and \( y_1[1] \) must be less than or equal to the square of \( t_1[0] \). Here, \( y_1[0] \) is determined by 0.1242454238540142 multiplied by \( x[0] \) minus 0.2094940308550101 multiplied by \( x[1] \) plus 0.0218788315028139 multiplied by \( x[2] \), which equals -0.1826683487550716. Similarly, \( y_1[1] \) is determined by 0.0612039952350878 multiplied by \( x[0] \) plus 0.019467075730508 multiplied by \( x[1] \) minus 0.0279175737966843 multiplied by \( x[2] \), which equals -0.1133584554034866. The variable \( t_1[0] \) is determined by -0.1049189629762404 multiplied by \( x[0] \) plus 0.6171636592039963 multiplied by \( x[1] \) minus 0.385085431921569 multiplied by \( x[2] \), which equals 1.132753956602686.

For the third operational area, the quadratic cone constraint \( qc2 \) requires that the sum of the squares of \( y_2[0] \) and \( y_2[1] \) must be less than or equal to the square of \( t_2[0] \). Here, \( y_2[0] \) is determined by -0.1504745044323135 multiplied by \( x[0] \) minus 0.1569086648551038 multiplied by \( x[1] \) minus 0.1058514836896046 multiplied by \( x[2] \), which equals 0.2363416370720583. Similarly, \( y_2[1] \) is determined by 0.0825995942902514 multiplied by \( x[0] \) minus 0.089460646459489 multiplied by \( x[1] \) minus 0.0359085847666962 multiplied by \( x[2] \), which equals 0.1827679172343429. The variable \( t_2[0] \) is determined by -0.2546431852316068 multiplied by \( x[0] \) minus 0.9584080837019103 multiplied by \( x[1] \) plus 0.3025850075547174 multiplied by \( x[2] \), which equals 1.774740955514529.

All variables, including \( x[0] \), \( x[1] \), \( x[2] \), \( y_0[0] \), \( y_0[1] \), \( y_1[0] \), \( y_1[1] \), \( y_2[0] \), \( y_2[1] \), \( t_0[0] \), \( t_1[0] \), and \( t_2[0] \), are free to take any real value, as there are no bounds restricting their values. The quadratic cone constraints \( qc0 \), \( qc1 \), and \( qc2 \) are explicitly part of the problem constraints, and the variables \( y_0[0] \), \( y_0[1] \), \( y_1[0] \), \( y_1[1] \), \( y_2[0] \), \( y_2[1] \), \( t_0[0] \), \( t_1[0] \), and \( t_2[0] \) are auxiliary variables introduced to represent these quadratic cone constraints. The problem is a Second-Order Cone Programming (SOCP) problem, as indicated by the LP data header.","\[
\begin{aligned}
\min\;& 2.238472652501168\,x_0 + 1.593692449804477\,x_1 + 1.091018724438081\,x_2\\
\text{s.t.}\;& 2.086630330627226\,x_0 + 0.0977042297800921\,x_1 + 0.3238066911742682\,x_2 = 0.2728125978918034\\
& y_{0,0}=1.350013394321828\,x_0-0.2433648689288818\,x_1+1.170490297808538\,x_2\\
& y_{0,1}=-0.5827218400584065\,x_0-1.214924181090006\,x_1-0.7100967735067889\,x_2\\
& t_{0,0}=-0.1042401171821044\,x_0+0.2613612792965374\,x_1+1.118900434050682\,x_2\\
& y_{1,0}=0.1242454238540142\,x_0-0.2094940308550101\,x_1+0.0218788315028139\,x_2\\
& y_{1,1}=0.0612039952350878\,x_0+0.019467075730508\,x_1-0.0279175737966843\,x_2\\
& t_{1,0}=-0.1049189629762404\,x_0+0.6171636592039963\,x_1-0.385085431921569\,x_2\\
& y_{2,0}=-0.1504745044323135\,x_0-0.1569086648551038\,x_1-0.1058514836896046\,x_2\\
& y_{2,1}=0.0825995942902514\,x_0-0.089460646459489\,x_1-0.0359085847666962\,x_2\\
& t_{2,0}=-0.2546431852316068\,x_0-0.9584080837019103\,x_1+0.3025850075547174\,x_2\\
& y_{0,0}^2+y_{0,1}^2\le t_{0,0}^2\\
& y_{1,0}^2+y_{1,1}^2\le t_{1,0}^2\\
& y_{2,0}^2+y_{2,1}^2\le t_{2,0}^2\\
& x_0,x_1,x_2,y_{0,0},y_{0,1},y_{1,0},y_{1,1},y_{2,0},y_{2,1},t_{0,0},t_{1,0},t_{2,0}\in\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Quadratic_Optimization"")

# Decision variables
x0 = m.addVar(vtype=GRB.CONTINUOUS, name=""x0"")
x1 = m.addVar(vtype=GRB.CONTINUOUS, name=""x1"")
x2 = m.addVar(vtype=GRB.CONTINUOUS, name=""x2"")

y00 = m.addVar(vtype=GRB.CONTINUOUS, name=""y00"")
y01 = m.addVar(vtype=GRB.CONTINUOUS, name=""y01"")
y10 = m.addVar(vtype=GRB.CONTINUOUS, name=""y10"")
y11 = m.addVar(vtype=GRB.CONTINUOUS, name=""y11"")
y20 = m.addVar(vtype=GRB.CONTINUOUS, name=""y20"")
y21 = m.addVar(vtype=GRB.CONTINUOUS, name=""y21"")

t00 = m.addVar(vtype=GRB.CONTINUOUS, name=""t00"")
t10 = m.addVar(vtype=GRB.CONTINUOUS, name=""t10"")
t20 = m.addVar(vtype=GRB.CONTINUOUS, name=""t20"")

# Objective function
m.setObjective(2.238472652501168*x0 + 1.593692449804477*x1 + 1.091018724438081*x2, GRB.MINIMIZE)

# Equality constraint
m.addConstr(2.086630330627226*x0 + 0.0977042297800921*x1 + 0.3238066911742682*x2 == 0.2728125978918034, ""eq_constraint"")

# Linear definitions of y and t
m.addConstr(y00 == 1.350013394321828*x0 - 0.2433648689288818*x1 + 1.170490297808538*x2, ""y00_def"")
m.addConstr(y01 == -0.5827218400584065*x0 - 1.214924181090006*x1 - 0.7100967735067889*x2, ""y01_def"")
m.addConstr(t00 == -0.1042401171821044*x0 + 0.2613612792965374*x1 + 1.118900434050682*x2, ""t00_def"")

m.addConstr(y10 == 0.1242454238540142*x0 - 0.2094940308550101*x1 + 0.0218788315028139*x2, ""y10_def"")
m.addConstr(y11 == 0.0612039952350878*x0 + 0.019467075730508*x1 - 0.0279175737966843*x2, ""y11_def"")
m.addConstr(t10 == -0.1049189629762404*x0 + 0.6171636592039963*x1 - 0.385085431921569*x2, ""t10_def"")

m.addConstr(y20 == -0.1504745044323135*x0 - 0.1569086648551038*x1 - 0.1058514836896046*x2, ""y20_def"")
m.addConstr(y21 == 0.0825995942902514*x0 - 0.089460646459489*x1 - 0.0359085847666962*x2, ""y21_def"")
m.addConstr(t20 == -0.2546431852316068*x0 - 0.9584080837019103*x1 + 0.3025850075547174*x2, ""t20_def"")

# Quadratic constraints
m.addQConstr(y00*y00 + y01*y01 <= t00*t00, ""qc_0"")
m.addQConstr(y10*y10 + y11*y11 <= t10*t10, ""qc_1"")
m.addQConstr(y20*y20 + y21*y21 <= t20*t20, ""qc_2"")

# Optimize
m.optimize()",,-8.9494699,0,,,,,,,,
"The problem involves minimizing a linear objective function with decision variables \( x[0] \), \( x[1] \), and \( x[2] \), along with auxiliary variables \( y_0[0] \), \( y_0[1] \), \( y_0[2] \), and \( t_0[0] \). The objective function coefficients are 0.9775739758894315 for \( x[0] \), -1.622521430954005 for \( x[1] \), and -0.3823943916427769 for \( x[2] \). All variables \( x[0] \), \( x[1] \), \( x[2] \), \( y_0[0] \), \( y_0[1] \), \( y_0[2] \), and \( t_0[0] \) are free.

The constraints include four linear equality constraints. The first constraint ensures that 2.218395151719285 times \( x[0] \) minus 0.4934367321170816 times \( x[1] \) plus 2.037698386055625 times \( x[2] \) equals -7.639024318581815. The second constraint ensures that 0.1288997654276396 times \( x[0] \) plus 0.4134151782133442 times \( x[1] \) minus 1.016848910244227 times \( x[2] \) equals 0.8282605412220725. The third constraint ensures that -0.3888036525234204 times \( x[0] \) plus 1.582023744531529 times \( x[1] \) plus 0.4853205141377102 times \( x[2] \) equals 0.9861388989442696. The fourth constraint ensures that -0.8184959408216979 times \( x[0] \) plus 0.1508892622723634 times \( x[1] \) plus 0.4877918700202323 times \( x[2] \) equals 1.575829009785032.

Additionally, there are four linear constraints defining \( y_0[0] \), \( y_0[1] \), \( y_0[2] \), and \( t_0[0] \) in terms of \( x[0] \), \( x[1] \), and \( x[2] \). The first constraint ensures that 0.000682161 times \( x[0] \) minus 0.058594741163783 times \( x[1] \) minus 0.2214986665992643 times \( x[2] \) plus \( y_0[0] \) equals 0.0363203305835107. The second constraint ensures that -0.00108977088958764 times \( x[0] \) plus 0.0836225593865622 times \( x[1] \) minus 0.2893750072155089 times \( x[2] \) plus \( y_0[1] \) equals -0.1460000637840041. The third constraint ensures that -0.0231877971791914 times \( x[0] \) minus 0.0340439160737732 times \( x[1] \) minus 0.2441350484603667 times \( x[2] \) plus \( y_0[2] \) equals 0.0702001695223133. The fourth constraint ensures that 0.8200125377679498 times \( x[0] \) minus 0.2688442189065823 times \( x[1] \) plus 0.8884584718933239 times \( x[2] \) plus \( t_0[0] \) equals 0.0172532969418979.

A second-order cone constraint ensures that the square of \( t_0[0] \) is less than or equal to the sum of the squares of \( y_0[0] \), \( y_0[1] \), and \( y_0[2] \), specifically expressed as \(-t_0[0]^2 + y_0[0]^2 + y_0[1]^2 + y_0[2]^2 \leq 0\). The goal is to determine the values of \( x[0] \), \( x[1] \), \( x[2] \), \( y_0[0] \), \( y_0[1] \), \( y_0[2] \), and \( t_0[0] \) that minimize the objective function while satisfying all constraints. This is a Second-Order Cone Programming (SOCP) problem.","\[
\begin{aligned}
\min\quad & 0.9775739758894315\,x_0 \;-\;1.622521430954005\,x_1 \;-\;0.3823943916427769\,x_2\\
\text{s.t.}\quad
& 2.218395151719285\,x_0 \;-\;0.4934367321170816\,x_1 \;+\;2.037698386055625\,x_2 \;=\; -7.639024318581815\\
& 0.1288997654276396\,x_0 \;+\;0.4134151782133442\,x_1 \;-\;1.016848910244227\,x_2 \;=\; 0.8282605412220725\\
& -0.3888036525234204\,x_0 \;+\;1.582023744531529\,x_1 \;+\;0.4853205141377102\,x_2 \;=\; 0.9861388989442696\\
& -0.8184959408216979\,x_0 \;+\;0.1508892622723634\,x_1 \;+\;0.4877918700202323\,x_2 \;=\; 1.575829009785032\\
& 0.000682161\,x_0 \;-\;0.058594741163783\,x_1 \;-\;0.2214986665992643\,x_2 \;+\;y_{0,0} \;=\; 0.0363203305835107\\
& -0.00108977088958764\,x_0 \;+\;0.0836225593865622\,x_1 \;-\;0.2893750072155089\,x_2 \;+\;y_{0,1} \;=\; -0.1460000637840041\\
& -0.0231877971791914\,x_0 \;-\;0.0340439160737732\,x_1 \;-\;0.2441350484603667\,x_2 \;+\;y_{0,2} \;=\; 0.0702001695223133\\
& 0.8200125377679498\,x_0 \;-\;0.2688442189065823\,x_1 \;+\;0.8884584718933239\,x_2 \;+\;t_{0,0} \;=\; 0.0172532969418979\\
& -t_{0,0}^2 \;+\;y_{0,0}^2 \;+\;y_{0,1}^2 \;+\;y_{0,2}^2 \;\le\; 0\\
& x_0,x_1,x_2,y_{0,0},y_{0,1},y_{0,2},t_{0,0}\;\in\;\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Optimization_Model"")

# Decision variables
x0 = m.addVar(vtype=GRB.CONTINUOUS, name=""x0"")
x1 = m.addVar(vtype=GRB.CONTINUOUS, name=""x1"")
x2 = m.addVar(vtype=GRB.CONTINUOUS, name=""x2"")
y00 = m.addVar(vtype=GRB.CONTINUOUS, name=""y00"")
y01 = m.addVar(vtype=GRB.CONTINUOUS, name=""y01"")
y02 = m.addVar(vtype=GRB.CONTINUOUS, name=""y02"")
t00 = m.addVar(vtype=GRB.CONTINUOUS, name=""t00"")

# Objective function
m.setObjective(0.9775739758894315*x0 - 1.622521430954005*x1 - 0.3823943916427769*x2, GRB.MINIMIZE)

# Linear equality constraints
m.addConstr(2.218395151719285*x0 - 0.4934367321170816*x1 + 2.037698386055625*x2 == -7.639024318581815, name=""eq1"")
m.addConstr(0.1288997654276396*x0 + 0.4134151782133442*x1 - 1.016848910244227*x2 == 0.8282605412220725, name=""eq2"")
m.addConstr(-0.3888036525234204*x0 + 1.582023744531529*x1 + 0.4853205141377102*x2 == 0.9861388989442696, name=""eq3"")
m.addConstr(-0.8184959408216979*x0 + 0.1508892622723634*x1 + 0.4877918700202323*x2 == 1.575829009785032, name=""eq4"")

# Constraints involving y variables
m.addConstr(0.000682161*x0 - 0.058594741163783*x1 - 0.2214986665992643*x2 + y00 == 0.0363203305835107, name=""eq5"")
m.addConstr(-0.00108977088958764*x0 + 0.0836225593865622*x1 - 0.2893750072155089*x2 + y01 == -0.1460000637840041, name=""eq6"")
m.addConstr(-0.0231877971791914*x0 - 0.0340439160737732*x1 - 0.2441350484603667*x2 + y02 == 0.0702001695223133, name=""eq7"")

# Constraint involving t variable
m.addConstr(0.8200125377679498*x0 - 0.2688442189065823*x1 + 0.8884584718933239*x2 + t00 == 0.0172532969418979, name=""eq8"")

# Nonlinear quadratic constraint
m.addQConstr(-t00*t00 + y00*y00 + y01*y01 + y02*y02 <= 0, name=""nonlinear_constraint"")

# Optimize
m.optimize()
",,-2.5488419,0,,,,,,,,
"The problem involves minimizing a linear objective function defined by the coefficients 0.0169907447059004 for x[0], -0.1354658035191434 for x[1], and 0.1439797319070909 for x[2]. The optimization is subject to four linear equality constraints that balance the relationships between the variables x[0], x[1], and x[2]. The first constraint requires that 0.8636590559284738 times x[0] plus 0.0966833012301337 times x[1] minus 0.3152291953090132 times x[2] equals 0.8843372418353203. The second constraint requires that -1.308791116694014 times x[0] plus 1.026765786674754 times x[1] minus 1.641892627931514 times x[2] equals -3.068584167132096. The third constraint requires that -2.022894561574939 times x[0] plus 1.078027292135305 times x[1] minus 0.6806946931130862 times x[2] equals -3.878545364964277. The fourth constraint requires that 0.5909183755526639 times x[0] minus 1.227754194746086 times x[1] plus 0.9978468809169225 times x[2] equals 2.373932955061617. 

The problem also includes twelve additional linear constraints that introduce auxiliary variables y_0, y_1, y_2, and t_0, t_1, t_2. These constraints balance the primary variables x[0], x[1], and x[2] with the auxiliary variables. For example, constraint R4 requires that -0.0830895372455731 times x[0] plus 0.140196500160931 times x[1] plus 0.0835731570777216 times x[2] plus y_0[0] equals -0.0542756929304628. Similarly, constraints R5 through R15 impose similar relationships involving y_0[1], y_0[2], y_1[0], y_1[1], y_1[2], y_2[0], y_2[1], y_2[2], t_0[0], t_1[0], and t_2[0]. 

The problem also includes three second-order cone constraints, qc0, qc1, and qc2, which ensure that the sum of the squares of the auxiliary variables y_0[0], y_0[1], and y_0[2] does not exceed the square of t_0[0], the sum of the squares of y_1[0], y_1[1], and y_1[2] does not exceed the square of t_1[0], and the sum of the squares of y_2[0], y_2[1], and y_2[2] does not exceed the square of t_2[0]. All variables, including x[0], x[1], x[2], y_0[0], y_0[1], y_0[2], y_1[0], y_1[1], y_1[2], y_2[0], y_2[1], y_2[2], t_0[0], t_1[0], and t_2[0], are free to take any real value. The goal is to determine the values of these variables that minimize the objective function while satisfying all constraints.","\[
\begin{aligned}
\min\;& 0.0169907447059004\,x_0-0.1354658035191434\,x_1+0.1439797319070909\,x_2\\[4pt]
\text{s.t. }&0.8636590559284738\,x_0+0.0966833012301337\,x_1-0.3152291953090132\,x_2=0.8843372418353203\\
&-1.308791116694014\,x_0+1.026765786674754\,x_1-1.641892627931514\,x_2=-3.068584167132096\\
&-2.022894561574939\,x_0+1.078027292135305\,x_1-0.6806946931130862\,x_2=-3.878545364964277\\
&0.5909183755526639\,x_0-1.227754194746086\,x_1+0.9978468809169225\,x_2=2.373932955061617\\
&-0.0830895372455731\,x_0+0.140196500160931\,x_1+0.0835731570777216\,x_2+y_{0,0}=-0.0542756929304628\\
&\text{(R5__15: }a_{0k}x_0+a_{1k}x_1+a_{2k}x_2+y_{0,k}=b_k,\;k=1,2\\
&\qquad\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Optimization_Model"")

# Decision variables
x0 = m.addVar(name=""x0"")
x1 = m.addVar(name=""x1"")
x2 = m.addVar(name=""x2"")
y00 = m.addVar(name=""y_0_0"")

# Objective function: minimize 0.0169907447059004*x0 - 0.1354658035191434*x1 + 0.1439797319070909*x2
m.setObjective(0.0169907447059004 * x0 - 0.1354658035191434 * x1 + 0.1439797319070909 * x2, GRB.MINIMIZE)

# Constraints
m.addConstr(0.8636590559284738 * x0 + 0.0966833012301337 * x1 - 0.3152291953090132 * x2 == 0.8843372418353203, name=""c1"")
m.addConstr(-1.308791116694014 * x0 + 1.026765786674754 * x1 - 1.641892627931514 * x2 == -3.068584167132096, name=""c2"")
m.addConstr(-2.022894561574939 * x0 + 1.078027292135305 * x1 - 0.6806946931130862 * x2 == -3.878545364964277, name=""c3"")
m.addConstr(0.5909183755526639 * x0 - 1.227754194746086 * x1 + 0.9978468809169225 * x2 == 2.373932955061617, name=""c4"")
m.addConstr(-0.0830895372455731 * x0 + 0.140196500160931 * x1 + 0.0835731570777216 * x2 + y00 == -0.0542756929304628, name=""c5"")

# Optimize
m.optimize()",,0.207797304,0,,,,,,,,
"Minimize the total cost of resource allocation, where the cost coefficients for the variables x[0] to x[6] are -0.2747522145296182, -1.766479699359979, 0.7843967105070561, 0.1559911408895964, -0.891327664664444, -0.2108190112467947, and -0.4779719262070241, respectively. The allocation must satisfy five equality constraints:  
1. The allocation for x[0] multiplied by 1.015905804200365, minus the allocation for x[1] multiplied by 1.075563368516513, plus the allocation for x[2] multiplied by 1.354422581651652, plus the allocation for x[3] multiplied by 1.231175719391763, minus the allocation for x[4] multiplied by 0.5695498149899738, minus the allocation for x[5] multiplied by 0.0845431272925385, minus the allocation for x[6] multiplied by 0.945839019408856, must equal -0.0350333551254621.  
2. The allocation for x[0] multiplied by 0.1021906812588868, plus the allocation for x[1] multiplied by 1.017649603494175, plus the allocation for x[2] multiplied by 0.7113625469010652, minus the allocation for x[3] multiplied by 0.7845975403828425, minus the allocation for x[4] multiplied by 0.1330475619361555, minus the allocation for x[5] multiplied by 0.2027851245783147, minus the allocation for x[6] multiplied by 0.4907635167746233, must equal -0.0890746280206778.  
3. The allocation for x[0] multiplied by -0.0691151611879505, minus the allocation for x[1] multiplied by 0.1726234142770679, plus the allocation for x[2] multiplied by 0.7490870928543292, minus the allocation for x[3] multiplied by 0.0017337760468129, minus the allocation for x[4] multiplied by 0.9675143456769632, minus the allocation for x[5] multiplied by 0.6700478590428591, minus the allocation for x[6] multiplied by 0.3470673767061095, must equal -2.198650485794045.  
4. The allocation for x[0] multiplied by -0.1853251444505973, minus the allocation for x[1] multiplied by 1.849600638660094, minus the allocation for x[2] multiplied by 1.508370034295556, minus the allocation for x[3] multiplied by 0.9668525673953132, minus the allocation for x[4] multiplied by 1.21156196565678, minus the allocation for x[5] multiplied by 0.6645469549418966, plus the allocation for x[6] multiplied by 1.661638743910969, must equal -4.829481983044288.  
5. The allocation for x[0] multiplied by 0.8891607518271019, plus the allocation for x[1] multiplied by 0.8384286881235276, minus the allocation for x[2] multiplied by 0.8035031028628979, minus the allocation for x[3] multiplied by 1.092054353478263, plus the allocation for x[4] multiplied by 0.3420691219898985, plus the allocation for x[5] multiplied by 0.1291789846691225, plus the allocation for x[6] multiplied by 2.02029578986399, must equal 0.8991262576526948.  

Additionally, there are four linear constraints involving auxiliary variables y_0[0], y_0[1], y_0[2], and t_0[0]:  
1. The allocation for x[0] multiplied by 0.1370623147413594, minus the allocation for x[1] multiplied by 0.0955523959954012, minus the allocation for x[2] multiplied by 0.1070159267992108, minus the allocation for x[3] multiplied by 0.044283559484152, plus the allocation for x[4] multiplied by 0.2052751838377566, minus the allocation for x[5] multiplied by 0.0472147055355524, plus the allocation for x[6] multiplied by 0.0263779101242163, plus the auxiliary variable y_0[0], must equal -0.1372906598086168.  
2. The allocation for x[0] multiplied by -0.0864033173525697, minus the allocation for x[1] multiplied by 0.0242389263268966, plus the allocation for x[2] multiplied by 0.0198400163659476, minus the allocation for x[3] multiplied by 0.0529154412212283, plus the allocation for x[4] multiplied by 0.0919575570765138, minus the allocation for x[5] multiplied by 0.0465630198887696, minus the allocation for x[6] multiplied by 0.0415047822548149, plus the auxiliary variable y_0[1], must equal -0.1090956146371356.  
3. The allocation for x[0] multiplied by -0.0493566419623072, plus the allocation for x[1] multiplied by 0.0190877037065351, minus the allocation for x[2] multiplied by 0.0625676089375108, plus the allocation for x[3] multiplied by 0.0152602958492, minus the allocation for x[4] multiplied by 0.00439851178580794, plus the allocation for x[5] multiplied by 0.1593300015509853, plus the allocation for x[6] multiplied by 0.1099457671812097, plus the auxiliary variable y_0[2], must equal -0.018160978920798.  
4. The allocation for x[0] multiplied by 2.17906321051382, plus the allocation for x[1] multiplied by 0.2404505380691451, minus the allocation for x[2] multiplied by 1.273156876389871, minus the allocation for x[3] multiplied by 1.521652877877997, minus the allocation for x[4] multiplied by 0.9431372726898773, minus the allocation for x[5] multiplied by 0.9371176801678375, minus the allocation for x[6] multiplied by 1.072428152750414, plus the auxiliary variable t_0[0], must equal 1.636356226721274.  

A second-order cone constraint requires that the negative square of the auxiliary variable t_0[0] plus the sum of the squares of the auxiliary variables y_0[0], y_0[1], and y_0[2] must be less than or equal to zero. All decision variables, including x[0] to x[6], y_0[0], y_0[1], y_0[2], and t_0[0], are free and unbounded. The goal is to minimize the total cost while satisfying all these constraints.","\[
\begin{aligned}
\min\;&-0.2747522145296182\,x_0-1.766479699359979\,x_1+0.7843967105070561\,x_2+0.1559911408895964\,x_3-0.891327664664444\,x_4-0.2108190112467947\,x_5-0.4779719262070241\,x_6\\
\text{s.t.}\;&1.015905804200365\,x_0-1.075563368516513\,x_1+1.354422581651652\,x_2+1.231175719391763\,x_3-0.5695498149899738\,x_4-0.0845431272925385\,x_5-0.945839019408856\,x_6=-0.0350333551254621\\
&0.1021906812588868\,x_0+1.017649603494175\,x_1+0.7113625469010652\,x_2-0.7845975403828425\,x_3-0.1330475619361555\,x_4-0.2027851245783147\,x_5-0.4907635167746233\,x_6=-0.0890746280206778\\
&-0.0691151611879505\,x_0-0.1726234142770679\,x_1+0.7490870928543292\,x_2-0.0017337760468129\,x_3-0.9675143456769632\,x_4-0.6700478590428591\,x_5-0.3470673767061095\,x_6=-2.198650485794045\\
&-0.1853251444505973\,x_0-1.849600638660094\,x_1-1.508370034295556\,x_2-0.9668525673953132\,x_3-1.21156196565678\,x_4-0.6645469549418966\,x_5+1.661638743910969\,x_6=-4.829481983044288\\
&0.8891607518271019\,x_0+0.8384286881235276\,x_1-0.8035031028628979\,x_2-1.092054353478263\,x_3+0.3420691219898985\,x_4+0.1291789846691225\,x_5+2.02029578986399\,x_6=0.8991262576526948\\
&0.1370623147413594\,x_0-0.0955523959954012\,x_1-0.1070159267992108\,x_2-0.044283559484152\,x_3+0.2052751838377566\,x_4-0.0472147055355524\,x_5+0.0263779101242163\,x_6+y_{0,0}=-0.1372906598086168\\
&-0.0864033173525697\,x_0-0.0242389263268966\,x_1+0.0198400163659476\,x_2-0.0529154412212283\,x_3+0.0919575570765138\,x_4-0.0465630198887696\,x_5-0.0415047822548149\,x_6+y_{0,1}=-0.1090956146371356\\
&-0.0493566419623072\,x_0+0.0190877037065351\,x_1-0.0625676089375108\,x_2+0.0152602958492\,x_3-0.00439851178580794\,x_4+0.1593300015509853\,x_5+0.1099457671812097\,x_6+y_{0,2}=-0.018160978920798\\
&2.17906321051382\,x_0+0.2404505380691451\,x_1-1.273156876389871\,x_2-1.521652877877997\,x_3-0.9431372726898773\,x_4-0.9371176801678375\,x_5-1.072428152750414\,x_6+t_{0,0}=1.636356226721274\\
&-t_{0,0}^2+y_{0,0}^2+y_{0,1}^2+y_{0,2}^2\le0\\
&x_0,x_1,x_2,x_3,x_4,x_5,x_6,y_{0,0},y_{0,1},y_{0,2},t_{0,0}\in\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Optimization_Model"")

# Decision variables
x0 = m.addVar(name=""x0"")
x1 = m.addVar(name=""x1"")
x2 = m.addVar(name=""x2"")
x3 = m.addVar(name=""x3"")
x4 = m.addVar(name=""x4"")
x5 = m.addVar(name=""x5"")
x6 = m.addVar(name=""x6"")
y00 = m.addVar(name=""y00"")
y01 = m.addVar(name=""y01"")
y02 = m.addVar(name=""y02"")
t00 = m.addVar(name=""t00"")

# Objective function
m.setObjective(
    -0.2747522145296182 * x0
    - 1.766479699359979 * x1
    + 0.7843967105070561 * x2
    + 0.1559911408895964 * x3
    - 0.891327664664444 * x4
    - 0.2108190112467947 * x5
    - 0.4779719262070241 * x6,
    GRB.MINIMIZE
)

# Linear equality constraints
m.addConstr(1.015905804200365 * x0
            - 1.075563368516513 * x1
            + 1.354422581651652 * x2
            + 1.231175719391763 * x3
            - 0.5695498149899738 * x4
            - 0.0845431272925385 * x5
            - 0.945839019408856 * x6 == -0.0350333551254621,
            name=""c1"")

m.addConstr(0.1021906812588868 * x0
            + 1.017649603494175 * x1
            + 0.7113625469010652 * x2
            - 0.7845975403828425 * x3
            - 0.1330475619361555 * x4
            - 0.2027851245783147 * x5
            - 0.4907635167746233 * x6 == -0.0890746280206778,
            name=""c2"")

m.addConstr(-0.0691151611879505 * x0
            - 0.1726234142770679 * x1
            + 0.7490870928543292 * x2
            - 0.0017337760468129 * x3
            - 0.9675143456769632 * x4
            - 0.6700478590428591 * x5
            - 0.3470673767061095 * x6 == -2.198650485794045,
            name=""c3"")

m.addConstr(-0.1853251444505973 * x0
            - 1.849600638660094 * x1
            - 1.508370034295556 * x2
            - 0.9668525673953132 * x3
            - 1.21156196565678 * x4
            - 0.6645469549418966 * x5
            + 1.661638743910969 * x6 == -4.829481983044288,
            name=""c4"")

m.addConstr(0.8891607518271019 * x0
            + 0.8384286881235276 * x1
            - 0.8035031028628979 * x2
            - 1.092054353478263 * x3
            + 0.3420691219898985 * x4
            + 0.1291789846691225 * x5
            + 2.02029578986399 * x6 == 0.8991262576526948,
            name=""c5"")

m.addConstr(0.1370623147413594 * x0
            - 0.0955523959954012 * x1
            - 0.1070159267992108 * x2
            - 0.044283559484152 * x3
            + 0.2052751838377566 * x4
            - 0.0472147055355524 * x5
            + 0.0263779101242163 * x6
            + y00 == -0.1372906598086168,
            name=""c6"")

m.addConstr(-0.0864033173525697 * x0
            - 0.0242389263268966 * x1
            + 0.0198400163659476 * x2
            - 0.0529154412212283 * x3
            + 0.0919575570765138 * x4
            - 0.0465630198887696 * x5
            - 0.0415047822548149 * x6
            + y01 == -0.1090956146371356,
            name=""c7"")

m.addConstr(-0.0493566419623072 * x0
            + 0.0190877037065351 * x1
            - 0.0625676089375108 * x2
            + 0.0152602958492 * x3
            - 0.00439851178580794 * x4
            + 0.1593300015509853 * x5
            + 0.1099457671812097 * x6
            + y02 == -0.018160978920798,
            name=""c8"")

m.addConstr(2.17906321051382 * x0
            + 0.2404505380691451 * x1
            - 1.273156876389871 * x2
            - 1.521652877877997 * x3
            - 0.9431372726898773 * x4
            - 0.9371176801678375 * x5
            - 1.072428152750414 * x6
            + t00 == 1.636356226721274,
            name=""c9"")

# Quadratic constraint: -t00^2 + y00^2 + y01^2 + y02^2 <= 0
m.addQConstr(
    -t00 * t00 + y00 * y00 + y01 * y01 + y02 * y02 <= 0,
    name=""q1""
)

# Optimize
m.optimize()

# Print solution
if m.status == GRB.OPTIMAL:
    print(""Optimal objective:"", m.objVal)
    for v in m.getVars():
        print(f""{v.varName} = {v.x}"")",,-3.740022,0,,,,,,,,
"The production manager must determine the optimal levels of three components, referred to as Component A, Component B, and Component C, to minimize the objective function defined by 1.069640799533941 times the level of Component A minus 1.616200142169644 times the level of Component B minus 1.486492226609768 times the level of Component C. The production levels of Components A, B, and C, as well as the auxiliary variables y_0[0], y_0[1], y_0[2], y_0[3], and t_0[0], are free to vary, and the process is subject to several constraints.

First, the production levels must satisfy three linear equality constraints. The first requires that -1.44151739228461 times the level of Component A plus 3.168186412960231 times the level of Component B minus 1.939318306738097 times the level of Component C equals -0.1920883547257966. The second requires that -2.518157292057484 times the level of Component A minus 0.045850744657515 times the level of Component B plus 0.8181912066930375 times the level of Component C equals 4.883115462374718. The third requires that -1.850469185521618 times the level of Component A plus 0.4312499690020329 times the level of Component B minus 0.7557135832325144 times the level of Component C equals 0.092955763950354.

Additionally, the production process involves four auxiliary variables, y_0[0], y_0[1], y_0[2], and y_0[3], which must satisfy four resource allocation constraints. The first requires that -0.0609720704349455 times the level of Component A plus 0.0577626224097794 times the level of Component B plus 0.1279201721670446 times the level of Component C plus y_0[0] equals 0.1618518754288826. The second requires that -0.033065184399102 times the level of Component A plus 0.0448028105084557 times the level of Component B minus 0.1129590164777731 times the level of Component C plus y_0[1] equals -0.0270310934062265. The third requires that 0.084397043540958 times the level of Component A plus 0.0393016756676922 times the level of Component B plus 0.0346841557930454 times the level of Component C plus y_0[2] equals -0.0279180675961654. The fourth requires that 0.0184000253815845 times the level of Component A minus 0.00348695513114734 times the level of Component B minus 0.069624774030688 times the level of Component C plus y_0[3] equals 0.1874514710284287.

A second-order cone constraint must also be satisfied, where the sum of the squares of y_0[0], y_0[1], y_0[2], and y_0[3] minus the square of t_0[0] must be less than or equal to zero. The variable t_0[0] is determined by the production levels of Components A, B, and C, such that -0.4776208627305155 times the level of Component A minus 0.0366363201101301 times the level of Component B minus 0.5186224190772866 times the level of Component C plus t_0[0] equals 0.309414690634093.

The objective is to minimize the value of the objective function while satisfying all the above constraints and ensuring that the levels of Components A, B, and C, as well as the auxiliary variables y_0[0], y_0[1], y_0[2], y_0[3], and t_0[0], are free to vary within the given constraints. This problem is a Second-Order Cone Programming (SOCP) problem, characterized by the second-order cone constraint that ties the auxiliary variables together in a specific relationship.","\[
\begin{aligned}
\min\;& 1.069640799533941\,A \;-\; 1.616200142169644\,B \;-\; 1.486492226609768\,C \\[4pt]
\text{s.t.}\;& -1.44151739228461\,A \;+\; 3.168186412960231\,B \;-\; 1.939318306738097\,C \;=\; -0.1920883547257966 \\[2pt]
& -2.518157292057484\,A \;-\; 0.045850744657515\,B \;+\; 0.8181912066930375\,C \;=\; 4.883115462374718 \\[2pt]
& -1.850469185521618\,A \;+\; 0.4312499690020329\,B \;-\; 0.7557135832325144\,C \;=\; 0.092955763950354 \\[4pt]
& -0.0609720704349455\,A \;+\; 0.0577626224097794\,B \;+\; 0.1279201721670446\,C \;+\; y_{0,0} \;=\; 0.1618518754288826 \\[2pt]
& -0.033065184399102\,A \;+\; 0.0448028105084557\,B \;-\; 0.1129590164777731\,C \;+\; y_{0,1} \;=\; -0.0270310934062265 \\[2pt]
& 0.084397043540958\,A \;+\; 0.0393016756676922\,B \;+\; 0.0346841557930454\,C \;+\; y_{0,2} \;=\; -0.0279180675961654 \\[2pt]
& 0.0184000253815845\,A \;-\; 0.00348695513114734\,B \;-\; 0.069624774030688\,C \;+\; y_{0,3} \;=\; 0.1874514710284287 \\[4pt]
& y_{0,0}^{2} + y_{0,1}^{2} + y_{0,2}^{2} + y_{0,3}^{2} \;\le\; t_{0,0}^{2} \\[2pt]
& -0.4776208627305155\,A \;-\; 0.0366363201101301\,B \;-\; 0.5186224190772866\,C \;+\; t_{0,0} \;=\; 0.309414690634093 \\[4pt]
& A,B,C,y_{0,0},y_{0,1},y_{0,2},y_{0,3},t_{0,0}\;\in\;\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Optimization_Model"")

# Decision variables
A = m.addVar(vtype=GRB.CONTINUOUS, name=""A"")
B = m.addVar(vtype=GRB.CONTINUOUS, name=""B"")
C = m.addVar(vtype=GRB.CONTINUOUS, name=""C"")
y00 = m.addVar(vtype=GRB.CONTINUOUS, name=""y00"")
y01 = m.addVar(vtype=GRB.CONTINUOUS, name=""y01"")
y02 = m.addVar(vtype=GRB.CONTINUOUS, name=""y02"")
y03 = m.addVar(vtype=GRB.CONTINUOUS, name=""y03"")
t00 = m.addVar(vtype=GRB.CONTINUOUS, name=""t00"")

# Objective function
m.setObjective(1.069640799533941*A - 1.616200142169644*B - 1.486492226609768*C, GRB.MINIMIZE)

# Linear equality constraints
m.addConstr(-1.44151739228461*A + 3.168186412960231*B - 1.939318306738097*C == -0.1920883547257966, name=""eq1"")
m.addConstr(-2.518157292057484*A - 0.045850744657515*B + 0.8181912066930375*C == 4.883115462374718, name=""eq2"")
m.addConstr(-1.850469185521618*A + 0.4312499690020329*B - 0.7557135832325144*C == 0.092955763950354, name=""eq3"")
m.addConstr(-0.0609720704349455*A + 0.0577626224097794*B + 0.1279201721670446*C + y00 == 0.1618518754288826, name=""eq4"")
m.addConstr(-0.033065184399102*A + 0.0448028105084557*B - 0.1129590164777731*C + y01 == -0.0270310934062265, name=""eq5"")
m.addConstr(0.084397043540958*A + 0.0393016756676922*B + 0.0346841557930454*C + y02 == -0.0279180675961654, name=""eq6"")
m.addConstr(0.0184000253815845*A - 0.00348695513114734*B - 0.069624774030688*C + y03 == 0.1874514710284287, name=""eq7"")
m.addConstr(-0.4776208627305155*A - 0.0366363201101301*B - 0.5186224190772866*C + t00 == 0.309414690634093, name=""eq8"")

# Quadratic constraint
m.addQConstr(y00*y00 + y01*y01 + y02*y02 + y03*y03 <= t00*t00, name=""quad"")

# Optimize
m.optimize()

# Print results
if m.status == GRB.OPTIMAL:
    print(f""A = {A.X:.6f}"")
    print(f""B = {B.X:.6f}"")
    print(f""C = {C.X:.6f}"")
    print(f""y00 = {y00.X:.6f}"")
    print(f""y01 = {y01.X:.6f}"")
    print(f""y02 = {y02.X:.6f}"")
    print(f""y03 = {y03.X:.6f}"")
    print(f""t00 = {t00.X:.6f}"")
    print(f""Objective = {m.objVal:.6f}"")",,-7.7565049,0,,,,,,,,
"Minimize the objective function with cost coefficients -0.1919592146476727 for x[0], -1.473647303839492 for x[1], and 2.304735407761341 for x[2]. The problem is subject to three strict equality constraints: (1) -1.635895473616174 x[0] - 0.3973211001807447 x[1] + 0.9471007364101932 x[2] must equal -1.151224267166901, labeled as linear_eq[0]; (2) -0.5249535603075616 x[0] + 0.3668073807989349 x[1] - 0.7858336216136411 x[2] must equal 0.2111440590441619, labeled as linear_eq[1]; and (3) -1.91474276776438 x[0] - 0.0172618223950067 x[1] - 0.4534063203075578 x[2] must equal -0.0637133383926026, labeled as linear_eq[2].

Additionally, four auxiliary variables y_0[0], y_0[1], y_0[2], and y_0[3] are introduced, each subject to linear constraints: (1) -0.1884394252535835 x[0] + 0.0177104249784969 x[1] + 0.0986130842848287 x[2] + y_0[0] must equal 0.0043955531724021, labeled as R3; (2) -0.0708818331240574 x[0] - 0.0215819660876361 x[1] - 0.0616654799104094 x[2] + y_0[1] must equal 0.0879019749446116, labeled as R4; (3) -0.0907143884234421 x[0] + 0.0750697315409076 x[1] - 0.1169779589661307 x[2] + y_0[2] must equal 0.0357726532121181, labeled as R5; and (4) -0.1820309484664378 x[0] + 0.0261698752429371 x[1] + 0.0667294286775777 x[2] + y_0[3] must equal 0.0118088378651355, labeled as R6.

A decision variable t_0[0] is introduced, subject to the constraint -0.2396501315769039 x[0] + 0.3255209569765619 x[1] + 0.2624492403208943 x[2] + t_0[0] must equal 1.588464205354944, labeled as R7. A second-order cone constraint labeled as qc0 is imposed, ensuring that the sum of the squares of y_0[0], y_0[1], y_0[2], and y_0[3] does not exceed the square of t_0[0], expressed as - t_0[0]^2 + y_0[0]^2 + y_0[1]^2 + y_0[2]^2 + y_0[3]^2 <= 0. All decision variables, including x[0], x[1], x[2], y_0[0], y_0[1], y_0[2], y_0[3], and t_0[0], are free to take any real value. The goal is to determine the optimal values for these variables to minimize the objective function while satisfying all constraints. This is a Second-Order Cone Programming (SOCP) problem.","\[
\begin{aligned}
\min\;& -0.1919592146476727\,x_0 \;-\;1.473647303839492\,x_1 \;+\;2.304735407761341\,x_2\\
\text{s.t.}\;& -1.635895473616174\,x_0 \;-\;0.3973211001807447\,x_1 \;+\;0.9471007364101932\,x_2 \;=\; -1.151224267166901\\
& -0.5249535603075616\,x_0 \;+\;0.3668073807989349\,x_1 \;-\;0.7858336216136411\,x_2 \;=\; 0.2111440590441619\\
& -1.91474276776438\,x_0 \;-\;0.0172618223950067\,x_1 \;-\;0.4534063203075578\,x_2 \;=\; -0.0637133383926026\\
& -0.1884394252535835\,x_0 \;+\;0.0177104249784969\,x_1 \;+\;0.0986130842848287\,x_2 \;+\;y_{0,0} \;=\; 0.0043955531724021\\
& -0.0708818331240574\,x_0 \;-\;0.0215819660876361\,x_1 \;-\;0.0616654799104094\,x_2 \;+\;y_{0,1} \;=\; 0.0879019749446116\\
& -0.0907143884234421\,x_0 \;+\;0.0750697315409076\,x_1 \;-\;0.1169779589661307\,x_2 \;+\;y_{0,2} \;=\; 0.0357726532121181\\
& -0.1820309484664378\,x_0 \;+\;0.0261698752429371\,x_1 \;+\;0.0667294286775777\,x_2 \;+\;y_{0,3} \;=\; 0.0118088378651355\\
& -0.2396501315769039\,x_0 \;+\;0.3255209569765619\,x_1 \;+\;0.2624492403208943\,x_2 \;+\;t_{0,0} \;=\; 1.588464205354944\\
& \sqrt{\,y_{0,0}^2 + y_{0,1}^2 + y_{0,2}^2 + y_{0,3}^2\,}\;\le\; t_{0,0}\\
& x_0,x_1,x_2,y_{0,0},y_{0,1},y_{0,2},y_{0,3},t_{0,0}\;\in\;\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

m = gp.Model(""Optimization"")

x0 = m.addVar(vtype=GRB.CONTINUOUS, name=""x0"")
x1 = m.addVar(vtype=GRB.CONTINUOUS, name=""x1"")
x2 = m.addVar(vtype=GRB.CONTINUOUS, name=""x2"")
y00 = m.addVar(vtype=GRB.CONTINUOUS, name=""y00"")
y01 = m.addVar(vtype=GRB.CONTINUOUS, name=""y01"")
y02 = m.addVar(vtype=GRB.CONTINUOUS, name=""y02"")
y03 = m.addVar(vtype=GRB.CONTINUOUS, name=""y03"")
t00 = m.addVar(vtype=GRB.CONTINUOUS, name=""t00"")

m.setObjective(-0.1919592146476727*x0 - 1.473647303839492*x1 + 2.304735407761341*x2, GRB.MINIMIZE)

m.addConstr(-1.635895473616174*x0 - 0.3973211001807447*x1 + 0.9471007364101932*x2 == -1.151224267166901, name=""c1"")
m.addConstr(-0.5249535603075616*x0 + 0.3668073807989349*x1 - 0.7858336216136411*x2 == 0.2111440590441619, name=""c2"")
m.addConstr(-1.91474276776438*x0 - 0.0172618223950067*x1 - 0.4534063203075578*x2 == -0.0637133383926026, name=""c3"")
m.addConstr(-0.1884394252535835*x0 + 0.0177104249784969*x1 + 0.0986130842848287*x2 + y00 == 0.0043955531724021, name=""c4"")
m.addConstr(-0.0708818331240574*x0 - 0.0215819660876361*x1 - 0.0616654799104094*x2 + y01 == 0.0879019749446116, name=""c5"")
m.addConstr(-0.0907143884234421*x0 + 0.0750697315409076*x1 - 0.1169779589661307*x2 + y02 == 0.0357726532121181, name=""c6"")
m.addConstr(-0.1820309484664378*x0 + 0.0261698752429371*x1 + 0.0667294286775777*x2 + y03 == 0.0118088378651355, name=""c7"")
m.addConstr(-0.2396501315769039*x0 + 0.3255209569765619*x1 + 0.2624492403208943*x2 + t00 == 1.588464205354944, name=""c8"")

m.addConstr(t00 >= 0, name=""t_nonneg"")
m.addConstr(gp.quicksum([y00*y00, y01*y01, y02*y02, y03*y03]) <= t00*t00, name=""norm_constraint"")

m.optimize()

if m.status == GRB.OPTIMAL:
    print(f""x0={x0.X:.6f}, x1={x1.X:.6f}, x2={x2.X:.6f}"")
    print(f""y00={y00.X:.6f}, y01={y01.X:.6f}, y02={y02.X:.6f}, y03={y03.X:.6f}"")
    print(f""t00={t00.X:.6f}"")
    print(f""Objective={m.objVal:.6f}"")",,-0.5553453,0,,,,,,,,
"Minimize the objective function defined as 1.416733013504254 times the first decision variable minus 1.637403309183765 times the second decision variable plus 0.4022638456918747 times the third decision variable. The problem includes three linear equality constraints: the first equality constraint specifies that 0.1616012453467476 times the first variable minus 0.8306137706187448 times the second variable minus 0.1515288797410668 times the third variable equals -1.643419668997376. The second equality constraint specifies that 1.456169241005894 times the first variable plus 0.5395849002520692 times the second variable minus 0.8149223903970267 times the third variable equals 1.699940269626918. The third equality constraint specifies that 0.4277456985899902 times the first variable minus 0.5463295579766617 times the second variable plus 1.434710626115096 times the third variable equals -3.331337036084423.

There are ten linear constraints involving auxiliary and throughput variables. The first three constraints involve the first set of auxiliary variables: the first constraint specifies that 0.0771566555713033 times the first variable plus 0.1116037485944799 times the second variable minus 0.0869350722337483 times the third variable plus the first auxiliary variable equals 0.0620112102329036. The second constraint specifies that 0.0616561304966069 times the first variable minus 0.0974104451697517 times the second variable plus 0.0731223386150885 times the third variable plus the second auxiliary variable equals -0.0587197478672789. The third constraint specifies that -0.0081168698754745 times the first variable plus 0.1006466302551332 times the second variable plus 0.0871949253632896 times the third variable plus the third auxiliary variable equals 0.1492287513423473. The fourth constraint involves the first throughput variable and specifies that 0.7878086620078162 times the first variable minus 1.237192350711952 times the second variable plus 0.0891701482981527 times the third variable plus the first throughput variable equals 0.0451513700840946.

The next three constraints involve the second set of auxiliary variables: the fifth constraint specifies that -0.0877923363815518 times the first variable plus 0.0435833077366723 times the second variable plus 0.2441522313227069 times the third variable plus the fourth auxiliary variable equals -0.0455285314769021. The sixth constraint specifies that 0.1269499650822233 times the first variable minus 0.1249417310147306 times the second variable plus 0.0823756522034219 times the third variable plus the fifth auxiliary variable equals 0.1088319552421044. The seventh constraint specifies that -6.71937e-07 times the first variable plus 0.1218393680025435 times the second variable plus 0.1838094221276996 times the third variable plus the sixth auxiliary variable equals -0.0248992942856434. The eighth constraint involves the second throughput variable and specifies that 1.611447749097356 times the first variable minus 0.9783611539447722 times the second variable minus 0.3250051330062018 times the third variable plus the second throughput variable equals 0.8152009008108351.

Two second-order cone constraints are included: the first specifies that the square of the first throughput variable subtracted from the sum of the squares of the first three auxiliary variables must be less than or equal to zero. The second specifies that the square of the second throughput variable subtracted from the sum of the squares of the second three auxiliary variables must be less than or equal to zero. All decision variables, auxiliary variables, and throughput variables are unrestricted in sign and can take any real value.","\begin{align*}
\min\;& 1.416733013504254\,x_1 - 1.637403309183765\,x_2 + 0.4022638456918747\,x_3\\
\text{s.t.}\;& 0.1616012453467476\,x_1 - 0.8306137706187448\,x_2 - 0.1515288797410668\,x_3 = -1.643419668997376\\
& 1.456169241005894\,x_1 + 0.5395849002520692\,x_2 - 0.8149223903970267\,x_3 = 1.699940269626918\\
& 0.4277456985899902\,x_1 - 0.5463295579766617\,x_2 + 1.434710626115096\,x_3 = -3.331337036084423\\
& 0.0771566555713033\,x_1 + 0.1116037485944799\,x_2 - 0.0869350722337483\,x_3 + u_1 = 0.0620112102329036\\
& 0.0616561304966069\,x_1 - 0.0974104451697517\,x_2 + 0.0731223386150885\,x_3 + u_2 = -0.0587197478672789\\
& -0.0081168698754745\,x_1 + 0.1006466302551332\,x_2 + 0.0871949253632896\,x_3 + u_3 = 0.1492287513423473\\
& 0.7878086620078162\,x_1 - 1.237192350711952\,x_2 + 0.0891701482981527\,x_3 + t_1 = 0.0451513700840946\\
& -0.0877923363815518\,x_1 + 0.0435833077366723\,x_2 + 0.2441522313227069\,x_3 + u_4 = -0.0455285314769021\\
& 0.1269499650822233\,x_1 - 0.1249417310147306\,x_2 + 0.0823756522034219\,x_3 + u_5 = 0.1088319552421044\\
& -6.71937\times10^{-7}\,x_1 + 0.1218393680025435\,x_2 + 0.1838094221276996\,x_3 + u_6 = -0.0248992942856434\\
& 1.611447749097356\,x_1 - 0.9783611539447722\,x_2 - 0.3250051330062018\,x_3 + t_2 = 0.8152009008108351\\
& u_1^2 + u_2^2 + u_3^2 - t_1^2 \le 0\\
& u_4^2 + u_5^2 + u_6^2 - t_2^2 \le 0\\
& x_1,x_2,x_3,u_1,u_2,u_3,u_4,u_5,u_6,t_1,t_2 \in \mathbb{R}
\end{align*}","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Quadratic_Optimization"")

# Decision variables
x1 = m.addVar(vtype=GRB.CONTINUOUS, name=""x1"")
x2 = m.addVar(vtype=GRB.CONTINUOUS, name=""x2"")
x3 = m.addVar(vtype=GRB.CONTINUOUS, name=""x3"")
u1 = m.addVar(vtype=GRB.CONTINUOUS, name=""u1"")
u2 = m.addVar(vtype=GRB.CONTINUOUS, name=""u2"")
u3 = m.addVar(vtype=GRB.CONTINUOUS, name=""u3"")
u4 = m.addVar(vtype=GRB.CONTINUOUS, name=""u4"")
u5 = m.addVar(vtype=GRB.CONTINUOUS, name=""u5"")
u6 = m.addVar(vtype=GRB.CONTINUOUS, name=""u6"")
t1 = m.addVar(vtype=GRB.CONTINUOUS, name=""t1"")
t2 = m.addVar(vtype=GRB.CONTINUOUS, name=""t2"")

# Objective function
m.setObjective(1.416733013504254*x1 - 1.637403309183765*x2 + 0.4022638456918747*x3, GRB.MINIMIZE)

# Linear equality constraints
m.addConstr(0.1616012453467476*x1 - 0.8306137706187448*x2 - 0.1515288797410668*x3 == -1.643419668997376, name=""eq1"")
m.addConstr(1.456169241005894*x1 + 0.5395849002520692*x2 - 0.8149223903970267*x3 == 1.699940269626918, name=""eq2"")
m.addConstr(0.4277456985899902*x1 - 0.5463295579766617*x2 + 1.434710626115096*x3 == -3.331337036084423, name=""eq3"")
m.addConstr(0.0771566555713033*x1 + 0.1116037485944799*x2 - 0.0869350722337483*x3 + u1 == 0.0620112102329036, name=""eq4"")
m.addConstr(0.0616561304966069*x1 - 0.0974104451697517*x2 + 0.0731223386150885*x3 + u2 == -0.0587197478672789, name=""eq5"")
m.addConstr(-0.0081168698754745*x1 + 0.1006466302551332*x2 + 0.0871949253632896*x3 + u3 == 0.1492287513423473, name=""eq6"")
m.addConstr(0.7878086620078162*x1 - 1.237192350711952*x2 + 0.0891701482981527*x3 + t1 == 0.0451513700840946, name=""eq7"")
m.addConstr(-0.0877923363815518*x1 + 0.0435833077366723*x2 + 0.2441522313227069*x3 + u4 == -0.0455285314769021, name=""eq8"")
m.addConstr(0.1269499650822233*x1 - 0.1249417310147306*x2 + 0.0823756522034219*x3 + u5 == 0.1088319552421044, name=""eq9"")
m.addConstr(-6.71937e-7*x1 + 0.1218393680025435*x2 + 0.1838094221276996*x3 + u6 == -0.0248992942856434, name=""eq10"")
m.addConstr(1.611447749097356*x1 - 0.9783611539447722*x2 - 0.3250051330062018*x3 + t2 == 0.8152009008108351, name=""eq11"")

# Quadratic constraints
m.addQConstr(u1*u1 + u2*u2 + u3*u3 - t1*t1 <= 0, name=""quad1"")
m.addQConstr(u4*u4 + u5*u5 + u6*u6 - t2*t2 <= 0, name=""quad2"")

# Optimize
m.optimize()
",,-4.6516953,0,,,,,,,,
"The goal is to minimize the total cost determined by the weighted sum of resources \( x[0] \), \( x[1] \), and \( x[2] \), where \( x[0] \) contributes 1.161237384198499 units of cost per unit allocated, \( x[1] \) reduces the cost by 0.166305801898613 units per unit allocated, and \( x[2] \) reduces the cost by 0.4010222263993871 units per unit allocated. The allocation must satisfy four strict equality conditions: the first requires -0.8171434027373111 units of \( x[0] \), 0.0148992990791839 units of \( x[1] \), and -1.624552817012578 units of \( x[2] \) to equal -2.266806032684915; the second requires 0.5642952588239045 units of \( x[0] \), -1.323990231764886 units of \( x[1] \), and 1.432095008297531 units of \( x[2] \) to equal 2.393666956177287; the third requires -0.5423126832826126 units of \( x[0] \), -0.6668037930363615 units of \( x[1] \), and -0.8987771739249211 units of \( x[2] \) to equal -1.048625110146119; and the fourth requires 0.398575737860184 units of \( x[0] \), -1.340131134270142 units of \( x[1] \), and 0.3595004047412258 units of \( x[2] \) to equal 0.8340459801039611.

Additional constraints involve auxiliary variables \( y_0[0] \) to \( y_0[3] \), \( y_1[0] \) to \( y_1[3] \), \( y_2[0] \) to \( y_2[3] \), and \( t_0[0] \), \( t_1[0] \), \( t_2[0] \). For the first set, \( y_0[0] \) is determined by -0.0790956451487926 units of \( x[0] \), -0.00177045180427562 units of \( x[1] \), and -0.0135101531022542 units of \( x[2] \), equal to 4.3318049409104566e-04; \( y_0[1] \) is determined by -0.1888423336020157 units of \( x[0] \), 0.0468378089437413 units of \( x[1] \), and 0.0422915893690382 units of \( x[2] \), equal to -0.057473642380715; \( y_0[2] \) is determined by 0.1111684227208376 units of \( x[0] \), 0.1168866454616669 units of \( x[1] \), and 0.00994317726502118 units of \( x[2] \), equal to -0.0027025235150565; \( y_0[3] \) is determined by -0.1003054361114799 units of \( x[0] \), -0.1074280721090408 units of \( x[1] \), and 0.0347646765882297 units of \( x[2] \), equal to -0.0187719281760365; \( t_0[0] \) is determined by -0.0923314568919683 units of \( x[0] \), 0.3059364524963586 units of \( x[1] \), and -0.4891183949819865 units of \( x[2] \), equal to 1.559548175449872.

For \( y_1[0] \), the sum is 0.0983461752470471, determined by 0.0260300607215097 units of \( x[0] \), 0.104222743854305 units of \( x[1] \), and 0.165095052940775 units of \( x[2] \); \( y_1[1] \) sums to 0.2590974156103631, determined by 3.9617645465962872e-04 units of \( x[0] \), -0.0842482365695222 units of \( x[1] \), and 0.2115742333860741 units of \( x[2] \); \( y_1[2] \) sums to 0.0656791263260323, determined by 0.0469551281711486 units of \( x[0] \), -0.0279863701043123 units of \( x[1] \), and -0.2267772085587545 units of \( x[2] \); \( y_1[3] \) sums to 0.0925284262906007, determined by -0.00769378398286824 units of \( x[0] \), -0.1620714406841336 units of \( x[1] \), and -0.137052404669175 units of \( x[2] \); \( t_1[0] \) sums to 0.9781052631063663, determined by -0.4553968316872111 units of \( x[0] \), -0.8477088153755726 units of \( x[1] \), and -0.4607927423478093 units of \( x[2] \).

For \( y_2[0] \), the sum is -0.0316470399294818, determined by -0.0587561844433846 units of \( x[0] \), -0.0374159998289655 units of \( x[1] \), and -0.1432421286622242 units of \( x[2] \); \( y_2[1] \) sums to 0.1193203771742649, determined by -0.0483997505258602 units of \( x[0] \), 0.1896458148433305 units of \( x[1] \), and -0.0709856184240573 units of \( x[2] \); \( y_2[2] \) sums to 0.0249940394491055, determined by 0.0846693606546272 units of \( x[0] \), 0.0686759181099283 units of \( x[1] \), and -0.0216946264193857 units of \( x[2] \); \( y_2[3] \) sums to -0.0230055775535458, determined by 0.2218191833614268 units of \( x[0] \), 0.054166153139831 units of \( x[1] \), and 0.0802604337456637 units of \( x[2] \); \( t_2[0] \) sums to 0.0133770717575745, determined by -2.322162140550891 units of \( x[0] \), 0.6539919936190184 units of \( x[1] \), and -0.5823100315050422 units of \( x[2] \).

The problem also includes second-order cone constraints: the first ensures that the sum of the squares of \( y_0[0] \), \( y_0[1] \), \( y_0[2] \), and \( y_0[3] \) is less than or equal to the square of \( t_0[0] \); the second ensures that the sum of the squares of \( y_1[0] \), \( y_1[1] \), \( y_1[2] \), and \( y_1[3] \) is less than or equal to the square of \( t_1[0] \); the third ensures that the sum of the squares of \( y_2[0] \), \( y_2[1] \), \( y_2[2] \), and \( y_2[3] \) is less than or equal to the square of \( t_2[0] \). All decision variables, including \( x[0] \), \( x[1] \), \( x[2] \), \( y_0[0] \) to \( y_0[3] \), \( y_1[0] \) to \( y_1[3] \), \( y_2[0] \) to \( y_2[3] \), and \( t_0[0] \), \( t_1[0] \), \( t_2[0] \), are free and can take any real value. The task is to allocate resources \( x[0] \), \( x[1] \), and \( x[2] \) to minimize the total cost, while satisfying all equality constraints, resource allocation constraints, and second-order cone constraints. The specific numerical values and relationships provided must be strictly adhered to in order to achieve an optimal solution.","\[
\begin{aligned}
\min\quad & 1.161237384198499\,x_0-0.166305801898613\,x_1-0.4010222263993871\,x_2\\
\text{s.t.}\quad & -0.8171434027373111\,x_0+0.0148992990791839\,x_1-1.624552817012578\,x_2=-2.266806032684915\\
& 0.5642952588239045\,x_0-1.323990231764886\,x_1+1.432095008297531\,x_2=2.393666956177287\\
& -0.5423126832826126\,x_0-0.6668037930363615\,x_1-0.8987771739249211\,x_2=-1.048625110146119\\
& 0.398575737860184\,x_0-1.340131134270142\,x_1+0.3595004047412258\,x_2=0.8340459801039611\\
& y_{0,0}=-0.0790956451487926\,x_0-0.00177045180427562\,x_1-0.0135101531022542\,x_2\\
& y_{0,1}=-0.1888423336020157\,x_0+0.0468378089437413\,x_1+0.0422915893690382\,x_2\\
& y_{0,2}=0.1111684227208376\,x_0+0.1168866454616669\,x_1+0.00994317726502118\,x_2\\
& y_{0,3}=-0.1003054361114799\,x_0-0.1074280721090408\,x_1+0.0347646765882297\,x_2\\
& t_{0,0}=-0.0923314568919683\,x_0+0.3059364524963586\,x_1-0.4891183949819865\,x_2\\
& y_{1,0}=0.0260300607215097\,x_0+0.104222743854305\,x_1+0.165095052940775\,x_2\\
& y_{1,1}=3.9617645465962872\times10^{-4}\,x_0-0.0842482365695222\,x_1+0.2115742333860741\,x_2\\
& y_{1,2}=0.0469551281711486\,x_0-0.0279863701043123\,x_1-0.2267772085587545\,x_2\\
& y_{1,3}=-0.00769378398286824\,x_0-0.1620714406841336\,x_1-0.137052404669175\,x_2\\
& t_{1,0}=-0.4553968316872111\,x_0-0.8477088153755726\,x_1-0.4607927423478093\,x_2\\
& y_{2,0}=-0.0587561844433846\,x_0-0.0374159998289655\,x_1-0.1432421286622242\,x_2\\
& y_{2,1}=-0.0483997505258602\,x_0+0.1896458148433305\,x_1-0.0709856184240573\,x_2\\
& y_{2,2}=0.0846693606546272\,x_0+0.0686759181099283\,x_1-0.0216946264193857\,x_2\\
& y_{2,3}=0.2218191833614268\,x_0+0.054166153139831\,x_1+0.0802604337456637\,x_2\\
& t_{2,0}=-2.322162140550891\,x_0+0.6539919936190184\,x_1-0.5823100315050422\,x_2\\
& y_{0,0}^2+y_{0,1}^2+y_{0,2}^2+y_{0,3}^2\le t_{0,0}^2\\
& y_{1,0}^2+y_{1,1}^2+y_{1,2}^2+y_{1,3}^2\le t_{1,0}^2\\
& y_{2,0}^2+y_{2,1}^2+y_{2,2}^2+y_{2,3}^2\le t_{2,0}^2\\
& x_0,x_1,x_2,y_{0,0},y_{0,1},y_{0,2},y_{0,3},y_{1,0},y_{1,1},y_{1,2},y_{1,3},y_{2,0},y_{2,1},y_{2,2},y_{2,3},t_{0,0},t_{1,0},t_{2,0}\in\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Optimization_Model"")

# Decision variables
x0 = m.addVar(name=""x0"")
x1 = m.addVar(name=""x1"")
x2 = m.addVar(name=""x2"")

y00 = m.addVar(name=""y00"")
y01 = m.addVar(name=""y01"")
y02 = m.addVar(name=""y02"")
y03 = m.addVar(name=""y03"")
y10 = m.addVar(name=""y10"")
y11 = m.addVar(name=""y11"")
y12 = m.addVar(name=""y12"")
y13 = m.addVar(name=""y13"")
y20 = m.addVar(name=""y20"")
y21 = m.addVar(name=""y21"")
y22 = m.addVar(name=""y22"")
y23 = m.addVar(name=""y23"")

t00 = m.addVar(name=""t00"")
t10 = m.addVar(name=""t10"")
t20 = m.addVar(name=""t20"")

# Objective
m.setObjective(1.161237384198499*x0 - 0.166305801898613*x1 - 0.4010222263993871*x2, GRB.MINIMIZE)

# Linear equality constraints
m.addConstr(-0.8171434027373111*x0 + 0.0148992990791839*x1 - 1.624552817012578*x2 == -2.266806032684915, name=""eq1"")
m.addConstr(0.5642952588239045*x0 - 1.323990231764886*x1 + 1.432095008297531*x2 == 2.393666956177287, name=""eq2"")
m.addConstr(-0.5423126832826126*x0 - 0.6668037930363615*x1 - 0.8987771739249211*x2 == -1.048625110146119, name=""eq3"")
m.addConstr(0.398575737860184*x0 - 1.340131134270142*x1 + 0.3595004047412258*x2 == 0.8340459801039611, name=""eq4"")

# Definitions of y variables
m.addConstr(y00 == -0.0790956451487926*x0 - 0.00177045180427562*x1 - 0.0135101531022542*x2, name=""y00_def"")
m.addConstr(y01 == -0.1888423336020157*x0 + 0.0468378089437413*x1 + 0.0422915893690382*x2, name=""y01_def"")
m.addConstr(y02 == 0.1111684227208376*x0 + 0.1168866454616669*x1 + 0.00994317726502118*x2, name=""y02_def"")
m.addConstr(y03 == -0.1003054361114799*x0 - 0.1074280721090408*x1 + 0.0347646765882297*x2, name=""y03_def"")

m.addConstr(y10 == 0.0260300607215097*x0 + 0.104222743854305*x1 + 0.165095052940775*x2, name=""y10_def"")
m.addConstr(y11 == 3.9617645465962872e-04*x0 - 0.0842482365695222*x1 + 0.2115742333860741*x2, name=""y11_def"")
m.addConstr(y12 == 0.0469551281711486*x0 - 0.0279863701043123*x1 - 0.2267772085587545*x2, name=""y12_def"")
m.addConstr(y13 == -0.00769378398286824*x0 - 0.1620714406841336*x1 - 0.137052404669175*x2, name=""y13_def"")

m.addConstr(y20 == -0.0587561844433846*x0 - 0.0374159998289655*x1 - 0.1432421286622242*x2, name=""y20_def"")
m.addConstr(y21 == -0.0483997505258602*x0 + 0.1896458148433305*x1 - 0.0709856184240573*x2, name=""y21_def"")
m.addConstr(y22 == 0.0846693606546272*x0 + 0.0686759181099283*x1 - 0.0216946264193857*x2, name=""y22_def"")
m.addConstr(y23 == 0.2218191833614268*x0 + 0.054166153139831*x1 + 0.0802604337456637*x2, name=""y23_def"")

# Definitions of t variables
m.addConstr(t00 == -0.0923314568919683*x0 + 0.3059364524963586*x1 - 0.4891183949819865*x2, name=""t00_def"")
m.addConstr(t10 == -0.4553968316872111*x0 - 0.8477088153755726*x1 - 0.4607927423478093*x2, name=""t10_def"")
m.addConstr(t20 == -2.322162140550891*x0 + 0.6539919936190184*x1 - 0.5823100315050422*x2, name=""t20_def"")

# Quadratic constraints
m.addQConstr(y00*y00 + y01*y01 + y02*y02 + y03*y03 <= t00*t00, name=""qc0"")
m.addQConstr(y10*y10 + y11*y11 + y12*y12 + y13*y13 <= t10*t10, name=""qc1"")
m.addQConstr(y20*y20 + y21*y21 + y22*y22 + y23*y23 <= t20*t20, name=""qc2"")

# Optimize
m.optimize()

# Print solution
if m.status == GRB.OPTIMAL:
    print(""Optimal objective:"", m.objVal)
    print(""x0 ="", x0.X)
    print(""x1 ="", x1.X)
    print(""x2 ="", x2.X)
    print(""t00 ="", t00.X)
    print(""t10 ="", t10.X)
    print(""t20 ="", t20.X)
else:
    print(""No optimal solution found."")",,-0.768207,0,,,,,,,,
"The problem is a Second-Order Cone Programming (SOCP) problem aimed at minimizing the expression: -0.0834997320390843 multiplied by x[0], minus 1.281157927338681 multiplied by x[1], minus 0.6997343607099248 multiplied by x[2], minus 1.124765322700406 multiplied by x[3], plus 1.075870893520574 multiplied by x[4], minus 0.873635307005547 multiplied by x[5]. The problem includes four linear equality constraints involving the decision variables x[0] through x[5]. The first constraint requires -0.5885607904893205 multiplied by x[0], minus 0.4065465515131446 multiplied by x[1], plus 0.3059688687379479 multiplied by x[2], plus 0.5752454203843212 multiplied by x[3], plus 0.8134273230222456 multiplied by x[4], minus 0.3137959036191741 multiplied by x[5] to equal 0.9326117395439714. The second constraint requires -1.925586727059667 multiplied by x[0], plus 1.52432983869767 multiplied by x[1], plus 0.7056564744559519 multiplied by x[2], plus 0.4429646642871883 multiplied by x[3], minus 1.191971501984802 multiplied by x[4], minus 1.423701744010086 multiplied by x[5] to equal -1.127568679343468. The third constraint specifies 0.3695976409523919 multiplied by x[0], minus 1.172799439640038 multiplied by x[1], plus 2.456480065266749 multiplied by x[2], minus 0.6028161578986598 multiplied by x[3], plus 0.1526235927792681 multiplied by x[4], minus 0.7698423890950179 multiplied by x[5] to equal -0.464660190344107. The fourth constraint mandates -1.43554468908569 multiplied by x[0], plus 1.029767278463664 multiplied by x[1], minus 0.22200928921289 multiplied by x[2], minus 1.475662550421019 multiplied by x[3], minus 0.4673380914761413 multiplied by x[4], plus 1.197928628533288 multiplied by x[5] to equal -1.088009446155389.

There are ten additional linear constraints involving auxiliary variables y_0[0], y_0[1], y_0[2], y_0[3], y_1[0], y_1[1], y_1[2], y_1[3], t_0[0], and t_1[0]. These constraints define specific linear relationships between the decision variables x[0] through x[5] and the auxiliary variables. For example, one constraint requires 0.0893317393307157 multiplied by x[0], plus 0.0150647185847581 multiplied by x[1], plus 0.0261787249528073 multiplied by x[2], plus 0.0752497482880115 multiplied by x[3], plus 0.089362702614514 multiplied by x[4], minus 0.0903365860453957 multiplied by x[5], plus y_0[0] to equal 0.0348229641116467. Another constraint requires 0.0309053187877012 multiplied by x[0], plus 0.024045043885088 multiplied by x[1], plus 0.1070923676270683 multiplied by x[2], plus 0.2073521720181627 multiplied by x[3], minus 0.1770274961116007 multiplied by x[4], minus 0.0922005916406162 multiplied by x[5], plus y_0[1] to equal -0.1872964740542509. A third constraint requires -0.1262388132745864 multiplied by x[0], plus 0.0795068962664749 multiplied by x[1], plus 0.0187856757413385 multiplied by x[2], plus 0.1513494147153156 multiplied by x[3], minus 0.0163664274157314 multiplied by x[4], minus 0.00311286020002606 multiplied by x[5], plus y_0[2] to equal -0.0954444159908309. A fourth constraint requires -0.0757819715079799 multiplied by x[0], plus 0.0919093860274552 multiplied by x[1], minus 0.0364339288064356 multiplied by x[2], plus 0.083580945500982 multiplied by x[3], minus 0.1474689439069835 multiplied by x[4], plus 0.0301651918491998 multiplied by x[5], plus y_0[3] to equal 0.2579565194918507. A fifth constraint requires 0.7572820533712606 multiplied by x[0], minus 1.21352962362722 multiplied by x[1], plus 0.3803676681799136 multiplied by x[2], plus 0.4801395423918295 multiplied by x[3], minus 0.8927539207272388 multiplied by x[4], minus 1.447471364330223 multiplied by x[5], plus t_0[0] to equal 0.683762161476536. A sixth constraint requires -0.039176642120947 multiplied by x[0], minus 0.0594029213045902 multiplied by x[1], plus 0.0203899965676045 multiplied by x[2], minus 0.0006599505607145948 multiplied by x[3], plus 0.1993498474530564 multiplied by x[4], minus 0.1494561245854857 multiplied by x[5], plus y_1[0] to equal -0.0909307736334353. A seventh constraint requires -0.1551511441179779 multiplied by x[0], plus 0.0850834698172653 multiplied by x[1], minus 0.1602283190962608 multiplied by x[2], plus 0.0725598573219744 multiplied by x[3], minus 0.1055576967228311 multiplied by x[4], minus 0.1582958490297426 multiplied by x[5], plus y_1[1] to equal -0.1725026750262158. An eighth constraint requires -0.1933585329412353 multiplied by x[0], plus 0.0929980184151937 multiplied by x[1], plus 0.099592631874656 multiplied by x[2], plus 0.0797650799817848 multiplied by x[3], plus 0.0106313375995685 multiplied by x[4], minus 0.00903979011317048 multiplied by x[5], plus y_1[2] to equal -0.1167161263783248. A ninth constraint requires 0.0230142114746871 multiplied by x[0], plus 0.0796690661109758 multiplied by x[1], plus 0.0216327232273718 multiplied by x[2], minus 0.0337376899834936 multiplied by x[3], minus 0.1518320281674425 multiplied by x[4], plus 0.046720461629375 multiplied by x[5], plus y_1[3] to equal -0.1005698418344237. A tenth constraint requires -0.1501707210081249 multiplied by x[0], plus 0.7058311865593911 multiplied by x[1], plus 1.287754324454335 multiplied by x[2], plus 0.0373827245849037 multiplied by x[3], plus 0.1171725723905398 multiplied by x[4], plus 0.1069533502066662 multiplied by x[5], plus t_1[0] to equal 0.1223510811918817.

Two quadratic cone constraints ensure that the squared sum of y_0[0], y_0[1], y_0[2], and y_0[3] does not exceed the square of t_0[0], and the squared sum of y_1[0], y_1[1], y_1[2], and y_1[3] does not exceed the square of t_1[0]. All variables, including the decision variables x[0] through x[5] and the auxiliary variables y_0[0], y_0[1], y_0[2], y_0[3], y_1[0], y_1[1], y_1[2], y_1[3], t_0[0], and t_1[0], are free to take any real value, with no bounds specified. The goal is to determine the values of these variables that minimize the objective function while satisfying all equality and quadratic cone constraints.","\[
\begin{aligned}
\min\;&-0.0834997320390843\,x_0-1.281157927338681\,x_1-0.6997343607099248\,x_2-1.124765322700406\,x_3\\
&\quad+1.075870893520574\,x_4-0.873635307005547\,x_5\\[4pt]
\text{s.t.}\;&-0.5885607904893205\,x_0-0.4065465515131446\,x_1+0.3059688687379479\,x_2\\
&\quad+0.5752454203843212\,x_3+0.8134273230222456\,x_4-0.3137959036191741\,x_5=0.9326117395439714\\
&-1.925586727059667\,x_0+1.52432983869767\,x_1+0.7056564744559519\,x_2\\
&\quad+0.4429646642871883\,x_3-1.191971501984802\,x_4-1.423701744010086\,x_5=-1.127568679343468\\
&0.3695976409523919\,x_0-1.172799439640038\,x_1+2.456480065266749\,x_2\\
&\quad-0.6028161578986598\,x_3+0.1526235927792681\,x_4-0.7698423890950179\,x_5=-0.464660190344107\\
&-1.43554468908569\,x_0+1.029767278463664\,x_1-0.22200928921289\,x_2\\
&\quad-1.475662550421019\,x_3-0.4673380914761413\,x_4+1.197928628533288\,x_5=-1.088009446155389\\
&0.0893317393307157\,x_0+0.0150647185847581\,x_1+0.0261787249528073\,x_2\\
&\quad+0.0752497482880115\,x_3+0.089362702614514\,x_4-0.0903365860453957\,x_5+y_{0,0}=0.0348229641116467\\
&0.0309053187877012\,x_0+0.024045043885088\,x_1+0.1070923676270683\,x_2\\
&\quad+0.2073521720181627\,x_3-0.1770274961116007\,x_4-0.0922005916406162\,x_5+y_{0,1}=-0.1872964740542509\\
&-0.1262388132745864\,x_0+0.0795068962664749\,x_1+0.0187856757413385\,x_2\\
&\quad+0.1513494147153156\,x_3-0.0163664274157314\,x_4-0.00311286020002606\,x_5+y_{0,2}=-0.0954444159908309\\
&-0.0757819715079799\,x_0+0.0919093860274552\,x_1-0.0364339288064356\,x_2\\
&\quad+0.083580945500982\,x_3-0.1474689439069835\,x_4+0.0301651918491998\,x_5+y_{0,3}=0.2579565194918507\\
&0.7572820533712606\,x_0-1.21352962362722\,x_1+0.3803676681799136\,x_2\\
&\quad+0.4801395423918295\,x_3-0.8927539207272388\,x_4-1.447471364330223\,x_5+t_{0,0}=0.683762161476536\\
&-0.039176642120947\,x_0-0.0594029213045902\,x_1+0.0203899965676045\,x_2\\
&\quad-0.0006599505607145948\,x_3+0.1993498474530564\,x_4-0.1494561245854857\,x_5+y_{1,0}=-0.0909307736334353\\
&-0.1551511441179779\,x_0+0.0850834698172653\,x_1-0.1602283190962608\,x_2\\
&\quad+0.0725598573219744\,x_3-0.1055576967228311\,x_4-0.1582958490297426\,x_5+y_{1,1}=-0.1725026750262158\\
&-0.1933585329412353\,x_0+0.0929980184151937\,x_1+0.099592631874656\,x_2\\
&\quad+0.0797650799817848\,x_3+0.0106313375995685\,x_4-0.00903979011317048\,x_5+y_{1,2}=-0.1167161263783248\\
&0.0230142114746871\,x_0+0.0796690661109758\,x_1+0.0216327232273718\,x_2\\
&\quad-0.0337376899834936\,x_3-0.1518320281674425\,x_4+0.046720461629375\,x_5+y_{1,3}=-0.1005698418344237\\
&-0.1501707210081249\,x_0+0.7058311865593911\,x_1+1.287754324454335\,x_2\\
&\quad+0.0373827245849037\,x_3+0.1171725723905398\,x_4+0.1069533502066662\,x_5+t_{1,0}=0.1223510811918817\\
&\| (y_{0,0},y_{0,1},y_{0,2},y_{0,3}) \|_2 \le t_{0,0}\\
&\| (y_{1,0},y_{1,1},y_{1,2},y_{1,3}) \|_2 \le t_{1,0}\\
&x_0,x_1,x_2,x_3,x_4,x_5,y_{0,0},y_{0,1},y_{0,2},y_{0,3},y_{1,0},y_{1,1},y_{1,2},y_{1,3},t_{0,0},t_{1,0}\in\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

m = gp.Model(""Optimization_Model"")

# Decision variables
x0 = m.addVar(name=""x0"")
x1 = m.addVar(name=""x1"")
x2 = m.addVar(name=""x2"")
x3 = m.addVar(name=""x3"")
x4 = m.addVar(name=""x4"")
x5 = m.addVar(name=""x5"")

y0_0 = m.addVar(name=""y0_0"")
y0_1 = m.addVar(name=""y0_1"")
y0_2 = m.addVar(name=""y0_2"")
y0_3 = m.addVar(name=""y0_3"")

y1_0 = m.addVar(name=""y1_0"")
y1_1 = m.addVar(name=""y1_1"")
y1_2 = m.addVar(name=""y1_2"")
y1_3 = m.addVar(name=""y1_3"")

t0_0 = m.addVar(lb=0, name=""t0_0"")
t1_0 = m.addVar(lb=0, name=""t1_0"")

# Objective
m.setObjective(
    -0.0834997320390843*x0
    -1.281157927338681*x1
    -0.6997343607099248*x2
    -1.124765322700406*x3
    +1.075870893520574*x4
    -0.873635307005547*x5,
    GRB.MINIMIZE
)

# Constraints
m.addConstr(-0.5885607904893205*x0 -0.4065465515131446*x1 +0.3059688687379479*x2
            +0.5752454203843212*x3 +0.8134273230222456*x4 -0.3137959036191741*x5
            == 0.9326117395439714, name=""c1"")

m.addConstr(-1.925586727059667*x0 +1.52432983869767*x1 +0.7056564744559519*x2
            +0.4429646642871883*x3 -1.191971501984802*x4 -1.423701744010086*x5
            == -1.127568679343468, name=""c2"")

m.addConstr(0.3695976409523919*x0 -1.172799439640038*x1 +2.456480065266749*x2
            -0.6028161578986598*x3 +0.1526235927792681*x4 -0.7698423890950179*x5
            == -0.464660190344107, name=""c3"")

m.addConstr(-1.43554468908569*x0 +1.029767278463664*x1 -0.22200928921289*x2
            -1.475662550421019*x3 -0.4673380914761413*x4 +1.197928628533288*x5
            == -1.088009446155389, name=""c4"")

m.addConstr(0.0893317393307157*x0 +0.0150647185847581*x1 +0.0261787249528073*x2
            +0.0752497482880115*x3 +0.089362702614514*x4 -0.0903365860453957*x5
            + y0_0 == 0.0348229641116467, name=""c5"")

m.addConstr(0.0309053187877012*x0 +0.024045043885088*x1 +0.1070923676270683*x2
            +0.2073521720181627*x3 -0.1770274961116007*x4 -0.0922005916406162*x5
            + y0_1 == -0.1872964740542509, name=""c6"")

m.addConstr(-0.1262388132745864*x0 +0.0795068962664749*x1 +0.0187856757413385*x2
            +0.1513494147153156*x3 -0.0163664274157314*x4 -0.00311286020002606*x5
            + y0_2 == -0.0954444159908309, name=""c7"")

m.addConstr(-0.0757819715079799*x0 +0.0919093860274552*x1 -0.0364339288064356*x2
            +0.083580945500982*x3 -0.1474689439069835*x4 +0.0301651918491998*x5
            + y0_3 == 0.2579565194918507, name=""c8"")

m.addConstr(0.7572820533712606*x0 -1.21352962362722*x1 +0.3803676681799136*x2
            +0.4801395423918295*x3 -0.8927539207272388*x4 -1.447471364330223*x5
            + t0_0 == 0.683762161476536, name=""c9"")

m.addConstr(-0.039176642120947*x0 -0.0594029213045902*x1 +0.0203899965676045*x2
            -0.0006599505607145948*x3 +0.1993498474530564*x4 -0.1494561245854857*x5
            + y1_0 == -0.0909307736334353, name=""c10"")

m.addConstr(-0.1551511441179779*x0 +0.0850834698172653*x1 -0.1602283190962608*x2
            +0.0725598573219744*x3 -0.1055576967228311*x4 -0.1582958490297426*x5
            + y1_1 == -0.1725026750262158, name=""c11"")

m.addConstr(-0.1933585329412353*x0 +0.0929980184151937*x1 +0.099592631874656*x2
            +0.0797650799817848*x3 +0.0106313375995685*x4 -0.00903979011317048*x5
            + y1_2 == -0.1167161263783248, name=""c12"")

m.addConstr(0.0230142114746871*x0 +0.0796690661109758*x1 +0.0216327232273718*x2
            -0.0337376899834936*x3 -0.1518320281674425*x4 +0.046720461629375*x5
            + y1_3 == -0.1005698418344237, name=""c13"")

m.addConstr(-0.1501707210081249*x0 +0.7058311865593911*x1 +1.287754324454335*x2
            +0.0373827245849037*x3 +0.1171725723905398*x4 +0.1069533502066662*x5
            + t1_0 == 0.1223510811918817, name=""c14"")

# Quadratic constraints
m.addQConstr(gp.quicksum(y0_0*y0_0, y0_1*y0_1, y0_2*y0_2, y0_3*y0_3) <= t0_0*t0_0, name=""norm_y0"")
m.addQConstr(gp.quicksum(y1_0*y1_0, y1_1*y1_1, y1_2*y1_2, y1_3*y1_3) <= t1_0*t1_0, name=""norm_y1"")

# Optimize
m.optimize()

# Print solution
if m.status == GRB.OPTIMAL:
    print(""Optimal objective:"", m.objVal)
    for v in m.getVars():
        print(f""{v.varName} = {v.x}"")",,-2.0438316,0,,,,,,,,
"The problem involves determining the optimal allocation of five types of resources, represented by variables \( x[0] \) through \( x[4] \), along with auxiliary variables \( y_0[0] \), \( y_0[1] \), and \( t_0[0] \), to minimize the total cost defined by the linear objective function: \( 1.126401441072199 x[0] - 0.3048391076081773 x[1] + 1.210295701208876 x[2] + 0.3629036707879342 x[3] - 1.541074052220742 x[4] \). 

The solution must satisfy four linear equality constraints: the first requires \( -0.9907409502145462 x[0] - 0.7264863472262246 x[1] + 0.2793136098129854 x[2] - 0.9349403902445268 x[3] + 1.444658005223368 x[4] = 1.116201276984661 \); the second requires \( 2.936722209688262 x[0] + 0.5035733953314866 x[1] + 0.3357143231898844 x[2] + 1.112758520098299 x[3] + 1.412597032089028 x[4] = -1.571971227040746 \); the third requires \( 0.7899614064673852 x[0] - 0.0724234240750259 x[1] - 0.7706602505688044 x[2] + 1.907488050972312 x[3] + 1.420058526737699 x[4] = -1.686571012140405 \); and the fourth requires \( 0.6068754572874664 x[0] + 0.7492819480236036 x[1] - 1.565830499338323 x[2] + 0.2718401004423009 x[3] + 0.5510027846961619 x[4] = 4.014442756917189 \).

Additionally, three linear equality constraints, labeled R4, R5, and R6, tie the resource allocations to auxiliary variables \( y_0[0] \), \( y_0[1] \), and \( t_0[0] \): R4 requires \( -0.0124992573250491 x[0] - 0.1193568402945484 x[1] - 0.0200307964468845 x[2] + 0.0612863681420025 x[3] - 0.116537049877206 x[4] + y_0[0] = -0.0358590805559009 \); R5 requires \( 0.0484815211698107 x[0] - 0.0631246556642578 x[1] + 0.1244200448905836 x[2] + 0.0530487576814488 x[3] + 0.1361347655297342 x[4] + y_0[1] = 0.0271906214446268 \); and R6 requires \( -2.249909202694956 x[0] + 0.7776031115768471 x[1] - 0.2174454691465576 x[2] + 1.953508135119546 x[3] + 1.071251451084194 x[4] + t_0[0] = 0.9059772765697818 \).

A second-order cone constraint, labeled \( qc0 \), ensures that the sum of the squares of \( y_0[0] \) and \( y_0[1] \) does not exceed the square of \( t_0[0] \), expressed as \( -t_0[0]^2 + y_0[0]^2 + y_0[1]^2 \leq 0 \). All decision variables, including \( x[0] \) through \( x[4] \), \( y_0[0] \), \( y_0[1] \), and \( t_0[0] \), are unrestricted in sign, meaning they can take any real value to satisfy the constraints and optimize the objective. This is a Second-Order Cone Programming (SOCP) problem that combines linear and quadratic constraints, requiring a balance between resource allocation and auxiliary variables to achieve the optimal solution while minimizing total cost.","\[
\begin{aligned}
\min\;& 1.126401441072199\,x_0 - 0.3048391076081773\,x_1 + 1.210295701208876\,x_2 + 0.3629036707879342\,x_3 - 1.541074052220742\,x_4 \\
\text{s.t.}\;& -0.9907409502145462\,x_0 - 0.7264863472262246\,x_1 + 0.2793136098129854\,x_2 - 0.9349403902445268\,x_3 + 1.444658005223368\,x_4 = 1.116201276984661 \\
& 2.936722209688262\,x_0 + 0.5035733953314866\,x_1 + 0.3357143231898844\,x_2 + 1.112758520098299\,x_3 + 1.412597032089028\,x_4 = -1.571971227040746 \\
& 0.7899614064673852\,x_0 - 0.0724234240750259\,x_1 - 0.7706602505688044\,x_2 + 1.907488050972312\,x_3 + 1.420058526737699\,x_4 = -1.686571012140405 \\
& 0.6068754572874664\,x_0 + 0.7492819480236036\,x_1 - 1.565830499338323\,x_2 + 0.2718401004423009\,x_3 + 0.5510027846961619\,x_4 = 4.014442756917189 \\
& -0.0124992573250491\,x_0 - 0.1193568402945484\,x_1 - 0.0200307964468845\,x_2 + 0.0612863681420025\,x_3 - 0.116537049877206\,x_4 + y_{0,0} = -0.0358590805559009 \\
& 0.0484815211698107\,x_0 - 0.0631246556642578\,x_1 + 0.1244200448905836\,x_2 + 0.0530487576814488\,x_3 + 0.1361347655297342\,x_4 + y_{0,1} = 0.0271906214446268 \\
& -2.249909202694956\,x_0 + 0.7776031115768471\,x_1 - 0.2174454691465576\,x_2 + 1.953508135119546\,x_3 + 1.071251451084194\,x_4 + t_{0,0} = 0.9059772765697818 \\
& -t_{0,0}^2 + y_{0,0}^2 + y_{0,1}^2 \le 0 \\
& x_0,x_1,x_2,x_3,x_4,y_{0,0},y_{0,1},t_{0,0}\in\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Nonlinear_Optimization"")

# Decision variables
x0 = m.addVar(name=""x0"")
x1 = m.addVar(name=""x1"")
x2 = m.addVar(name=""x2"")
x3 = m.addVar(name=""x3"")
x4 = m.addVar(name=""x4"")
y00 = m.addVar(name=""y00"")
y01 = m.addVar(name=""y01"")
t00 = m.addVar(name=""t00"")

# Objective function
m.setObjective(
    1.126401441072199 * x0
    - 0.3048391076081773 * x1
    + 1.210295701208876 * x2
    + 0.3629036707879342 * x3
    - 1.541074052220742 * x4,
    GRB.MINIMIZE
)

# Linear equality constraints
m.addConstr(
    -0.9907409502145462 * x0
    - 0.7264863472262246 * x1
    + 0.2793136098129854 * x2
    - 0.9349403902445268 * x3
    + 1.444658005223368 * x4 == 1.116201276984661,
    name=""eq1""
)
m.addConstr(
    2.936722209688262 * x0
    + 0.5035733953314866 * x1
    + 0.3357143231898844 * x2
    + 1.112758520098299 * x3
    + 1.412597032089028 * x4 == -1.571971227040746,
    name=""eq2""
)
m.addConstr(
    0.7899614064673852 * x0
    - 0.0724234240750259 * x1
    - 0.7706602505688044 * x2
    + 1.907488050972312 * x3
    + 1.420058526737699 * x4 == -1.686571012140405,
    name=""eq3""
)
m.addConstr(
    0.6068754572874664 * x0
    + 0.7492819480236036 * x1
    - 1.565830499338323 * x2
    + 0.2718401004423009 * x3
    + 0.5510027846961619 * x4 == 4.014442756917189,
    name=""eq4""
)
m.addConstr(
    -0.0124992573250491 * x0
    - 0.1193568402945484 * x1
    - 0.0200307964468845 * x2
    + 0.0612863681420025 * x3
    - 0.116537049877206 * x4
    + y00 == -0.0358590805559009,
    name=""eq5""
)
m.addConstr(
    0.0484815211698107 * x0
    - 0.0631246556642578 * x1
    + 0.1244200448905836 * x2
    + 0.0530487576814488 * x3
    + 0.1361347655297342 * x4
    + y01 == 0.0271906214446268,
    name=""eq6""
)
m.addConstr(
    -2.249909202694956 * x0
    + 0.7776031115768471 * x1
    - 0.2174454691465576 * x2
    + 1.953508135119546 * x3
    + 1.071251451084194 * x4
    + t00 == 0.9059772765697818,
    name=""eq7""
)

# Quadratic constraint: -t00^2 + y00^2 + y01^2 <= 0
m.addQConstr(
    y00 * y00 + y01 * y01 - t00 * t00 <= 0,
    name=""quad_constraint""
)

# Optimize
m.optimize()

# Print results
if m.status == GRB.OPTIMAL:
    print(""Optimal objective:"", m.objVal)
    print(""x0 ="", x0.X)
    print(""x1 ="", x1.X)
    print(""x2 ="", x2.X)
    print(""x3 ="", x3.X)
    print(""x4 ="", x4.X)
    print(""y00 ="", y00.X)
    print(""y01 ="", y01.X)
    print(""t00 ="", t00.X)",,-5.0688283,0,,,,,,,,
"The production manager seeks to minimize the total production cost for four product lines, \( x[0] \), \( x[1] \), \( x[2] \), and \( x[3] \), with costs of \( -0.0211519215863677 \), \( -0.157914420869699 \), \( -1.276226636497168 \), and \( 1.887428393936258 \) per unit, respectively. Negative coefficients in the objective function represent costs to be minimized, not cost savings. Four linear equality constraints must be satisfied: the first requires a weighted sum of production levels using coefficients \( -0.6903544941297689 \), \( 0.184421264426265 \), \( 0.2271145373127337 \), and \( 0.3261334256865931 \) to equal \( -1.784682154876947 \). The second constraint uses coefficients \( 0.9527280569937944 \), \( -0.227563767653628 \), \( -0.1388448211471715 \), and \( -0.7259447957545259 \) to sum to \( 3.071741041299838 \). The third constraint uses coefficients \( -0.2904848690892891 \), \( 0.6067085131648451 \), \( 0.5360035950278403 \), and \( 1.175919727086906 \) to sum to \( -3.247120484557859 \). The fourth constraint uses coefficients \( -1.447328047167681 \), \( 1.078800425952911 \), \( -1.071986023688645 \), and \( 2.402600530074645 \) to sum to \( -9.240805229261266 \).

Twelve auxiliary variables, \( y_0[0] \), \( y_0[1] \), \( y_1[0] \), \( y_1[1] \), \( y_2[0] \), \( y_2[1] \), \( y_3[0] \), \( y_3[1] \), \( t_0[0] \), \( t_1[0] \), \( t_2[0] \), and \( t_3[0] \), are introduced to model resource usage and operational safety. These variables are part of twelve additional linear constraints: R4 through R15. For example, R4 states that \( -0.00544743187557857 \) times \( x[0] \), minus \( 0.1023858515949546 \) times \( x[1] \), minus \( 0.2570937910987342 \) times \( x[2] \), minus \( 0.0303903824324441 \) times \( x[3] \), plus \( y_0[0] \), equals \( 0.0630402459981765 \). Similar relationships define R5 through R15.

Four quadratic constraints ensure safe operational limits: the sum of the squares of \( y_0[0] \) and \( y_0[1] \) must be less than or equal to the square of \( t_0[0] \); the sum of the squares of \( y_1[0] \) and \( y_1[1] \) must be less than or equal to the square of \( t_1[0] \); the sum of the squares of \( y_2[0] \) and \( y_2[1] \) must be less than or equal to the square of \( t_2[0] \); and the sum of the squares of \( y_3[0] \) and \( y_3[1] \) must be less than or equal to the square of \( t_3[0] \). All decision variables, including production levels and auxiliary variables, are free to take any real value. The goal is to determine the optimal production levels for \( x[0] \), \( x[1] \), \( x[2] \), and \( x[3] \) that minimize total production cost while satisfying all constraints. This problem is a Second-Order Cone Programming (SOCP) problem, as indicated by the quadratic constraints and the structure of the model.","\[
\begin{aligned}
\min\;&-0.0211519215863677\,x_0-0.157914420869699\,x_1-1.276226636497168\,x_2+1.887428393936258\,x_3\\
\text{s.t.}\;&-0.6903544941297689\,x_0+0.184421264426265\,x_1+0.2271145373127337\,x_2+0.3261334256865931\,x_3=-1.784682154876947\\
&0.9527280569937944\,x_0-0.227563767653628\,x_1-0.1388448211471715\,x_2-0.7259447957545259\,x_3=3.071741041299838\\
&-0.2904848690892891\,x_0+0.6067085131648451\,x_1+0.5360035950278403\,x_2+1.175919727086906\,x_3=-3.247120484557859\\
&-1.447328047167681\,x_0+1.078800425952911\,x_1-1.071986023688645\,x_2+2.402600530074645\,x_3=-9.240805229261266\\
&-0.00544743187557857\,x_0-0.1023858515949546\,x_1-0.2570937910987342\,x_2-0.0303903824324441\,x_3+y_{0,0}=0.0630402459981765\\
&\text{(R5)}\;a_{5,0}x_0+a_{5,1}x_1+a_{5,2}x_2+a_{5,3}x_3+y_{0,1}=b_5\\
&\text{(R6)}\;a_{6,0}x_0+a_{6,1}x_1+a_{6,2}x_2+a_{6,3}x_3+y_{1,0}=b_6\\
&\text{(R7)}\;a_{7,0}x_0+a_{7,1}x_1+a_{7,2}x_2+a_{7,3}x_3+y_{1,1}=b_7\\
&\text{(R8)}\;a_{8,0}x_0+a_{8,1}x_1+a_{8,2}x_2+a_{8,3}x_3+y_{2,0}=b_8\\
&\text{(R9)}\;a_{9,0}x_0+a_{9,1}x_1+a_{9,2}x_2+a_{9,3}x_3+y_{2,1}=b_9\\
&\text{(R10)}\;a_{10,0}x_0+a_{10,1}x_1+a_{10,2}x_2+a_{10,3}x_3+y_{3,0}=b_{10}\\
&\text{(R11)}\;a_{11,0}x_0+a_{11,1}x_1+a_{11,2}x_2+a_{11,3}x_3+y_{3,1}=b_{11}\\
&\text{(R12)}\;a_{12,0}x_0+a_{12,1}x_1+a_{12,2}x_2+a_{12,3}x_3+t_{0,0}=b_{12}\\
&\text{(R13)}\;a_{13,0}x_0+a_{13,1}x_1+a_{13,2}x_2+a_{13,3}x_3+t_{1,0}=b_{13}\\
&\text{(R14)}\;a_{14,0}x_0+a_{14,1}x_1+a_{14,2}x_2+a_{14,3}x_3+t_{2,0}=b_{14}\\
&\text{(R15)}\;a_{15,0}x_0+a_{15,1}x_1+a_{15,2}x_2+a_{15,3}x_3+t_{3,0}=b_{15}\\
&y_{0,0}^2+y_{0,1}^2\le t_{0,0}^2\\
&y_{1,0}^2+y_{1,1}^2\le t_{1,0}^2\\
&y_{2,0}^2+y_{2,1}^2\le t_{2,0}^2\\
&y_{3,0}^2+y_{3,1}^2\le t_{3,0}^2\\
&x_0,x_1,x_2,x_3,y_{0,0},y_{0,1},y_{1,0},y_{1,1},y_{2,0},y_{2,1},y_{3,0},y_{3,1},t_{0,0},t_{1,0},t_{2,0},t_{3,0}\in\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""OptimizationModel"")

# Decision variables
x0 = m.addVar(vtype=GRB.CONTINUOUS, name=""x0"")
x1 = m.addVar(vtype=GRB.CONTINUOUS, name=""x1"")
x2 = m.addVar(vtype=GRB.CONTINUOUS, name=""x2"")
x3 = m.addVar(vtype=GRB.CONTINUOUS, name=""x3"")

y00 = m.addVar(vtype=GRB.CONTINUOUS, name=""y00"")
y01 = m.addVar(vtype=GRB.CONTINUOUS, name=""y01"")
y10 = m.addVar(vtype=GRB.CONTINUOUS, name=""y10"")
y11 = m.addVar(vtype=GRB.CONTINUOUS, name=""y11"")
y20 = m.addVar(vtype=GRB.CONTINUOUS, name=""y20"")
y21 = m.addVar(vtype=GRB.CONTINUOUS, name=""y21"")
y30 = m.addVar(vtype=GRB.CONTINUOUS, name=""y30"")
y31 = m.addVar(vtype=GRB.CONTINUOUS, name=""y31"")

t00 = m.addVar(vtype=GRB.CONTINUOUS, name=""t00"")
t10 = m.addVar(vtype=GRB.CONTINUOUS, name=""t10"")
t20 = m.addVar(vtype=GRB.CONTINUOUS, name=""t20"")
t30 = m.addVar(vtype=GRB.CONTINUOUS, name=""t30"")

# Objective function
m.setObjective(-0.0211519215863677*x0 - 0.157914420869699*x1 - 1.276226636497168*x2 + 1.887428393936258*x3, GRB.MINIMIZE)

# Linear equality constraints
m.addConstr(-0.6903544941297689*x0 + 0.184421264426265*x1 + 0.2271145373127337*x2 + 0.3261334256865931*x3 == -1.784682154876947, name=""eq1"")
m.addConstr(0.9527280569937944*x0 - 0.227563767653628*x1 - 0.1388448211471715*x2 - 0.7259447957545259*x3 == 3.071741041299838, name=""eq2"")
m.addConstr(-0.2904848690892891*x0 + 0.6067085131648451*x1 + 0.5360035950278403*x2 + 1.175919727086906*x3 == -3.247120484557859, name=""eq3"")
m.addConstr(-1.447328047167681*x0 + 1.078800425952911*x1 - 1.071986023688645*x2 + 2.402600530074645*x3 == -9.240805229261266, name=""eq4"")

# Constraint involving y00
m.addConstr(-0.00544743187557857*x0 - 0.1023858515949546*x1 - 0.2570937910987342*x2 - 0.0303903824324441*x3 + y00 == 0.0630402459981765, name=""eq_y00"")

# Placeholder coefficients for R5-R15
a = {
    5: [0.0, 0.0, 0.0, 0.0],
    6: [0.0, 0.0, 0.0, 0.0],
    7: [0.0, 0.0, 0.0, 0.0],
    8: [0.0, 0.0, 0.0, 0.0],
    9: [0.0, 0.0, 0.0, 0.0],
    10: [0.0, 0.0, 0.0, 0.0],
    11: [0.0, 0.0, 0.0, 0.0],
    12: [0.0, 0.0, 0.0, 0.0],
    13: [0.0, 0.0, 0.0, 0.0],
    14: [0.0, 0.0, 0.0, 0.0],
    15: [0.0, 0.0, 0.0, 0.0]
}
b = {
    5: 0.0,
    6: 0.0,
    7: 0.0,
    8: 0.0,
    9: 0.0,
    10: 0.0,
    11: 0.0,
    12: 0.0,
    13: 0.0,
    14: 0.0,
    15: 0.0
}

# Mapping from constraint number to variable
var_map = {
    5: y01,
    6: y10,
    7: y11,
    8: y20,
    9: y21,
    10: y30,
    11: y31,
    12: t00,
    13: t10,
    14: t20,
    15: t30
}

# Add R5-R15 constraints
for i in range(5, 16):
    coeffs = a[i]
    var = var_map[i]
    m.addConstr(coeffs[0]*x0 + coeffs[1]*x1 + coeffs[2]*x2 + coeffs[3]*x3 + var == b[i], name=f""R{i}"")

# Quadratic constraints
m.addQConstr(y00*y00 + y01*y01 <= t00*t00, name=""qc0"")
m.addQConstr(y10*y10 + y11*y11 <= t10*t10, name=""qc1"")
m.addQConstr(y20*y20 + y21*y21 <= t20*t20, name=""qc2"")
m.addQConstr(y30*y30 + y31*y31 <= t30*t30, name=""qc3"")

# Optimize
m.optimize()
```",,-4.298742,0,,,,,,,,
"The problem involves minimizing a linear objective function with coefficients 0.4662680322234939 for \( x[0] \), 0.1250396579327832 for \( x[1] \), and -0.1976509195604252 for \( x[2] \). The variables \( x[0] \), \( x[1] \), \( x[2] \), \( y_0[0] \), \( y_0[1] \), \( y_0[2] \), and \( t_0[0] \) are free to take any real values. The problem includes three linear equality constraints: the first requires that -1.506294713918092 times \( x[0] \) minus 0.5786002519685364 times \( x[1] \) plus 1.651436537097151 times \( x[2] \) equals 1.525536343222344; the second requires that -2.426679243393074 times \( x[0] \) minus 0.4289126288561773 times \( x[1] \) plus 1.265936258705534 times \( x[2] \) equals 2.564935934767919; and the third requires that -0.8667404022651017 times \( x[0] \) minus 0.6788861516220543 times \( x[1] \) minus 0.0947089689368911 times \( x[2] \) equals 0.2370752919653094. Additionally, there are four linear constraints: the first requires that -0.0337374122584387 times \( x[0] \) plus 0.0926622976309022 times \( x[1] \) minus 0.0275747406547086 times \( x[2] \) plus \( y_0[0] \) equals 0.0767641469627959; the second requires that -0.0370852326700521 times \( x[0] \) minus 0.1174307145074716 times \( x[1] \) plus 0.2032292481351275 times \( x[2] \) plus \( y_0[1] \) equals 0.0370679052304449; the third requires that -0.0582508292397692 times \( x[0] \) plus 0.0721175797872196 times \( x[1] \) plus 0.1702423600392019 times \( x[2] \) plus \( y_0[2] \) equals 0.2075459354425953; and the fourth requires that -0.1277576901021839 times \( x[0] \) minus 1.799889451307227 times \( x[1] \) minus 1.238366353571482 times \( x[2] \) plus \( t_0[0] \) equals 0.9137569517560475. Finally, a second-order cone constraint requires that the sum of the squares of \( y_0[0] \), \( y_0[1] \), and \( y_0[2] \) minus the square of \( t_0[0] \) is less than or equal to zero. The constraint involving \( t_0[0] \) is part of the second-order cone constraint setup, and \( t_0[0] \) is explicitly recognized as a decision variable.","\[
\begin{aligned}
\min\;& 0.4662680322234939\,x_0 + 0.1250396579327832\,x_1 - 0.1976509195604252\,x_2 \\[4pt]
\text{s.t.}\;& -1.506294713918092\,x_0 - 0.5786002519685364\,x_1 + 1.651436537097151\,x_2 = 1.525536343222344 \\[2pt]
& -2.426679243393074\,x_0 - 0.4289126288561773\,x_1 + 1.265936258705534\,x_2 = 2.564935934767919 \\[2pt]
& -0.8667404022651017\,x_0 - 0.6788861516220543\,x_1 - 0.0947089689368911\,x_2 = 0.2370752919653094 \\[4pt]
& -0.0337374122584387\,x_0 + 0.0926622976309022\,x_1 - 0.0275747406547086\,x_2 + y_{0,0} = 0.0767641469627959 \\[2pt]
& -0.0370852326700521\,x_0 - 0.1174307145074716\,x_1 + 0.2032292481351275\,x_2 + y_{0,1} = 0.0370679052304449 \\[2pt]
& -0.0582508292397692\,x_0 + 0.0721175797872196\,x_1 + 0.1702423600392019\,x_2 + y_{0,2} = 0.2075459354425953 \\[2pt]
& -0.1277576901021839\,x_0 - 1.799889451307227\,x_1 - 1.238366353571482\,x_2 + t_{0,0} = 0.9137569517560475 \\[4pt]
& y_{0,0}^2 + y_{0,1}^2 + y_{0,2}^2 - t_{0,0}^2 \le 0 \\[4pt]
& x_0,\,x_1,\,x_2,\,y_{0,0},\,y_{0,1},\,y_{0,2},\,t_{0,0}\;\in\;\mathbb{R}\;.
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

m = gp.Model(""Optimization_Model"")

# Decision variables
x0 = m.addVar(vtype=GRB.CONTINUOUS, name=""x0"")
x1 = m.addVar(vtype=GRB.CONTINUOUS, name=""x1"")
x2 = m.addVar(vtype=GRB.CONTINUOUS, name=""x2"")
y00 = m.addVar(vtype=GRB.CONTINUOUS, name=""y00"")
y01 = m.addVar(vtype=GRB.CONTINUOUS, name=""y01"")
y02 = m.addVar(vtype=GRB.CONTINUOUS, name=""y02"")
t00 = m.addVar(vtype=GRB.CONTINUOUS, name=""t00"")

# Objective
m.setObjective(0.4662680322234939*x0 + 0.1250396579327832*x1 - 0.1976509195604252*x2, GRB.MINIMIZE)

# Constraints
m.addConstr(-1.506294713918092*x0 - 0.5786002519685364*x1 + 1.651436537097151*x2 == 1.525536343222344, name=""c1"")
m.addConstr(-2.426679243393074*x0 - 0.4289126288561773*x1 + 1.265936258705534*x2 == 2.564935934767919, name=""c2"")
m.addConstr(-0.8667404022651017*x0 - 0.6788861516220543*x1 - 0.0947089689368911*x2 == 0.2370752919653094, name=""c3"")
m.addConstr(-0.0337374122584387*x0 + 0.0926622976309022*x1 - 0.0275747406547086*x2 + y00 == 0.0767641469627959, name=""c4"")
m.addConstr(-0.0370852326700521*x0 - 0.1174307145074716*x1 + 0.2032292481351275*x2 + y01 == 0.0370679052304449, name=""c5"")
m.addConstr(-0.0582508292397692*x0 + 0.0721175797872196*x1 + 0.1702423600392019*x2 + y02 == 0.2075459354425953, name=""c6"")
m.addConstr(-0.1277576901021839*x0 - 1.799889451307227*x1 - 1.238366353571482*x2 + t00 == 0.9137569517560475, name=""c7"")

# Quadratic constraint
q = gp.quadExpr()
q += y00*y00 + y01*y01 + y02*y02 - t00*t00
m.addQConstr(q <= 0, name=""q1"")

m.optimize()",,-0.4374181,0,,,,,,,,
"Minimize the total cost of allocating resources \( x[0] \) to \( x[4] \), where the cost coefficients are 0.190510737670758 for \( x[0] \), 1.129350959341043 for \( x[1] \), -1.45763004619859 for \( x[2] \), 0.4979171399142379 for \( x[3] \), and 0.217933194293673 for \( x[4] \). The allocation must satisfy four equality constraints. The first constraint requires 1.219567298556732 \( x[0] \) + 0.9289001747224751 \( x[1] \) - 1.336923760887845 \( x[2] \) - 1.115644167094657 \( x[3] \) - 0.4761759785063266 \( x[4] \) = -0.4344345340009604. The second constraint requires -1.662323208398086 \( x[0] \) + 0.8659229325025953 \( x[1] \) - 0.715611281293988 \( x[2] \) + 0.513394018474748 \( x[3] \) - 1.247456907892064 \( x[4] \) = -1.263487160460341. The third constraint requires -0.2849105246051509 \( x[0] \) - 1.235291728359102 \( x[1] \) + 1.089988844777487 \( x[2] \) - 1.059632720036963 \( x[3] \) + 0.2188818725225526 \( x[4] \) = 0.0598263158545554. The fourth constraint requires -1.037775353342995 \( x[0] \) - 1.808771173081519 \( x[1] \) + 1.006811579019581 \( x[2] \) + 0.2261443990014109 \( x[3] \) - 0.5001468099984979 \( x[4] \) = 0.6799624629319878. Additional linear constraints involve variables \( y_0[0] \), \( y_0[1] \), \( t_0[0] \), \( y_1[0] \), \( y_1[1] \), \( t_1[0] \), \( y_2[0] \), \( y_2[1] \), \( t_2[0] \), \( y_3[0] \), \( y_3[1] \), \( t_3[0] \), \( y_4[0] \), \( y_4[1] \), and \( t_4[0] \), which are free variables. These constraints are defined as follows: 0.1854712369852954 \( x[0] \) + 0.2126049926787192 \( x[1] \) - 0.0552426804013357 \( x[2] \) - 0.0300913423926646 \( x[3] \) + 0.0191442880734612 \( x[4] \) + \( y_0[0] \) = -0.00851123919328947; 0.033633911265618 \( x[0] \) + 0.0447803575912513 \( x[1] \) + 0.0906422549522432 \( x[2] \) - 0.140301925709981 \( x[3] \) + 0.0894655740323818 \( x[4] \) + \( y_0[1] \) = 0.1197073561594899; 1.032476848498754 \( x[0] \) + 0.5786229660982358 \( x[1] \) + 1.517117102281561 \( x[2] \) - 0.9892374377228246 \( x[3] \) - 0.7127788386839591 \( x[4] \) + \( t_0[0] \) = 0.0628164480170035; -0.0629876313760396 \( x[0] \) + 0.1186553496180699 \( x[1] \) + 0.0837866420373662 \( x[2] \) - 0.0175044400700457 \( x[3] \) + 0.0421466082438275 \( x[4] \) + \( y_1[0] \) = -0.0607801036942368; 0.0472913180476754 \( x[0] \) - 0.1672487320352799 \( x[1] \) + 0.00403030115525331 \( x[2] \) + 0.00774493287185739 \( x[3] \) - 0.0094688993206764 \( x[4] \) + \( y_1[1] \) = -0.0464456008702828; -0.2085979716989413 \( x[0] \) - 0.1092539540974228 \( x[1] \) - 2.174804559553748 \( x[2] \) - 1.69528753252808 \( x[3] \) - 1.525645556958908 \( x[4] \) + \( t_1[0] \) = 0.7445116249805878; 0.000912382 \( x[0] \) - 0.00863788041334999 \( x[1] \) - 0.0502948320610378 \( x[2] \) - 0.0667737933702229 \( x[3] \) + 0.2432277963883143 \( x[4] \) + \( y_2[0] \) = -0.139166601364713; 0.0232832507250414 \( x[0] \) + 0.2516736184489083 \( x[1] \) + 0.1386504617834828 \( x[2] \) - 0.0543682860611478 \( x[3] \) + 0.050704164298607 \( x[4] \) + \( y_2[1] \) = 0.0357160518360202; -0.5925926352567416 \( x[0] \) - 0.3891604825652387 \( x[1] \) + 0.0510217340581877 \( x[2] \) + 1.090606691890913 \( x[3] \) + 0.9938716757643966 \( x[4] \) + \( t_2[0] \) = 1.045297581678233; 0.1540622796961561 \( x[0] \) - 0.1883221064812006 \( x[1] \) + 0.1503453658091877 \( x[2] \) - 0.1474374678246578 \( x[3] \) + 0.0205212420510411 \( x[4] \) + \( y_3[0] \) = -0.00963411322153448; -0.0280861975467837 \( x[0] \) - 0.0105727074625737 \( x[1] \) + 0.0954257952878318 \( x[2] \) - 0.00589259567851985 \( x[3] \) + 0.145090882467532 \( x[4] \) + \( y_3[1] \) = -0.019437376136785; -1.252924325600617 \( x[0] \) + 1.244308803054627 \( x[1] \) - 2.21127388768641 \( x[2] \) - 1.885087766270206 \( x[3] \) - 1.006758968957397 \( x[4] \) + \( t_3[0] \) = 1.050824562362084; 0.1325971503040609 \( x[0] \) - 0.110249935172733 \( x[1] \) + 0.0558235975886938 \( x[2] \) + 0.0542813307961975 \( x[3] \) - 0.1156413261001238 \( x[4] \) + \( y_4[0] \) = 0.0325653324485877; -1.3730183823943952e-04 \( x[0] \) - 0.0268128227655337 \( x[1] \) + 0.0403141061350009 \( x[2] \) + 0.1864002689467194 \( x[3] \) - 0.0450317064978495 \( x[4] \) + \( y_4[1] \) = 0.0626883759594124; -1.090908275543176 \( x[0] \) + 0.3860841432731175 \( x[1] \) - 0.2953562653864454 \( x[2] \) - 0.2904011172481792 \( x[3] \) - 0.8273323625052638 \( x[4] \) + \( t_4[0] \) = 0.7353989816876624. Quadratic constraints require that the sum of the squares of the outcomes minus the square of the allocated resource must be less than or equal to zero for each project: \( y_0[0]^2 + y_0[1]^2 - t_0[0]^2 \leq 0 \), \( y_1[0]^2 + y_1[1]^2 - t_1[0]^2 \leq 0 \), \( y_2[0]^2 + y_2[1]^2 - t_2[0]^2 \leq 0 \), \( y_3[0]^2 + y_3[1]^2 - t_3[0]^2 \leq 0 \), and \( y_4[0]^2 + y_4[1]^2 - t_4[0]^2 \leq 0 \). All variables \( x[0] \) to \( x[4] \), \( y_0[0] \) to \( y_4[1] \), and \( t_0[0] \) to \( t_4[0] \) are free to take any real value.","\[
\begin{aligned}
\min\;&0.190510737670758\,x_0+1.129350959341043\,x_1-1.45763004619859\,x_2+0.4979171399142379\,x_3+0.217933194293673\,x_4\\
\text{s.t.}\;&1.219567298556732\,x_0+0.9289001747224751\,x_1-1.336923760887845\,x_2-1.115644167094657\,x_3-0.4761759785063266\,x_4=-0.4344345340009604\\
&-1.662323208398086\,x_0+0.8659229325025953\,x_1-0.715611281293988\,x_2+0.513394018474748\,x_3-1.247456907892064\,x_4=-1.263487160460341\\
&-0.2849105246051509\,x_0-1.235291728359102\,x_1+1.089988844777487\,x_2-1.059632720036963\,x_3+0.2188818725225526\,x_4=0.0598263158545554\\
&-1.037775353342995\,x_0-1.808771173081519\,x_1+1.006811579019581\,x_2+0.2261443990014109\,x_3-0.5001468099984979\,x_4=0.6799624629319878\\
&0.1854712369852954\,x_0+0.2126049926787192\,x_1-0.0552426804013357\,x_2-0.0300913423926646\,x_3+0.0191442880734612\,x_4+y_{0,0}=-0.00851123919328947\\
&0.033633911265618\,x_0+0.0447803575912513\,x_1+0.0906422549522432\,x_2-0.140301925709981\,x_3+0.0894655740323818\,x_4+y_{0,1}=0.1197073561594899\\
&1.032476848498754\,x_0+0.5786229660982358\,x_1+1.517117102281561\,x_2-0.9892374377228246\,x_3-0.7127788386839591\,x_4+t_{0,0}=0.0628164480170035\\
&-0.0629876313760396\,x_0+0.1186553496180699\,x_1+0.0837866420373662\,x_2-0.0175044400700457\,x_3+0.0421466082438275\,x_4+y_{1,0}=-0.0607801036942368\\
&0.0472913180476754\,x_0-0.1672487320352799\,x_1+0.00403030115525331\,x_2+0.00774493287185739\,x_3-0.0094688993206764\,x_4+y_{1,1}=-0.0464456008702828\\
&-0.2085979716989413\,x_0-0.1092539540974228\,x_1-2.174804559553748\,x_2-1.69528753252808\,x_3-1.525645556958908\,x_4+t_{1,0}=0.7445116249805878\\
&0.000912382\,x_0-0.00863788041334999\,x_1-0.0502948320610378\,x_2-0.0667737933702229\,x_3+0.2432277963883143\,x_4+y_{2,0}=-0.139166601364713\\
&0.0232832507250414\,x_0+0.2516736184489083\,x_1+0.1386504617834828\,x_2-0.0543682860611478\,x_3+0.050704164298607\,x_4+y_{2,1}=0.0357160518360202\\
&-0.5925926352567416\,x_0-0.3891604825652387\,x_1+0.0510217340581877\,x_2+1.090606691890913\,x_3+0.9938716757643966\,x_4+t_{2,0}=1.045297581678233\\
&0.1540622796961561\,x_0-0.1883221064812006\,x_1+0.1503453658091877\,x_2-0.1474374678246578\,x_3+0.0205212420510411\,x_4+y_{3,0}=-0.00963411322153448\\
&-0.0280861975467837\,x_0-0.0105727074625737\,x_1+0.0954257952878318\,x_2-0.00589259567851985\,x_3+0.145090882467532\,x_4+y_{3,1}=-0.019437376136785\\
&-1.252924325600617\,x_0+1.244308803054627\,x_1-2.21127388768641\,x_2-1.885087766270206\,x_3-1.006758968957397\,x_4+t_{3,0}=1.050824562362084\\
&0.1325971503040609\,x_0-0.110249935172733\,x_1+0.0558235975886938\,x_2+0.0542813307961975\,x_3-0.1156413261001238\,x_4+y_{4,0}=0.0325653324485877\\
&-1.3730183823943952\times10^{-4}\,x_0-0.0268128227655337\,x_1+0.0403141061350009\,x_2+0.1864002689467194\,x_3-0.0450317064978495\,x_4+y_{4,1}=0.0626883759594124\\
&-1.090908275543176\,x_0+0.3860841432731175\,x_1-0.2953562653864454\,x_2-0.2904011172481792\,x_3-0.8273323625052638\,x_4+t_{4,0}=0.7353989816876624\\
&y_{0,0}^2+y_{0,1}^2-t_{0,0}^2\le0,\quad y_{1,0}^2+y_{1,1}^2-t_{1,0}^2\le0,\quad y_{2,0}^2+y_{2,1}^2-t_{2,0}^2\le0,\\
&\quad y_{3,0}^2+y_{3,1}^2-t_{3,0}^2\le0,\quad y_{4,0}^2+y_{4,1}^2-t_{4,0}^2\le0\\
&x_0,x_1,x_2,x_3,x_4\in\mathbb{R},\;
y_{0,0},y_{0,1},y_{1,0},y_{1,1},y_{2,0},y_{2,1},y_{3,0},y_{3,1},y_{4,0},y_{4,1}\in\mathbb{R},\;
t_{0,0},t_{1,0},t_{2,0},t_{3,0},t_{4,0}\in\mathbb{R}.
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Optimization_Model"")

# Decision variables
x = m.addVars(5, lb=-GRB.INFINITY, name=""x"")  # x0..x4

y = {}
for i in range(5):
    for j in range(2):
        y[(i, j)] = m.addVar(name=f""y_{i}_{j}"")

t = {}
for i in range(5):
    t[i] = m.addVar(name=f""t_{i}"")

# Objective: minimize 0.190510737670758*x0 + 1.129350959341043*x1 - 1.45763004619859*x2
#            + 0.4979171399142379*x3 + 0.217933194293673*x4
m.setObjective(
    0.190510737670758 * x[0] +
    1.129350959341043 * x[1] -
    1.45763004619859  * x[2] +
    0.4979171399142379 * x[3] +
    0.217933194293673  * x[4],
    GRB.MINIMIZE
)

# Linear constraints
m.addConstr(1.219567298556732 * x[0] + 0.9289001747224751 * x[1] - 1.336923760887845 * x[2]
            - 1.115644167094657 * x[3] - 0.4761759785063266 * x[4] == -0.4344345340009604,
            name=""c1"")
m.addConstr(-1.662323208398086 * x[0] + 0.8659229325025953 * x[1] - 0.715611281293988 * x[2]
            + 0.513394018474748 * x[3] - 1.247456907892064 * x[4] == -1.263487160460341,
            name=""c2"")
m.addConstr(-0.2849105246051509 * x[0] - 1.235291728359102 * x[1] + 1.089988844777487 * x[2]
            - 1.059632720036963 * x[3] + 0.2188818725225526 * x[4] == 0.0598263158545554,
            name=""c3"")
m.addConstr(-1.037775353342995 * x[0] - 1.808771173081519 * x[1] + 1.006811579019581 * x[2]
            + 0.2261443990014109 * x[3] - 0.5001468099984979 * x[4] == 0.6799624629319878,
            name=""c4"")

m.addConstr(0.1854712369852954 * x[0] + 0.2126049926787192 * x[1] - 0.0552426804013357 * x[2]
            - 0.0300913423926646 * x[3] + 0.0191442880734612 * x[4] + y[(0,0)] == -0.00851123919328947,
            name=""c5"")
m.addConstr(0.033633911265618 * x[0] + 0.0447803575912513 * x[1] + 0.0906422549522432 * x[2]
            - 0.140301925709981 * x[3] + 0.0894655740323818 * x[4] + y[(0,1)] == 0.1197073561594899,
            name=""c6"")
m.addConstr(1.032476848498754 * x[0] + 0.5786229660982358 * x[1] + 1.517117102281561 * x[2]
            - 0.9892374377228246 * x[3] - 0.7127788386839591 * x[4] + t[0] == 0.0628164480170035,
            name=""c7"")

m.addConstr(-0.0629876313760396 * x[0] + 0.1186553496180699 * x[1] + 0.0837866420373662 * x[2]
            - 0.0175044400700457 * x[3] + 0.0421466082438275 * x[4] + y[(1,0)] == -0.0607801036942368,
            name=""c8"")
m.addConstr(0.0472913180476754 * x[0] - 0.1672487320352799 * x[1] + 0.00403030115525331 * x[2]
            + 0.00774493287185739 * x[3] - 0.0094688993206764 * x[4] + y[(1,1)] == -0.0464456008702828,
            name=""c9"")
m.addConstr(-0.2085979716989413 * x[0] - 0.1092539540974228 * x[1] - 2.174804559553748 * x[2]
            - 1.69528753252808 * x[3] - 1.525645556958908 * x[4] + t[1] == 0.7445116249805878,
            name=""c10"")

m.addConstr(0.000912382 * x[0] - 0.00863788041334999 * x[1] - 0.0502948320610378 * x[2]
            - 0.0667737933702229 * x[3] + 0.2432277963883143 * x[4] + y[(2,0)] == -0.139166601364713,
            name=""c11"")
m.addConstr(0.0232832507250414 * x[0] + 0.2516736184489083 * x[1] + 0.1386504617834828 * x[2]
            - 0.0543682860611478 * x[3] + 0.050704164298607 * x[4] + y[(2,1)] == 0.0357160518360202,
            name=""c12"")
m.addConstr(-0.5925926352567416 * x[0] - 0.3891604825652387 * x[1] + 0.0510217340581877 * x[2]
            + 1.090606691890913 * x[3] + 0.9938716757643966 * x[4] + t[2] == 1.045297581678233,
            name=""c13"")

m.addConstr(0.1540622796961561 * x[0] - 0.1883221064812006 * x[1] + 0.1503453658091877 * x[2]
            - 0.1474374678246578 * x[3] + 0.0205212420510411 * x[4] + y[(3,0)] == -0.00963411322153448,
            name=""c14"")
m.addConstr(-0.0280861975467837 * x[0] - 0.0105727074625737 * x[1] + 0.0954257952878318 * x[2]
            - 0.00589259567851985 * x[3] + 0.145090882467532 * x[4] + y[(3,1)] == -0.019437376136785,
            name=""c15"")
m.addConstr(-1.252924325600617 * x[0] + 1.244308803054627 * x[1] - 2.21127388768641 * x[2]
            - 1.885087766270206 * x[3] - 1.006758968957397 * x[4] + t[3] == 1.050824562362084,
            name=""c16"")

m.addConstr(0.1325971503040609 * x[0] - 0.110249935172733 * x[1] + 0.0558235975886938 * x[2]
            + 0.0542813307961975 * x[3] - 0.1156413261001238 * x[4] + y[(4,0)] == 0.0325653324485877,
            name=""c17"")
m.addConstr(-1.3730183823943952e-4 * x[0] - 0.0268128227655337 * x[1] + 0.0403141061350009 * x[2]
            + 0.1864002689467194 * x[3] - 0.0450317064978495 * x[4] + y[(4,1)] == 0.0626883759594124,
            name=""c18"")
m.addConstr(-1.090908275543176 * x[0] + 0.3860841432731175 * x[1] - 0.2953562653864454 * x[2]
            - 0.2904011172481792 * x[3] - 0.8273323625052638 * x[4] + t[4] == 0.7353989816876624,
            name=""c19"")

# Quadratic constraints: y_{i,0}^2 + y_{i,1}^2 - t_{i}^2 <= 0
for i in range(5):
    m.addQConstr(
        y[(i,0)] * y[(i,0)] + y[(i,1)] * y[(i,1)] - t[i] * t[i] <= 0,
        name=f""qc_{i}""
    )

# Optimize
m.optimize()
```",,-0.3945969,0,,,,,,,,
"The optimization problem involves minimizing a linear objective function influenced by decision variables \(x[0]\), \(x[1]\), and \(x[2]\), with coefficients \(-1.363345803670422\), \(1.361682302913205\), and \(-0.0230642010699799\), respectively. These variables are free to take any real value. The problem is subject to 18 linear equality constraints. The first three constraints enforce specific relationships: the sum of \(-1.712919234088719\) units from \(x[0]\), \(0.5094892843494099\) units from \(x[1]\), and \(-1.176977823298391\) units from \(x[2]\) must equal \(1.969673610649569\); the sum of \(0.370350858647903\) units from \(x[0]\), \(0.1859117162151037\) units from \(x[1]\), and \(0.4554018017289621\) units from \(x[2]\) must equal \(-0.42565571941171\); and the sum of \(1.568958943694931\) units from \(x[0]\), \(0.1377471346710665\) units from \(x[1]\), and \(-0.5120283579251602\) units from \(x[2]\) must equal \(-0.6850278359750025\). The remaining 15 constraints involve auxiliary variables \(y_i[j]\) and \(t_i[0]\), which are also free, and enforce linear relationships between these variables and the decision variables. For \(i=0\), the sum of \(0.0870156668345264\) units from \(x[0]\), \(0.0507128953480789\) units from \(x[1]\), \(0.2266461831421958\) units from \(x[2]\), and \(y_0[0]\) must equal \(-0.1485711357308674\). Similarly, for \(i=0\), the sum of \(-0.1414205820862144\) units from \(x[0]\), \(-0.3264725908092034\) units from \(x[1]\), \(-0.0734148848236748\) units from \(x[2]\), and \(y_0[1]\) must equal \(-0.0393674285854488\); and the sum of \(0.1205790377305938\) units from \(x[0]\), \(-0.0720533164152696\) units from \(x[1]\), \(1.0940570577090807e-04\) units from \(x[2]\), and \(y_0[2]\) must equal \(0.0713736217121076\). Additionally, for \(i=0\), the sum of \(1.069325952651591\) units from \(x[0]\), \(-1.138089180693524\) units from \(x[1]\), \(-0.2833695676847757\) units from \(x[2]\), and \(t_0[0]\) must equal \(0.5757538449770843\). These patterns continue for \(i=1\), \(i=2\), and \(i=3\), with similar linear relationships defined for \(y_i[j]\) and \(t_i[0]\). The problem also includes four quadratic constraints, which are second-order cone constraints. These constraints ensure that for each set of auxiliary variables \(y_i[0]\), \(y_i[1]\), and \(y_i[2]\), the squared sum of these variables does not exceed the square of \(t_i[0]\). The goal is to determine the values of the decision and auxiliary variables that minimize the objective function while satisfying all linear and quadratic constraints.","\[
\begin{aligned}
\min\;&-1.363345803670422\,x_{0}+1.361682302913205\,x_{1}-0.0230642010699799\,x_{2}\\
\text{s.t.}\;&-1.712919234088719\,x_{0}+0.5094892843494099\,x_{1}-1.176977823298391\,x_{2}=1.969673610649569\\
&0.370350858647903\,x_{0}+0.1859117162151037\,x_{1}+0.4554018017289621\,x_{2}=-0.42565571941171\\
&1.568958943694931\,x_{0}+0.1377471346710665\,x_{1}-0.5120283579251602\,x_{2}=-0.6850278359750025\\
&0.0870156668345264\,x_{0}+0.0507128953480789\,x_{1}+0.2266461831421958\,x_{2}+y_{0,0}=-0.1485711357308674\\
&-0.1414205820862144\,x_{0}-0.3264725908092034\,x_{1}-0.0734148848236748\,x_{2}+y_{0,1}=-0.0393674285854488\\
&0.1205790377305938\,x_{0}-0.0720533164152696\,x_{1}+1.0940570577090807\times10^{-4}\,x_{2}+y_{0,2}=0.0713736217121076\\
&1.069325952651591\,x_{0}-1.138089180693524\,x_{1}-0.2833695676847757\,x_{2}+t_{0,0}=0.5757538449770843\\
&y_{i,0}^{2}+y_{i,1}^{2}+y_{i,2}^{2}\le t_{i,0}^{2}\quad\forall i=0,1,2,3\\
&x_{0},x_{1},x_{2},y_{i,j},t_{i,0}\in\mathbb{R}\quad\forall i=0,\dots,3,\ j=0,1,2
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Optimization_Model"")

# Decision variables
x0 = m.addVar(name=""x0"")
x1 = m.addVar(name=""x1"")
x2 = m.addVar(name=""x2"")

# y variables for i=0..3, j=0..2
y = m.addVars(4, 3, name=""y"")

# t variables for i=0..3
t = m.addVars(4, name=""t"")

# Objective function: minimize -1.363345803670422*x0 + 1.361682302913205*x1 - 0.0230642010699799*x2
m.setObjective(-1.363345803670422 * x0 + 1.361682302913205 * x1 - 0.0230642010699799 * x2, GRB.MINIMIZE)

# Equality constraints on x variables
m.addConstr(-1.712919234088719 * x0 + 0.5094892843494099 * x1 - 1.176977823298391 * x2 == 1.969673610649569, name=""eq1"")
m.addConstr(0.370350858647903 * x0 + 0.1859117162151037 * x1 + 0.4554018017289621 * x2 == -0.42565571941171, name=""eq2"")
m.addConstr(1.568958943694931 * x0 + 0.1377471346710665 * x1 - 0.5120283579251602 * x2 == -0.6850278359750025, name=""eq3"")

# Constraints involving y[0,*]
m.addConstr(0.0870156668345264 * x0 + 0.0507128953480789 * x1 + 0.2266461831421958 * x2 + y[0,0] == -0.1485711357308674, name=""y0_0"")
m.addConstr(-0.1414205820862144 * x0 - 0.3264725908092034 * x1 - 0.0734148848236748 * x2 + y[0,1] == -0.0393674285854488, name=""y0_1"")
m.addConstr(0.1205790377305938 * x0 - 0.0720533164152696 * x1 + 1.0940570577090807e-4 * x2 + y[0,2] == 0.0713736217121076, name=""y0_2"")

# Constraint involving t[0]
m.addConstr(1.069325952651591 * x0 - 1.138089180693524 * x1 - 0.2833695676847757 * x2 + t[0] == 0.5757538449770843, name=""t0"")

# Nonlinear constraints: y[i,0]^2 + y[i,1]^2 + y[i,2]^2 <= t[i]^2 for all i
for i in range(4):
    m.addQConstr(y[i,0]*y[i,0] + y[i,1]*y[i,1] + y[i,2]*y[i,2] <= t[i]*t[i], name=f""nonlinear_{i}"")

# Optimize
m.optimize()
",,1.42027477,0,,,,,,,,
"The problem involves optimizing the allocation of five free variables \( x[0] \) to \( x[4] \), along with auxiliary variables \( y_0[0] \) to \( y_2[3] \) and \( t_0[0] \) to \( t_2[0] \), which are also free. The objective is to minimize the expression \(-0.4183092460544717 x[0] - 0.2813052479554071 x[1] + 0.134543055273074 x[2] + 0.3293895938730942 x[3] - 0.5013729625677056 x[4]\). The problem is subject to five linear equality constraints. The first constraint requires \(-0.2042258848533399 x[0] + 0.2505367949866907 x[1] - 0.4309025998889995 x[2] + 1.309402520858531 x[3] + 2.586402096787606 x[4] = -3.156703022107761\). The second constraint imposes \(-0.9968810525037243 x[0] - 0.4546685233810487 x[1] + 0.4750317828663017 x[2] + 0.266787146193911 x[3] - 1.191880626574726 x[4] = -2.176991821226254\). The third constraint requires \(0.349956286844281 x[0] + 1.015584003075466 x[1] - 0.0836288458590485 x[2] - 0.0695677711676667 x[3] + 0.104824587707105 x[4] = 2.926695432150372\). The fourth constraint enforces \(0.7470800133528747 x[0] + 0.8253890222140957 x[1] + 0.0968330451370987 x[2] + 0.7049632173662657 x[3] + 0.7872792028260496 x[4] = 0.5732174371789283\). The fifth constraint requires \(-1.307269223716067 x[0] + 0.3813744238506016 x[1] - 0.4050739984159557 x[2] + 1.424197873139263 x[3] + 0.4653468565843648 x[4] = -3.193503084865396\).

Additionally, the problem includes constraints linking the variables \( x[0] \) to \( x[4] \) with auxiliary variables \( y_0[0] \) to \( y_2[3] \). For example, the first linking constraint requires \(-0.3645044940419532 x[0] - 1.443832971588788 x[1] + 0.461589002970339 x[2] + 0.2606857473736294 x[3] + 1.721110703706202 x[4] + y_0[0] = -0.9152180704947402\). Similar constraints exist for \( y_0[1] \), \( y_0[2] \), \( y_0[3] \), \( y_1[0] \), \( y_1[1] \), \( y_1[2] \), \( y_1[3] \), \( y_2[0] \), \( y_2[1] \), \( y_2[2] \), and \( y_2[3] \), each with specific coefficients and target values.

The problem also includes quadratic constraints involving the variables \( t_0[0] \), \( t_1[0] \), and \( t_2[0] \). The first quadratic constraint ensures that \(-t_0[0]^2 + y_0[0]^2 + y_0[1]^2 + y_0[2]^2 + y_0[3]^2 \leq 0\). The second quadratic constraint requires \(-t_1[0]^2 + y_1[0]^2 + y_1[1]^2 + y_1[2]^2 + y_1[3]^2 \leq 0\), and the third quadratic constraint enforces \(-t_2[0]^2 + y_2[0]^2 + y_2[1]^2 + y_2[2]^2 + y_2[3]^2 \leq 0\). These constraints ensure that the relationships between the auxiliary variables and the safety buffers are maintained. The goal is to minimize the objective function while satisfying all linear equality, linking, and quadratic constraints.","\[
\begin{aligned}
\min \quad & -0.4183092460544717\,x_0 - 0.2813052479554071\,x_1 + 0.134543055273074\,x_2 + 0.3293895938730942\,x_3 - 0.5013729625677056\,x_4 \\
\text{s.t.}\quad & -0.2042258848533399\,x_0 + 0.2505367949866907\,x_1 - 0.4309025998889995\,x_2 + 1.309402520858531\,x_3 + 2.586402096787606\,x_4 = -3.156703022107761 \\
& -0.9968810525037243\,x_0 - 0.4546685233810487\,x_1 + 0.4750317828663017\,x_2 + 0.266787146193911\,x_3 - 1.191880626574726\,x_4 = -2.176991821226254 \\
& 0.349956286844281\,x_0 + 1.015584003075466\,x_1 - 0.0836288458590485\,x_2 - 0.0695677711676667\,x_3 + 0.104824587707105\,x_4 = 2.926695432150372 \\
& 0.7470800133528747\,x_0 + 0.8253890222140957\,x_1 + 0.0968330451370987\,x_2 + 0.7049632173662657\,x_3 + 0.7872792028260496\,x_4 = 0.5732174371789283 \\
& -1.307269223716067\,x_0 + 0.3813744238506016\,x_1 - 0.4050739984159557\,x_2 + 1.424197873139263\,x_3 + 0.4653468565843648\,x_4 = -3.193503084865396 \\
& -0.3645044940419532\,x_0 - 1.443832971588788\,x_1 + 0.461589002970339\,x_2 + 0.2606857473736294\,x_3 + 1.721110703706202\,x_4 + y_{0,0} = -0.9152180704947402 \\
& -t_{0,0}^2 + y_{0,0}^2 + y_{0,1}^2 + y_{0,2}^2 + y_{0,3}^2 \le 0 \\
& -t_{1,0}^2 + y_{1,0}^2 + y_{1,1}^2 + y_{1,2}^2 + y_{1,3}^2 \le 0 \\
& -t_{2,0}^2 + y_{2,0}^2 + y_{2,1}^2 + y_{2,2}^2 + y_{2,3}^2 \le 0 \\
& x_0,x_1,x_2,x_3,x_4 \in \mathbb{R} \\
& y_{0,0},y_{0,1},y_{0,2},y_{0,3},y_{1,0},y_{1,1},y_{1,2},y_{1,3},y_{2,0},y_{2,1},y_{2,2},y_{2,3} \in \mathbb{R} \\
& t_{0,0},t_{1,0},t_{2,0} \in \mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Optimization_Model"")

# Decision variables
x = m.addVars(5, lb=-GRB.INFINITY, name=""x"")          # x0..x4
y = m.addVars(3, 4, lb=-GRB.INFINITY, name=""y"")       # y[i,j] for i=0..2, j=0..3
t = m.addVars(3, lb=-GRB.INFINITY, name=""t"")          # t[0], t[1], t[2]

# Objective function
m.setObjective(
    -0.4183092460544717 * x[0]
    - 0.2813052479554071 * x[1]
    + 0.134543055273074  * x[2]
    + 0.3293895938730942 * x[3]
    - 0.5013729625677056 * x[4],
    GRB.MINIMIZE
)

# Linear equality constraints
m.addConstr(
    -0.2042258848533399 * x[0]
    + 0.2505367949866907 * x[1]
    - 0.4309025998889995 * x[2]
    + 1.309402520858531   * x[3]
    + 2.586402096787606   * x[4]
    == -3.156703022107761,
    name=""c1""
)
m.addConstr(
    -0.9968810525037243 * x[0]
    - 0.4546685233810487 * x[1]
    + 0.4750317828663017 * x[2]
    + 0.266787146193911   * x[3]
    - 1.191880626574726   * x[4]
    == -2.176991821226254,
    name=""c2""
)
m.addConstr(
    0.349956286844281   * x[0]
    + 1.015584003075466  * x[1]
    - 0.0836288458590485 * x[2]
    - 0.0695677711676667 * x[3]
    + 0.104824587707105  * x[4]
    == 2.926695432150372,
    name=""c3""
)
m.addConstr(
    0.7470800133528747  * x[0]
    + 0.8253890222140957 * x[1]
    + 0.0968330451370987 * x[2
    ] + 0.7049632173662657 * x[3]
    + 0.7872792028260496 * x[4]
    == 0.5732174371789283,
    name=""c4""
)
m.addConstr(
    -1.307269223716067 * x[0]
    + 0.3813744238506016 * x[1]
    - 0.4050739984159557 * x[2]
    + 1.424197873139263 * x[3]
    + 0.4653468565843648 * x[4]
    == -3.193503084865396,
    name=""c5""
)
m.addConstr(
    -0.3645044940419532 * x[0]
    - 1.443832971588788  * x[1]
    + 0.461589002970339  * x[2]
    + 0.2606857473736294 * x[3]
    + 1.721110703706202  * x[4]
    + y[0,0]
    == -0.9152180704947402,
    name=""c6""
)

# Quadratic constraints
m.addConstr(
    gp.quicksum(y[0,j]*y[0,j] for j in range(4)) - t[0]*t[0] <= 0,
    name=""qc0""
)
m.addConstr(
    gp.quicksum(y[1,j]*y[1,j] for j in range(4)) - t[1]*t[1] <= 0,
    name=""qc1""
)
m.addConstr(
    gp.quicksum(y[2,j]*y[2,j] for j in range(4)) - t[2]*t[2] <= 0,
    name=""qc2""
)

# Optimize
m.optimize()
```",-1.650565263,-1.6505653,1,,,,,,,,
"The optimization problem involves minimizing the total cost defined by the weighted contributions of four decision variables: x[0] with a cost of 0.4568048651554198, x[1] with a cost of 0.6822815404386418, x[2] with a cost of 1.801831165946818, and x[3] with a cost of 1.056541158185233. The objective is to minimize the sum of these weighted variables.

The problem is subject to several equality constraints. The first equality constraint is 1.222253726840453 times x[0] minus 0.9058589863483399 times x[1] plus 0.0693521718801037 times x[2] plus 2.178655656494156 times x[3] equals -0.4195106543118642. The second equality constraint is 0.1473169107230136 times x[0] plus 0.5172571290693887 times x[1] minus 1.293979451435283 times x[2] minus 1.054887597556351 times x[3] equals 0.3661434959821696. The third equality constraint is 0.4647687397733393 times x[0] plus 0.2341060054529592 times x[1] plus 1.778866018427452 times x[2] plus 0.8638766717259377 times x[3] equals -1.748015587968725. The fourth equality constraint is -0.0250593592360135 times x[0] minus 0.157487553997023 times x[1] minus 0.6980379871220622 times x[2] minus 0.1710905557322772 times x[3] equals 0.6138465007098338. The fifth equality constraint is -0.6647756257582154 times x[0] plus 0.5784421525498459 times x[1] plus 2.117378290823709 times x[2] minus 0.4463943452167778 times x[3] equals -1.25361991665147.

Additionally, there are auxiliary equality constraints involving variables y_0 and y_1. The first auxiliary constraint is 0.0689239653107249 times x[0] plus 0.0678131299325625 times x[1] minus 0.2023493775147238 times x[2] minus 0.0739358112586078 times x[3] plus y_0[0] equals -0.093423190067388. The second auxiliary constraint is 0.0445323421724085 times x[0] minus 0.0374069933363333 times x[1] minus 0.0947746176074507 times x[2] plus 0.0625716234434831 times x[3] plus y_0[1] equals 0.0993152088054553. The third auxiliary constraint is -0.056297721725534 times x[0] plus 0.0263563878275638 times x[1] minus 0.1207830337883556 times x[2] minus 0.0345530874849539 times x[3] plus y_0[2] equals -0.0719891440967462. The fourth auxiliary constraint is -0.0389348469541953 times x[0] minus 0.0207466886867141 times x[1] minus 0.1633463289784982 times x[2] minus 0.0676994906553111 times x[3] plus y_0[3] equals 0.0610083958048695.

The fifth auxiliary constraint is 0.5721177896133665 times x[0] minus 0.0673019079083626 times x[1] plus 0.0564335910547514 times x[2] minus 0.3663765912716627 times x[3] plus t_0[0] equals 1.173542716306169. The sixth auxiliary constraint is 0.0925151391451339 times x[0] minus 0.1031167146627894 times x[1] plus 0.000327681659276563 times x[2] minus 0.1038664121798131 times x[3] plus y_1[0] equals 0.00701092577147306. The seventh auxiliary constraint is -0.0311602517533045 times x[0] plus 0.0527217587580109 times x[1] plus 0.0357033538861844 times x[2] minus 0.0441292118120421 times x[3] plus y_1[1] equals -0.00804391349899621. The eighth auxiliary constraint is 0.088078411493411 times x[0] plus 0.0425752446328825 times x[1] plus 0.0742562500174835 times x[2] minus 0.0601203608650306 times x[3] plus y_1[2] equals 0.0417669069308694. The ninth auxiliary constraint is 0.0671054419934661 times x[0] minus 0.0455987092328547 times x[1] plus 0.00380146 times x[2] minus 0.0199997335030863 times x[3] plus y_1[3] equals 0.0438732344355552. The tenth auxiliary constraint is 0.6551923068010495 times x[0] plus 0.315985578120184 times x[1] minus 0.1539347685265308 times x[2] minus 0.9668187288441786 times x[3] plus t_1[0] equals 0.9921660803606838.

The problem also includes quadratic inequality constraints to ensure operational feasibility. The first quadratic constraint is negative t_0[0] squared plus y_0[0] squared plus y_0[1] squared plus y_0[2] squared plus y_0[3] squared is less than or equal to zero. The second quadratic constraint is negative t_1[0] squared plus y_1[0] squared plus y_1[1] squared plus y_1[2] squared plus y_1[3] squared is less than or equal to zero.

All decision variables x[0], x[1], x[2], x[3], as well as the auxiliary variables y_0 and y_1, are free to take any real value, meaning there are no explicit upper or lower bounds on these variables. The auxiliary variables t_0[0] and t_1[0] are also free to take any real value. The problem is a Second-Order Cone Programming (SOCP) problem, as indicated by the quadratic constraints.","\[
\begin{aligned}
\min\;&0.4568048651554198\,x_0+0.6822815404386418\,x_1+1.801831165946818\,x_2+1.056541158185233\,x_3\\
\text{s.t. }&1.222253726840453\,x_0-0.9058589863483399\,x_1+0.0693521718801037\,x_2+2.178655656494156\,x_3=-0.4195106543118642\\
&0.1473169107230136\,x_0+0.5172571290693887\,x_1-1.293979451435283\,x_2-1.054887597556351\,x_3=0.3661434959821696\\
&0.4647687397733393\,x_0+0.2341060054529592\,x_1+1.778866018427452\,x_2+0.8638766717259377\,x_3=-1.748015587968725\\
&-0.0250593592360135\,x_0-0.157487553997023\,x_1-0.6980379871220622\,x_2-0.1710905557322772\,x_3=0.6138465007098338\\
&-0.6647756257582154\,x_0+0.5784421525498459\,x_1+2.117378290823709\,x_2-0.4463943452167778\,x_3=-1.25361991665147\\
&0.0689239653107249\,x_0+0.0678131299325625\,x_1-0.2023493775147238\,x_2-0.0739358112586078\,x_3+y_{0,0}=-0.093423190067388\\
&0.0445323421724085\,x_0-0.0374069933363333\,x_1-0.0947746176074507\,x_2+0.0625716234434831\,x_3+y_{0,1}=0.0993152088054553\\
&-0.056297721725534\,x_0+0.0263563878275638\,x_1-0.1207830337883556\,x_2-0.0345530874849539\,x_3+y_{0,2}=-0.0719891440967462\\
&-0.0389348469541953\,x_0-0.0207466886867141\,x_1-0.1633463289784982\,x_2-0.0676994906553111\,x_3+y_{0,3}=0.0610083958048695\\
&0.5721177896133665\,x_0-0.0673019079083626\,x_1+0.0564335910547514\,x_2-0.3663765912716627\,x_3+t_{0,0}=1.173542716306169\\
&0.0925151391451339\,x_0-0.1031167146627894\,x_1+0.000327681659276563\,x_2-0.1038664121798131\,x_3+y_{1,0}=0.00701092577147306\\
&-0.0311602517533045\,x_0+0.0527217587580109\,x_1+0.0357033538861844\,x_2-0.0441292118120421\,x_3+y_{1,1}=-0.00804391349899621\\
&0.088078411493411\,x_0+0.0425752446328825\,x_1+0.0742562500174835\,x_2-0.0601203608650306\,x_3+y_{1,2}=0.0417669069308694\\
&0.0671054419934661\,x_0-0.0455987092328547\,x_1+0.00380146\,x_2-0.0199997335030863\,x_3+y_{1,3}=0.0438732344355552\\
&0.6551923068010495\,x_0+0.315985578120184\,x_1-0.1539347685265308\,x_2-0.9668187288441786\,x_3+t_{1,0}=0.9921660803606838\\
&-t_{0,0}^2+y_{0,0}^2+y_{0,1}^2+y_{0,2}^2+y_{0,3}^2\le0\\
&-t_{1,0}^2+y_{1,0}^2+y_{1,1}^2+y_{1,2}^2+y_{1,3}^2\le0\\
&x_0,x_1,x_2,x_3,y_{0,0},y_{0,1},y_{0,2},y_{0,3},y_{1,0},y_{1,1},y_{1,2},y_{1,3},t_{0,0},t_{1,0}\in\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Quadratic_Optimization"")

# Decision variables
x0 = m.addVar(vtype=GRB.CONTINUOUS, name=""x0"")
x1 = m.addVar(vtype=GRB.CONTINUOUS, name=""x1"")
x2 = m.addVar(vtype=GRB.CONTINUOUS, name=""x2"")
x3 = m.addVar(vtype=GRB.CONTINUOUS, name=""x3"")

y00 = m.addVar(vtype=GRB.CONTINUOUS, name=""y00"")
y01 = m.addVar(vtype=GRB.CONTINUOUS, name=""y01"")
y02 = m.addVar(vtype=GRB.CONTINUOUS, name=""y02"")
y03 = m.addVar(vtype=GRB.CONTINUOUS, name=""y03"")

y10 = m.addVar(vtype=GRB.CONTINUOUS, name=""y10"")
y11 = m.addVar(vtype=GRB.CONTINUOUS, name=""y11"")
y12 = m.addVar(vtype=GRB.CONTINUOUS, name=""y12"")
y13 = m.addVar(vtype=GRB.CONTINUOUS, name=""y13"")

t00 = m.addVar(vtype=GRB.CONTINUOUS, name=""t00"")
t10 = m.addVar(vtype=GRB.CONTINUOUS, name=""t10"")

# Objective function
m.setObjective(
    0.4568048651554198 * x0
    + 0.6822815404386418 * x1
    + 1.801831165946818 * x2
    + 1.056541158185233 * x3,
    GRB.MINIMIZE
)

# Linear equality constraints
m.addConstr(
    1.222253726840453 * x0
    - 0.9058589863483399 * x1
    + 0.0693521718801037 * x2
    + 2.178655656494156 * x3
    == -0.4195106543118642,
    name=""eq1""
)
m.addConstr(
    0.1473169107230136 * x0
    + 0.5172571290693887 * x1
    - 1.293979451435283 * x2
    - 1.054887597556351 * x3
    == 0.3661434959821696,
    name=""eq2""
)
m.addConstr(
    0.4647687397733393 * x0
    + 0.2341060054529592 * x1
    + 1.778866018427452 * x2
    + 0.8638766717259377 * x3
    == -1.748015587968725,
    name=""eq3""
)
m.addConstr(
    -0.0250593592360135 * x0
    - 0.157487553997023 * x1
    - 0.6980379871220622 * x2
    - 0.1710905557322772 * x3
    == 0.6138465007098338,
    name=""eq4""
)
m.addConstr(
    -0.6647756257582154 * x0
    + 0.5784421525498459 * x1
    + 2.117378290823709 * x2
    - 0.4463943452167778 * x3
    == -1.25361991665147,
    name=""eq5""
)
m.addConstr(
    0.0689239653107249 * x0
    + 0.0678131299325625 * x1
    - 0.2023493775147238 * x2
    - 0.0739358112586078 * x3
    + y00
    == -0.093423190067388,
    name=""eq6""
)
m.addConstr(
    0.0445323421724085 * x0
    - 0.0374069933363333 * x1
    - 0.0947746176074507 * x2
    + 0.0625716234434831 * x3
    + y01
    == 0.0993152088054553,
    name=""eq7""
)
m.addConstr(
    -0.056297721725534 * x0
    + 0.0263563878275638 * x1
    - 0.1207830337883556 * x2
    - 0.0345530874849539 * x3
    + y02
    == -0.0719891440967462,
    name=""eq8""
)
m.addConstr(
    -0.0389348469541953 * x0
    - 0.0207466886867141 * x1
    - 0.1633463289784982 * x2
    - 0.0676994906553111 * x3
    + y03
    == 0.0610083958048695,
    name=""eq9""
)
m.addConstr(
    0.5721177896133665 * x0
    - 0.0673019079083626 * x1
    + 0.0564335910547514 * x2
    - 0.3663765912716627 * x3
    + t00
    == 1.173542716306169,
    name=""eq10""
)
m.addConstr(
    0.0925151391451339 * x0
    - 0.1031167146627894 * x1
    + 0.000327681659276563 * x2
    - 0.1038664121798131 * x3
    + y10
    == 0.00701092577147306,
    name=""eq11""
)
m.addConstr(
    -0.0311602517533045 * x0
    + 0.0527217587580109 * x1
    + 0.0357033538861844 * x2
    - 0.0441292118120421 * x3
    + y11
    == -0.00804391349899621,
    name=""eq12""
)
m.addConstr(
    0.088078411493411 * x0
    + 0.0425752446328825 * x1
    + 0.0742562500174835 * x2
    - 0.0601203608650306 * x3
    + y12
    == 0.0417669069308694,
    name=""eq13""
)
m.addConstr(
    0.0671054419934661 * x0
    - 0.0455987092328547 * x1
    + 0.00380146 * x2
    - 0.0199997335030863 * x3
    + y13
    == 0.0438732344355552,
    name=""eq14""
)
m.addConstr(
    0.6551923068010495 * x0
    + 0.315985578120184 * x1
    - 0.1539347685265308 * x2
    - 0.9668187288441786 * x3
    + t10
    == 0.9921660803606838,
    name=""eq15""
)

# Quadratic constraints
m.addQConstr(
    -t00 * t00
    + y00 * y00
    + y01 * y01
    + y02 * y02
    + y03 * y03
    <= 0,
    name=""quad1""
)
m.addQConstr(
    -t10 * t10
    + y10 * y10
    + y11 * y11
    + y12 * y12
    + y13 * y13
    <= 0,
    name=""quad2""
)

# Optimize
m.optimize()
",,-2.2839945,0,,,,,,,,
"The problem involves minimizing the total cost of allocating three resources, \(x_0\), \(x_1\), and \(x_2\), where allocating one unit of \(x_0\) reduces the cost by 0.4471510837992146 units, allocating one unit of \(x_1\) reduces the cost by 0.5249098983165018 units, and allocating one unit of \(x_2\) increases the cost by 1.523631136652647 units. The allocation must satisfy five linear equality constraints:
1. The combined allocation of \(x_0\), \(x_1\), and \(x_2\) must result in a net value of 0.7034913153072593, with \(x_0\) contributing -0.3702651403450675, \(x_1\) contributing 0.7297352123799089, and \(x_2\) contributing 0.418858390580152.
2. The allocation must balance out to -0.1118855888702875, with \(x_0\) contributing 0.4153630032109168, \(x_1\) contributing 1.22940502964378, and \(x_2\) contributing -0.369836178888419.
3. The allocation must balance out to -0.0870555137122539, with \(x_0\) contributing 0.6396510452716259, \(x_1\) contributing -0.9807875135502231, and \(x_2\) contributing 1.032537634661943.
4. The allocation must balance out to -1.503406234028836, with \(x_0\) contributing 1.154571984507194, \(x_1\) contributing -0.0797094266894998, and \(x_2\) contributing -1.259256932824717.
5. The allocation must balance out to 0.4968828204562829, with \(x_0\) contributing -0.7680742354583855, \(x_1\) contributing -1.463758817488339, and \(x_2\) contributing 0.7608599270643391.

Additionally, four auxiliary variables \(y_0[0]\), \(y_0[1]\), \(y_0[2]\), and \(t_0[0]\) are introduced, which are determined by the following linear equations:
- \(y_0[0]\) is determined by \(0.149372637294763 \cdot x_0 - 0.0700461252415553 \cdot x_1 + 0.0637326829867655 \cdot x_2 = -0.1129095562448545\).
- \(y_0[1]\) is determined by \(-0.0658271548457527 \cdot x_0 + 0.0224831194568463 \cdot x_1 - 0.00639053916626198 \cdot x_2 = -0.0490454717367705\).
- \(y_0[2]\) is determined by \(-0.00559770209526484 \cdot x_0 - 0.1749117419573911 \cdot x_1 - 0.0549153174437265 \cdot x_2 = 0.0268845405956578\).
- \(t_0[0]\) is determined by \(0.2634865225900492 \cdot x_0 + 1.089839700108032 \cdot x_1 - 1.345710871710692 \cdot x_2 = 0.2701569757905559\).

A second-order cone constraint is imposed, requiring that the sum of the squares of \(y_0[0]\), \(y_0[1]\), and \(y_0[2]\) should not exceed the square of \(t_0[0]\). All decision variables \(x_0\), \(x_1\), \(x_2\), \(y_0[0]\), \(y_0[1]\), \(y_0[2]\), and \(t_0[0]\) are free to take any real value, meaning there are no upper or lower bounds imposed on their values. The goal is to determine the optimal allocation of \(x_0\), \(x_1\), and \(x_2\) to minimize the total cost while satisfying all the above constraints, including the second-order cone constraint. This is a Second-Order Cone Programming (SOCP) problem.","\[
\begin{aligned}
\min\quad & -0.4471510837992146\,x_0 \;-\;0.5249098983165018\,x_1 \;+\;1.523631136652647\,x_2\\
\text{s.t.}\quad
&-0.3702651403450675\,x_0 \;+\;0.7297352123799089\,x_1 \;+\;0.418858390580152\,x_2 \;=\;0.7034913153072593\\
&0.4153630032109168\,x_0 \;+\;1.22940502964378\,x_1 \;-\;0.369836178888419\,x_2 \;=\;-0.1118855888702875\\
&0.6396510452716259\,x_0 \;-\;0.9807875135502231\,x_1 \;+\;1.032537634661943\,x_2 \;=\;-0.0870555137122539\\
&1.154571984507194\,x_0 \;-\;0.0797094266894998\,x_1 \;-\;1.259256932824717\,x_2 \;=\;-1.503406234028836\\
&-0.7680742354583855\,x_0 \;-\;1.463758817488339\,x_1 \;+\;0.7608599270643391\,x_2 \;=\;0.4968828204562829\\
&0.149372637294763\,x_0 \;-\;0.0700461252415553\,x_1 \;+\;0.0637326829867655\,x_2 \;-\;y_0[0] \;=\;-0.1129095562448545\\
&-0.0658271548457527\,x_0 \;+\;0.0224831194568463\,x_1 \;-\;0.00639053916626198\,x_2 \;-\;y_0[1] \;=\;-0.0490454717367705\\
&-0.00559770209526484\,x_0 \;-\;0.1749117419573911\,x_1 \;-\;0.0549153174437265\,x_2 \;-\;y_0[2] \;=\;0.0268845405956578\\
&0.2634865225900492\,x_0 \;+\;1.089839700108032\,x_1 \;-\;1.345710871710692\,x_2 \;-\;t_0[0] \;=\;0.2701569757905559\\
&\sqrt{\,y_0[0]^2 + y_0[1]^2 + y_0[2]^2\,}\;\le\;t_0[0]
\end{aligned}
\quad
x_0,x_1,x_2,y_0[0],y_0[1],y_0[2],t_0[0]\in\mathbb{R}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""OptimizationModel"")

# Decision variables
x0 = m.addVar(vtype=GRB.CONTINUOUS, name=""x0"")
x1 = m.addVar(vtype=GRB.CONTINUOUS, name=""x1"")
x2 = m.addVar(vtype=GRB.CONTINUOUS, name=""x2"")
y0_0 = m.addVar(vtype=GRB.CONTINUOUS, name=""y0_0"")
y0_1 = m.addVar(vtype=GRB.CONTINUOUS, name=""y0_1"")
y0_2 = m.addVar(vtype=GRB.CONTINUOUS, name=""y0_2"")
t0_0 = m.addVar(vtype=GRB.CONTINUOUS, name=""t0_0"")

# Objective function: minimize -0.4471510837992146*x0 -0.5249098983165018*x1 + 1.523631136652647*x2
m.setObjective(-0.4471510837992146 * x0 - 0.5249098983165018 * x1 + 1.523631136652647 * x2, GRB.MINIMIZE)

# Linear constraints
m.addConstr(-0.3702651403450675 * x0 + 0.7297352123799089 * x1 + 0.418858390580152 * x2 == 0.7034913153072593, name=""c1"")
m.addConstr(0.4153630032109168 * x0 + 1.22940502964378 * x1 - 0.369836178888419 * x2 == -0.1118855888702875, name=""c2"")
m.addConstr(0.6396510452716259 * x0 - 0.9807875135502231 * x1 + 1.032537634661943 * x2 == -0.0870555137122539, name=""c3"")
m.addConstr(1.154571984507194 * x0 - 0.0797094266894998 * x1 - 1.259256932824717 * x2 == -1.503406234028836, name=""c4"")
m.addConstr(-0.7680742354583855 * x0 - 1.463758817488339 * x1 + 0.7608599270643391 * x2 == 0.4968828204562829, name=""c5"")

m.addConstr(0.149372637294763 * x0 - 0.0700461252415553 * x1 + 0.0637326829867655 * x2 - y0_0 == -0.1129095562448545, name=""c6"")
m.addConstr(-0.0658271548457527 * x0 + 0.0224831194568463 * x1 - 0.00639053916626198 * x2 - y0_1 == -0.0490454717367705, name=""c7"")
m.addConstr(-0.00559770209526484 * x0 - 0.1749117419573911 * x1 - 0.0549153174437265 * x2 - y0_2 == 0.0268845405956578, name=""c8"")

m.addConstr(0.2634865225900492 * x0 + 1.089839700108032 * x1 - 1.345710871710692 * x2 - t0_0 == 0.2701569757905559, name=""c9"")

# Nonlinear constraint: sqrt(y0_0^2 + y0_1^2 + y0_2^2) <= t0_0
# Equivalent to y0_0^2 + y0_1^2 + y0_2^2 <= t0_0^2
m.addQConstr(y0_0 * y0_0 + y0_1 * y0_1 + y0_2 * y0_2 <= t0_0 * t0_0, name=""c10"")

# Ensure t0_0 is nonnegative
m.addConstr(t0_0 >= 0, name=""t_nonneg"")

# Optimize
m.optimize()
",,1.030339884,0,,,,,,,,
"The optimization problem involves minimizing the total operational cost, calculated as -0.6407821570716368 times the resource allocation at Hub 0, plus 0.1282093451424064 times the allocation at Hub 1, plus 0.5610539844701511 times the allocation at Hub 2, minus 0.7387913261851949 times the allocation at Hub 3, minus 0.6386135273718804 times the allocation at Hub 4. The resource allocations at each hub must satisfy three operational balance equations. The first equation states that 0.8358787628285221 times the allocation at Hub 0, minus 0.3221455044008418 times the allocation at Hub 1, plus 0.1449025416792807 times the allocation at Hub 2, minus 1.143088864150698 times the allocation at Hub 3, minus 0.2961821681740678 times the allocation at Hub 4, equals -0.3533166906383274. The second equation requires that -0.00318416966765216 times the allocation at Hub 0, plus 0.0636663117252584 times the allocation at Hub 1, minus 0.6335115786242427 times the allocation at Hub 2, plus 0.7906235569218798 times the allocation at Hub 3, plus 1.611869546160813 times the allocation at Hub 4, equals 0.6687613216515473. The third equation specifies that 0.6413661217416131 times the allocation at Hub 0, plus 0.4316049771976506 times the allocation at Hub 1, minus 2.705808657534711 times the allocation at Hub 2, minus 0.4442117847616459 times the allocation at Hub 3, plus 0.1130949341290518 times the allocation at Hub 4, equals -3.522255392214968.

Each hub has additional constraints linking resource allocations to secondary operational metrics. For Hub 0, 1.486108997408437 times the allocation at Hub 0, plus 1.031757962743657 times the allocation at Hub 1, minus 0.4518720885240323 times the allocation at Hub 2, minus 0.3480442946563601 times the allocation at Hub 3, plus 1.580022153897245 times the allocation at Hub 4, plus the auxiliary variable y_0[0], equals -0.2475605897441492. Similarly, for Hub 0, -0.4066096523615669 times the allocation at Hub 0, minus 1.175211752170571 times the allocation at Hub 1, minus 0.7069411728647763 times the allocation at Hub 2, plus 0.836056412101241 times the allocation at Hub 3, minus 0.8926238938498942 times the allocation at Hub 4, plus the auxiliary variable y_0[1], equals 0.3074449602324441. Additionally, for Hub 0, -0.0569892486285832 times the allocation at Hub 0, plus 0.1233562548906215 times the allocation at Hub 1, minus 0.7134682305447539 times the allocation at Hub 2, minus 0.6038275844685674 times the allocation at Hub 3, minus 1.619511303009083 times the allocation at Hub 4, plus the auxiliary variable t_0[0], equals 0.2204862656053741.

Similar constraints are specified for Hubs 1 to 4. For Hub 1, -1.294423006398278 times the allocation at Hub 0, plus 1.346172260047954 times the allocation at Hub 1, minus 0.358451283614951 times the allocation at Hub 2, minus 1.928440987292954 times the allocation at Hub 3, plus 1.126221395948665 times the allocation at Hub 4, plus y_1[0], equals 1.376491310478152. For Hub 1, 0.5609955781941032 times the allocation at Hub 0, minus 0.0458140884642076 times the allocation at Hub 1, minus 0.0344324048732548 times the allocation at Hub 2, plus 0.4252922167535212 times the allocation at Hub 3, minus 1.28973345438307 times the allocation at Hub 4, plus y_1[1], equals 0.051955328245377. For Hub 1, 0.0627617087678124 times the allocation at Hub 0, plus 1.313586666171607 times the allocation at Hub 1, minus 0.0750373702925165 times the allocation at Hub 2, plus 0.8637943589659705 times the allocation at Hub 3, minus 2.128672133715813 times the allocation at Hub 4, plus t_1[0], equals 0.4369998177620138.

For Hub 2, 0.00108296658143404 times the allocation at Hub 0, plus 0.1150269209288099 times the allocation at Hub 1, minus 0.058430562821969 times the allocation at Hub 2, plus 0.1809260750957712 times the allocation at Hub 3, minus 0.107839460895758 times the allocation at Hub 4, plus y_2[0], equals -0.0466779941627568. For Hub 2, 0.1638929872378048 times the allocation at Hub 0, minus 0.0440335287917339 times the allocation at Hub 1, plus 0.1119306383643067 times the allocation at Hub 2, plus 0.0829079267212388 times the allocation at Hub 3, minus 0.0762160399972494 times the allocation at Hub 4, plus y_2[1], equals 0.1065935090322246. For Hub 2, 1.78119670849211 times the allocation at Hub 0, minus 0.9909783216060062 times the allocation at Hub 1, minus 1.08396186916195 times the allocation at Hub 2, minus 0.2137547994124323 times the allocation at Hub 3, minus 0.2410135384227864 times the allocation at Hub 4, plus t_2[0], equals 0.5794902323601145.

For Hub 3, -0.0641439226811574 times the allocation at Hub 0, minus 0.0718053951291886 times the allocation at Hub 1, plus 0.0269862978161679 times the allocation at Hub 2, plus 0.1102601358034707 times the allocation at Hub 3, plus 7.27392e-05 times the allocation at Hub 4, plus y_3[0], equals 0.00315977947277087. For Hub 3, -0.0632288388926973 times the allocation at Hub 0, minus 0.1241779187569768 times the allocation at Hub 1, plus 0.0064629944919384 times the allocation at Hub 2, plus 0.0116896390416125 times the allocation at Hub 3, plus 0.079988047761199 times the allocation at Hub 4, plus y_3[1], equals 0.0925241950659326. For Hub 3, 0.4429906926189995 times the allocation at Hub 0, plus 0.0991542311544501 times the allocation at Hub 1, minus 0.3240726565893556 times the allocation at Hub 2, minus 0.6543525499518488 times the allocation at Hub 3, minus 0.318896820227852 times the allocation at Hub 4, plus t_3[0], equals 0.1889924405903281.

For Hub 4, 0.0341804938689715 times the allocation at Hub 0, minus 0.1200246209041026 times the allocation at Hub 1, plus 0.0477968354488662 times the allocation at Hub 2, plus 0.0486460651624679 times the allocation at Hub 3, plus 0.0259780092785045 times the allocation at Hub 4, plus y_4[0], equals 0.1858842417400162. For Hub 4, -0.0427025044864235 times the allocation at Hub 0, minus 0.1161557760668262 times the allocation at Hub 1, minus 0.1281191768228226 times the allocation at Hub 2, plus 0.1296447474115312 times the allocation at Hub 3, minus 0.16357870291776 times the allocation at Hub 4, plus y_4[1], equals 0.0601306829794548. For Hub 4, 0.2140065823499792 times the allocation at Hub 0, minus 0.2328142561302691 times the allocation at Hub 1, minus 0.848196376440762 times the allocation at Hub 2, minus 0.5073797164375169 times the allocation at Hub 3, minus 2.928182945709474 times the allocation at Hub 4, plus t_4[0], equals 1.310467204578853.

To ensure operational feasibility, each hub must satisfy a second-order cone constraint. For Hub 0, the sum of the squares of y_0[0] and y_0[1] must be less than or equal to the square of t_0[0]. Similarly, for Hub 1, the sum of the squares of y_1[0] and y_1[1] must be less than or equal to the square of t_1[0]. For Hub 2, the sum of the squares of y_2[0] and y_2[1] must be less than or equal to the square of t_2[0]. For Hub 3, the sum of the squares of y_3[0] and y_3[1] must be less than or equal to the square of t_3[0]. For Hub 4, the sum of the squares of y_4[0] and y_4[1] must be less than or equal to the square of t_4[0].

All variables, including resource allocations and auxiliary variables, are free to take any real value, allowing for flexible resource allocation to minimize costs while satisfying all operational constraints. The problem is a Second-Order Cone Programming (SOCP) problem, as it involves quadratic constraints represented by the second-order cone constraints. The equality constraints are linear, while the additional constraints (R3 to R17) link resource allocations to secondary operational metrics. The auxiliary variables (y_0[0], y_0[1], t_0[0], etc.) are part of the second-order cone constraints, and all variables (x[0] to x[4], y_0[0], y_0[1], y_1[0], y_1[1], etc., and t_0[0], t_1[0], t_2[0], etc.) are free variables.","\[
\begin{aligned}
\min\;&-0.6407821570716368\,x_0+0.1282093451424064\,x_1+0.5610539844701511\,x_2-0.7387913261851949\,x_3-0.6386135273718804\,x_4\\
\text{s.t.}\;&0.8358787628285221\,x_0-0.3221455044008418\,x_1+0.1449025416792807\,x_2-1.143088864150698\,x_3-0.2961821681740678\,x_4=-0.3533166906383274\\
&-0.00318416966765216\,x_0+0.0636663117252584\,x_1-0.6335115786242427\,x_2+0.7906235569218798\,x_3+1.611869546160813\,x_4=0.6687613216515473\\
&0.6413661217416131\,x_0+0.4316049771976506\,x_1-2.705808657534711\,x_2-0.4442117847616459\,x_3+0.1130949341290518\,x_4=-3.522255392214968\\
&1.486108997408437\,x_0+1.031757962743657\,x_1-0.4518720885240323\,x_2-0.3480442946563601\,x_3+1.580022153897245\,x_4+y_{0,0}=-0.2475605897441492\\
&-0.4066096523615669\,x_0-1.175211752170571\,x_1-0.7069411728647763\,x_2+0.836056412101241\,x_3-0.8926238938498942\,x_4+y_{0,1}=0.3074449602324441\\
&-0.0569892486285832\,x_0+0.1233562548906215\,x_1-0.7134682305447539\,x_2-0.6038275844685674\,x_3-1.619511303009083\,x_4+t_{0,0}=0.2204862656053741\\
&-1.294423006398278\,x_0+1.346172260047954\,x_1-0.358451283614951\,x_2-1.928440987292954\,x_3+1.126221395948665\,x_4+y_{1,0}=1.376491310478152\\
&0.5609955781941032\,x_0-0.0458140884642076\,x_1-0.0344324048732548\,x_2+0.4252922167535212\,x_3-1.28973345438307\,x_4+y_{1,1}=0.051955328245377\\
&0.0627617087678124\,x_0+1.313586666171607\,x_1-0.0750373702925165\,x_2+0.8637943589659705\,x_3-2.128672133715813\,x_4+t_{1,0}=0.4369998177620138\\
&0.00108296658143404\,x_0+0.1150269209288099\,x_1-0.058430562821969\,x_2+0.1809260750957712\,x_3-0.107839460895758\,x_4+y_{2,0}=-0.0466779941627568\\
&0.1638929872378048\,x_0-0.0440335287917339\,x_1+0.1119306383643067\,x_2+0.0829079267212388\,x_3-0.0762160399972494\,x_4+y_{2,1}=0.1065935090322246\\
&1.78119670849211\,x_0-0.9909783216060062\,x_1-1.08396186916195\,x_2-0.2137547994124323\,x_3-0.2410135384227864\,x_4+t_{2,0}=0.5794902323601145\\
&-0.0641439226811574\,x_0-0.0718053951291886\,x_1+0.0269862978161679\,x_2+0.1102601358034707\,x_3+7.27392\times10^{-5}\,x_4+y_{3,0}=0.00315977947277087\\
&-0.0632288388926973\,x_0-0.1241779187569768\,x_1+0.0064629944919384\,x_2+0.0116896390416125\,x_3+0.079988047761199\,x_4+y_{3,1}=0.0925241950659326\\
&0.4429906926189995\,x_0+0.0991542311544501\,x_1-0.3240726565893556\,x_2-0.6543525499518488\,x_3-0.318896820227852\,x_4+t_{3,0}=0.1889924405903281\\
&0.0341804938689715\,x_0-0.1200246209041026\,x_1+0.0477968354488662\,x_2+0.0486460651624679\,x_3+0.0259780092785045\,x_4+y_{4,0}=0.1858842417400162\\
&-0.0427025044864235\,x_0-0.1161557760668262\,x_1-0.1281191768228226\,x_2+0.1296447474115312\,x_3-0.16357870291776\,x_4+y_{4,1}=0.0601306829794548\\
&0.2140065823499792\,x_0-0.2328142561302691\,x_1-0.848196376440762\,x_2-0.5073797164375169\,x_3-2.928182945709474\,x_4+t_{4,0}=1.310467204578853\\
&y_{0,0}^2+y_{0,1}^2\le t_{0,0}^2\\
&y_{1,0}^2+y_{1,1}^2\le t_{1,0}^2\\
&y_{2,0}^2+y_{2,1}^2\le t_{2,0}^2\\
&y_{3,0}^2+y_{3,1}^2\le t_{3,0}^2\\
&y_{4,0}^2+y_{4,1}^2\le t_{4,0}^2\\
&x_0,x_1,x_2,x_3,x_4\in\mathbb{R}\\
&y_{0,0},y_{0,1},y_{1,0},y_{1,1},y_{2,0},y_{2,1},y_{3,0},y_{3,1},y_{4,0},y_{4,1}\in\mathbb{R}\\
&t_{0,0},t_{1,0},t_{2,0},t_{3,0},t_{4,0}\in\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Optimization_Model"")

# Decision variables
x0 = m.addVar(name=""x0"")
x1 = m.addVar(name=""x1"")
x2 = m.addVar(name=""x2"")
x3 = m.addVar(name=""x3"")
x4 = m.addVar(name=""x4"")

y0_0 = m.addVar(name=""y0_0"")
y0_1 = m.addVar(name=""y0_1"")
y1_0 = m.addVar(name=""y1_0"")
y1_1 = m.addVar(name=""y1_1"")
y2_0 = m.addVar(name=""y2_0"")
y2_1 = m.addVar(name=""y2_1"")
y3_0 = m.addVar(name=""y3_0"")
y3_1 = m.addVar(name=""y3_1"")
y4_0 = m.addVar(name=""y4_0"")
y4_1 = m.addVar(name=""y4_1"")

t0_0 = m.addVar(name=""t0_0"")
t1_0 = m.addVar(name=""t1_0"")
t2_0 = m.addVar(name=""t2_0"")
t3_0 = m.addVar(name=""t3_0"")
t4_0 = m.addVar(name=""t4_0"")

# Objective function
m.setObjective(
    -0.6407821570716368 * x0
    + 0.1282093451424064 * x1
    + 0.5610539844701511 * x2
    - 0.7387913261851949 * x3
    - 0.6386135273718804 * x4,
    GRB.MINIMIZE
)

# Linear equality constraints
m.addConstr(0.8358787628285221 * x0
            - 0.3221455044008418 * x1
            + 0.1449025416792807 * x2
            - 1.143088864150698 * x3
            - 0.2961821681740678 * x4 == -0.3533166906383274,
            name=""c1"")

m.addConstr(-0.00318416966765216 * x0
            + 0.0636663117252584 * x1
            - 0.6335115786242427 * x2
            + 0.7906235569218798 * x3
            + 1.611869546160813 * x4 == 0.6687613216515473,
            name=""c2"")

m.addConstr(0.6413661217416131 * x0
            + 0.4316049771976506 * x1
            - 2.705808657534711 * x2
            - 0.4442117847616459 * x3
            + 0.1130949341290518 * x4 == -3.522255392214968,
            name=""c3"")

m.addConstr(1.486108997408437 * x0
            + 1.031757962743657 * x1
            - 0.4518720885240323 * x2
            - 0.3480442946563601 * x3
            + 1.580022153897245 * x4
            + y0_0 == -0.2475605897441492,
            name=""c4"")

m.addConstr(-0.4066096523615669 * x0
            - 1.175211752170571 * x1
            - 0.7069411728647763 * x2
            + 0.836056412101241 * x3
            - 0.8926238938498942 * x4
            + y0_1 == 0.3074449602324441,
            name=""c5"")

m.addConstr(-0.0569892486285832 * x0
            + 0.1233562548906215 * x1
            - 0.7134682305447539 * x2
            - 0.6038275844685674 * x3
            - 1.619511303009083 * x4
            + t0_0 == 0.2204862656053741,
            name=""c6"")

m.addConstr(-1.294423006398278 * x0
            + 1.346172260047954 * x1
            - 0.358451283614951 * x2
            - 1.928440987292954 * x3
            + 1.126221395948665 * x4
            + y1_0 == 1.376491310478152,
            name=""c7"")

m.addConstr(0.5609955781941032 * x0
            - 0.0458140884642076 * x1
            - 0.0344324048732548 * x2
            + 0.4252922167535212 * x3
            - 1.28973345438307 * x4
            + y1_1 == 0.051955328245377,
            name=""c8"")

m.addConstr(0.0627617087678124 * x0
            + 1.313586666171607 * x1
            - 0.0750373702925165 * x2
            + 0.8637943589659705 * x3
            - 2.128672133715813 * x4
            + t1_0 == 0.4369998177620138,
            name=""c9"")

m.addConstr(0.00108296658143404 * x0
            + 0.1150269209288099 * x1
            - 0.058430562821969 * x2
            + 0.1809260750957712 * x3
            - 0.107839460895758 * x4
            + y2_0 == -0.0466779941627568,
            name=""c10"")

m.addConstr(0.1638929872378048 * x0
            - 0.0440335287917339 * x1
            + 0.1119306383643067 * x2
            + 0.0829079267212388 * x3
            - 0.0762160399972494 * x4
            + y2_1 == 0.1065935090322246,
            name=""c11"")

m.addConstr(1.78119670849211 * x0
            - 0.9909783216060062 * x1
            - 1.08396186916195 * x2
            - 0.2137547994124323 * x3
            - 0.2410135384227864 * x4
            + t2_0 == 0.5794902323601145,
            name=""c12"")

m.addConstr(-0.0641439226811574 * x0
            - 0.0718053951291886 * x1
            + 0.0269862978161679 * x2
            + 0.1102601358034707 * x3
            + 7.27392e-05 * x4
            + y3_0 == 0.00315977947277087,
            name=""c13"")

m.addConstr(-0.0632288388926973 * x0
            - 0.1241779187569768 * x1
            + 0.0064629944919384 * x2
            + 0.0116896390416125 * x3
            + 0.079988047761199 * x4
            + y3_1 == 0.0925241950659326,
            name=""c14"")

m.addConstr(0.4429906926189995 * x0
            + 0.0991542311544501 * x1
            - 0.3240726565893556 * x2
            - 0.6543525499518488 * x3
            - 0.318896820227852 * x4
            + t3_0 == 0.1889924405903281,
            name=""c15"")

m.addConstr(0.0341804938689715 * x0
            - 0.1200246209041026 * x1
            + 0.0477968354488662 * x2
            + 0.0486460651624679 * x3
            + 0.0259780092785045 * x4
            + y4_0 == 0.1858842417400162,
            name=""c16"")

m.addConstr(-0.0427025044864235 * x0
            - 0.1161557760668262 * x1
            - 0.1281191768228226 * x2
            + 0.1296447474115312 * x3
            - 0.16357870291776 * x4
            + y4_1 == 0.0601306829794548,
            name=""c17"")

m.addConstr(0.2140065823499792 * x0
            - 0.2328142561302691 * x1
            - 0.848196376440762 * x2
            - 0.5073797164375169 * x3
            - 2.928182945709474 * x4
            + t4_0 == 1.310467204578853,
            name=""c18"")

# Quadratic constraints
m.addQConstr(y0_0 * y0_0 + y0_1 * y0_1 <= t0_0 * t0_0, name=""q1"")
m.addQConstr(y1_0 * y1_0 + y1_1 * y1_1 <= t1_0 * t1_0, name=""q2"")
m.addQConstr(y2_0 * y2_0 + y2_1 * y2_1 <= t2_0 * t2_0, name=""q3"")
m.addQConstr(y3_0 * y3_0 + y3_1 * y3_1 <= t3_0 * t3_0, name=""q4"")
m.addQConstr(y4_0 * y4_0 + y4_1 * y4_1 <= t4_0 * t4_0, name=""q5"")

# Optimize
m.optimize()
```",,-0.1796539,0,,,,,,,,
"The problem involves minimizing the total cost calculated as 0.408544260832344 times the value of x[0] minus 1.177163209326489 times the value of x[1] minus 0.3033727028272864 times the value of x[2]. This minimization is subject to several constraints: the first linear constraint requires that 0.5462940531635887 times x[0] minus 1.241668902664911 times x[1] minus 0.5998249994903344 times x[2] equals 0.3835911096798181. The second linear constraint requires that negative 0.030455142845263 times x[0] minus 0.7427336810498593 times x[1] plus 0.3957667498639689 times x[2] equals negative 0.6803383944729795. Another constraint, R2, requires that negative 0.0677712816971205 times x[0] plus 0.170365390174673 times x[1] minus 0.00413868631847959 times x[2] plus y_0[0] equals 0.00802717043497164. Constraint R3 requires that 0.0215916329150542 times x[0] minus 0.0479685166742133 times x[1] plus 0.0677847235104595 times x[2] plus y_0[1] equals negative 0.1511858316417728. Constraint R4 requires that negative 0.219725429611857 times x[0] minus 1.453471058496226 times x[1] minus 0.5544082541070903 times x[2] plus t_0[0] equals 1.182764044680309. Additionally, the square of t_0[0] must be less than or equal to the sum of the squares of y_0[0] and y_0[1], represented by the constraint negative t_0[0] squared plus y_0[0] squared plus y_0[1] squared is less than or equal to zero. All variables x[0], x[1], x[2], y_0[0], y_0[1], and t_0[0] are free to take any real value. The problem is a Second-Order Cone Programming (SOCP) problem due to the presence of the quadratic constraint.","\[
\begin{aligned}
\min\;& 0.408544260832344\,x_0 \;-\;1.177163209326489\,x_1 \;-\;0.3033727028272864\,x_2 \\[4pt]
\text{s.t.}\;& 0.5462940531635887\,x_0 \;-\;1.241668902664911\,x_1 \;-\;0.5998249994903344\,x_2 \;=\;0.3835911096798181 \\[4pt]
& -0.030455142845263\,x_0 \;-\;0.7427336810498593\,x_1 \;+\;0.3957667498639689\,x_2 \;=\;-0.6803383944729795 \\[4pt]
& -0.0677712816971205\,x_0 \;+\;0.170365390174673\,x_1 \;-\;0.00413868631847959\,x_2 \;+\;y_{0,0} \;=\;0.00802717043497164 \\[4pt]
& 0.0215916329150542\,x_0 \;-\;0.0479685166742133\,x_1 \;+\;0.0677847235104595\,x_2 \;+\;y_{0,1} \;=\;-0.1511858316417728 \\[4pt]
& -0.219725429611857\,x_0 \;-\;1.453471058496226\,x_1 \;-\;0.5544082541070903\,x_2 \;+\;t_{0,0} \;=\;1.182764044680309 \\[4pt]
& -t_{0,0}^2 \;+\;y_{0,0}^2 \;+\;y_{0,1}^2 \;\le\;0 \\[4pt]
& x_0,\;x_1,\;x_2,\;y_{0,0},\;y_{0,1},\;t_{0,0}\;\in\;\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Nonlinear_Optimization"")

# Decision variables
x0 = m.addVar(vtype=GRB.CONTINUOUS, name=""x0"")
x1 = m.addVar(vtype=GRB.CONTINUOUS, name=""x1"")
x2 = m.addVar(vtype=GRB.CONTINUOUS, name=""x2"")
y00 = m.addVar(vtype=GRB.CONTINUOUS, name=""y00"")
y01 = m.addVar(vtype=GRB.CONTINUOUS, name=""y01"")
t00 = m.addVar(vtype=GRB.CONTINUOUS, name=""t00"")

# Objective function
m.setObjective(0.408544260832344 * x0 - 1.177163209326489 * x1 - 0.3033727028272864 * x2, GRB.MINIMIZE)

# Linear constraints
m.addConstr(0.5462940531635887 * x0 - 1.241668902664911 * x1 - 0.5998249994903344 * x2 == 0.3835911096798181, name=""eq1"")
m.addConstr(-0.030455142845263 * x0 - 0.7427336810498593 * x1 + 0.3957667498639689 * x2 == -0.6803383944729795, name=""eq2"")
m.addConstr(-0.0677712816971205 * x0 + 0.170365390174673 * x1 - 0.00413868631847959 * x2 + y00 == 0.00802717043497164, name=""eq3"")
m.addConstr(0.0215916329150542 * x0 - 0.0479685166742133 * x1 + 0.0677847235104595 * x2 + y01 == -0.1511858316417728, name=""eq4"")
m.addConstr(-0.219725429611857 * x0 - 1.453471058496226 * x1 - 0.5544082541070903 * x2 + t00 == 1.182764044680309, name=""eq5"")

# Quadratic constraint: -t00^2 + y00^2 + y01^2 <= 0
m.addQConstr(y00 * y00 + y01 * y01 - t00 * t00 <= 0, name=""quad"")

# Optimize
m.optimize()
",,0.02669095,0,,,,,,,,
"The problem involves minimizing a linear objective function defined as 0.7117963359087778 times the value of variable x[0], plus 1.495363634959802 times the value of variable x[1], plus 0.0634582749300659 times the value of variable x[2]. The variables x[0], x[1], and x[2] are free to take any real value. The optimization is subject to two linear equality constraints. The first constraint requires that -0.0258717563775294 times x[0], plus 0.4400877796975226 times x[1], plus 1.085219312984192 times x[2], equals -0.399404323103251. The second constraint requires that -1.063740820798877 times x[0], plus 0.0262817424591634 times x[1], plus 0.3002430009821057 times x[2], equals -0.4003348752264555.

Additionally, the problem includes two second-order cone constraints. The first cone constraint involves variables y_0[0], y_0[1], y_0[2], and t_0[0], and requires that the square root of the sum of the squares of y_0[0], y_0[1], and y_0[2] is less than or equal to t_0[0]. This constraint is associated with the following linear relationships: 0.0709198094546279 times x[0], minus 0.0210367192622051 times x[1], plus 0.0895063725378235 times x[2], plus y_0[0], equals -0.1178974392901265; 0.0489330070748356 times x[0], minus 0.0910855567896424 times x[1], minus 0.0299901411888931 times x[2], plus y_0[1], equals 0.1528438418108943; -0.0102367576685978 times x[0], minus 0.0809953969784582 times x[1], minus 0.0326792481068488 times x[2], plus y_0[2], equals 0.1304009358682119; and -0.7205007161713685 times x[0], plus 0.8402710079185606 times x[1], plus 1.174037649876418 times x[2], plus t_0[0], equals 1.142365596215822.

The second cone constraint involves variables y_1[0], y_1[1], y_1[2], and t_1[0], and requires that the square root of the sum of the squares of y_1[0], y_1[1], and y_1[2] is less than or equal to t_1[0]. This constraint is associated with the following linear relationships: -0.1053047361476771 times x[0], minus 0.1098916681441547 times x[1], plus 0.0725443868339502 times x[2], plus y_1[0], equals -0.0464104086014158; -0.1846597649031371 times x[0], minus 0.0474185137216481 times x[1], minus 0.0085470813934405 times x[2], plus y_1[1], equals -0.0958578667235037; -0.1177843202999298 times x[0], minus 0.0387875095823661 times x[1], minus 0.0741126306954255 times x[2], plus y_1[2], equals -0.013119694402389; and 1.090558517373246 times x[0], minus 0.0977574216352732 times x[1], plus 0.0671448858489764 times x[2], plus t_1[0], equals 0.6764507139985713.

All variables, including x[0], x[1], x[2], y_0[0], y_0[1], y_0[2], y_1[0], y_1[1], y_1[2], t_0[0], and t_1[0], are free to take any real value. The goal is to determine the values of these variables that minimize the objective function while satisfying all the specified constraints.","\[
\begin{aligned}
\min\;& 0.7117963359087778\,x_0 + 1.495363634959802\,x_1 + 0.0634582749300659\,x_2 \\[4pt]
\text{s.t.}\;& -0.0258717563775294\,x_0 + 0.4400877796975226\,x_1 + 1.085219312984192\,x_2 = -0.399404323103251 \\[4pt]
& -1.063740820798877\,x_0 + 0.0262817424591634\,x_1 + 0.3002430009821057\,x_2 = -0.4003348752264555 \\[4pt]
& \|[\,y_{0,0},\,y_{0,1},\,y_{0,2}\,]\|_2 \le t_{0,0} \\[4pt]
& 0.0709198094546279\,x_0 - 0.0210367192622051\,x_1 + 0.0895063725378235\,x_2 + y_{0,0} = -0.1178974392901265 \\[4pt]
& 0.0489330070748356\,x_0 - 0.0910855567896424\,x_1 - 0.0299901411888931\,x_2 + y_{0,1} = 0.1528438418108943 \\[4pt]
& -0.0102367576685978\,x_0 - 0.0809953969784582\,x_1 - 0.0326792481068488\,x_2 + y_{0,2} = 0.1304009358682119 \\[4pt]
& -0.7205007161713685\,x_0 + 0.8402710079185606\,x_1 + 1.174037649876418\,x_2 + t_{0,0} = 1.142365596215822 \\[4pt]
& \|[\,y_{1,0},\,y_{1,1},\,y_{1,2}\,]\|_2 \le t_{1,0} \\[4pt]
& -0.1053047361476771\,x_0 - 0.1098916681441547\,x_1 + 0.0725443868339502\,x_2 + y_{1,0} = -0.0464104086014158 \\[4pt]
& -0.1846597649031371\,x_0 - 0.0474185137216481\,x_1 - 0.0085470813934405\,x_2 + y_{1,1} = -0.0958578667235037 \\[4pt]
& -0.1177843202999298\,x_0 - 0.0387875095823661\,x_1 - 0.0741126306954255\,x_2 + y_{1,2} = -0.013119694402389 \\[4pt]
& 1.090558517373246\,x_0 - 0.0977574216352732\,x_1 + 0.0671448858489764\,x_2 + t_{1,0} = 0.6764507139985713 \\[4pt]
& x_0,\,x_1,\,x_2,\,y_{0,0},\,y_{0,1},\,y_{0,2},\,t_{0,0},\,y_{1,0},\,y_{1,1},\,y_{1,2},\,t_{1,0}\;\in\;\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create the model
m = gp.Model(""Optimization_Model"")

# Decision variables
x0 = m.addVar(vtype=GRB.CONTINUOUS, name=""x0"")
x1 = m.addVar(vtype=GRB.CONTINUOUS, name=""x1"")
x2 = m.addVar(vtype=GRB.CONTINUOUS, name=""x2"")
y00 = m.addVar(vtype=GRB.CONTINUOUS, name=""y00"")
y01 = m.addVar(vtype=GRB.CONTINUOUS, name=""y01"")
y02 = m.addVar(vtype=GRB.CONTINUOUS, name=""y02"")
t00 = m.addVar(vtype=GRB.CONTINUOUS, name=""t00"")
y10 = m.addVar(vtype=GRB.CONTINUOUS, name=""y10"")
y11 = m.addVar(vtype=GRB.CONTINUOUS, name=""y11"")
y12 = m.addVar(vtype=GRB.CONTINUOUS, name=""y12"")
t10 = m.addVar(vtype=GRB.CONTINUOUS, name=""t10"")

# Objective function
m.setObjective(0.7117963359087778*x0 + 1.495363634959802*x1 + 0.0634582749300659*x2, GRB.MINIMIZE)

# Linear equality constraints
m.addConstr(-0.0258717563775294*x0 + 0.4400877796975226*x1 + 1.085219312984192*x2 == -0.399404323103251, name=""eq1"")
m.addConstr(-1.063740820798877*x0 + 0.0262817424591634*x1 + 0.3002430009821057*x2 == -0.4003348752264555, name=""eq2"")
m.addConstr(0.0709198094546279*x0 - 0.0210367192622051*x1 + 0.0895063725378235*x2 + y00 == -0.1178974392901265, name=""eq_y00"")
m.addConstr(0.0489330070748356*x0 - 0.0910855567896424*x1 - 0.0299901411888931*x2 + y01 == 0.1528438418108943, name=""eq_y01"")
m.addConstr(-0.0102367576685978*x0 - 0.0809953969784582*x1 - 0.0326792481068488*x2 + y02 == 0.1304009358682119, name=""eq_y02"")
m.addConstr(-0.7205007161713685*x0 + 0.8402710079185606*x1 + 1.174037649876418*x2 + t00 == 1.142365596215822, name=""eq_t00"")
m.addConstr(-0.1053047361476771*x0 - 0.1098916681441547*x1 + 0.0725443868339502*x2 + y10 == -0.0464104086014158, name=""eq_y10"")
m.addConstr(-0.1846597649031371*x0 - 0.0474185137216481*x1 - 0.0085470813934405*x2 + y11 == -0.0958578667235037, name=""eq_y11"")
m.addConstr(-0.1177843202999298*x0 - 0.0387875095823661*x1 - 0.0741126306954255*x2 + y12 == -0.013119694402389, name=""eq_y12"")
m.addConstr(1.090558517373246*x0 - 0.0977574216352732*x1 + 0.0671448858489764*x2 + t10 == 0.6764507139985713, name=""eq_t10"")

# Second-order cone constraints (norm <= t)
m.addQConstr(y00*y00 + y01*y01 + y02*y02 <= t00*t00, name=""soc0"")
m.addQConstr(y10*y10 + y11*y11 + y12*y12 <= t10*t10, name=""soc1"")

# Optimize the model
m.optimize()",,-1.3735385,0,,,,,,,,
"Minimize the linear objective function involving five variables with coefficients: -1.27457045729125 for x[0], 0.3829428410019269 for x[1], 0.8634766321930054 for x[2], -0.8495951803940098 for x[3], and 0.7818351274236842 for x[4]. 

The solution must satisfy five linear equality constraints: 
1. A weighted combination of x[0] (0.3779915609931544), x[1] (-0.2098956852913138), x[2] (-0.2045186307690221), x[3] (1.70241687084974), and x[4] (-0.0830495385416335) must equal -0.8872046273965938. 
2. A weighted combination of x[0] (-0.1980432307652125), x[1] (0.5734762682253645), x[2] (0.8168321608033806), x[3] (0.4534299593541723), and x[4] (-1.551957669500629) must equal -1.682642259460053. 
3. A weighted combination of x[0] (2.09940339313846), x[1] (-0.5382869592818297), x[2] (-0.4711126728138521), x[3] (2.41705884114686), and x[4] (0.3807643962655075) must equal -1.178472853778845. 
4. A weighted combination of x[0] (-0.0319043926204142), x[1] (1.274635913461541), x[2] (0.2494503935760785), x[3] (-1.178243710464141), and x[4] (-0.658162908023939) must equal 1.097123236331887. 
5. A weighted combination of x[0] (-2.38990451126146), x[1] (-0.4143841871813654), x[2] (-0.1278674033858785), x[3] (-0.0913945158661918), and x[4] (-0.6463312417465074) must equal 0.1278954511759081. 

Additionally, four auxiliary variables y_0[0], y_0[1], y_0[2], and t_0[0] are introduced as part of a second-order cone constraint. The solution must satisfy four linear equality constraints involving these variables: 
1. A weighted combination of x[0] (0.0811031804701355), x[1] (0.0614084577317061), x[2] (-0.0221560152059943), x[3] (0.2071308897950201), and x[4] (0.1014268263641295), plus y_0[0], must equal 0.0612422178599395. 
2. A weighted combination of x[0] (-0.0913274075374076), x[1] (0.0084232463574275), x[2] (0.0231115788245813), x[3] (-0.0528298653734004), and x[4] (-0.1547249726938889), plus y_0[1], must equal 0.0531856861000841. 
3. A weighted combination of x[0] (0.0682088948475448), x[1] (-0.1651917752267487), x[2] (-0.0413346954944568), x[3] (-0.0532349804461065), and x[4] (0.0783732630578606), plus y_0[2], must equal -0.0703701003068877. 
4. A weighted combination of x[0] (0.7179187345461103), x[1] (-0.5038326161213537), x[2] (0.9210968531714094), x[3] (-0.4759925591110667), and x[4] (-1.776260360500366), plus t_0[0], must equal 0.6058017967567707. 

The solution must also satisfy a second-order cone constraint: the square of t_0[0] must be less than or equal to the sum of the squares of y_0[0], y_0[1], and y_0[2], expressed as \(-t_0[0]^2 + y_0[0]^2 + y_0[1]^2 + y_0[2]^2 \leq 0\). 

All variables, including x[0] to x[4], y_0[0], y_0[1], y_0[2], and t_0[0], are free to take any real value. The goal is to determine the values of these variables that minimize the objective function while satisfying all the equality and cone constraints.","\[
\begin{aligned}
\min\;&-1.27457045729125\,x_0+0.3829428410019269\,x_1+0.8634766321930054\,x_2-0.8495951803940098\,x_3+0.7818351274236842\,x_4\\[4pt]
\text{s.t. }&0.3779915609931544\,x_0-0.2098956852913138\,x_1-0.2045186307690221\,x_2+1.70241687084974\,x_3-0.0830495385416335\,x_4=-0.8872046273965938\\
&-0.1980432307652125\,x_0+0.5734762682253645\,x_1+0.8168321608033806\,x_2+0.4534299593541723\,x_3-1.551957669500629\,x_4=-1.682642259460053\\
&2.09940339313846\,x_0-0.5382869592818297\,x_1-0.4711126728138521\,x_2+2.41705884114686\,x_3+0.3807643962655075\,x_4=-1.178472853778845\\
&-0.0319043926204142\,x_0+1.274635913461541\,x_1+0.2494503935760785\,x_2-1.178243710464141\,x_3-0.658162908023939\,x_4=1.097123236331887\\
&-2.38990451126146\,x_0-0.4143841871813654\,x_1-0.1278674033858785\,x_2-0.0913945158661918\,x_3-0.6463312417465074\,x_4=0.1278954511759081\\[4pt]
&0.0811031804701355\,x_0+0.0614084577317061\,x_1-0.0221560152059943\,x_2+0.2071308897950201\,x_3+0.1014268263641295\,x_4+y_0=-0.0612422178599395\\
&-0.0913274075374076\,x_0+0.0084232463574275\,x_1+0.0231115788245813\,x_2-0.0528298653734004\,x_3-0.1547249726938889\,x_4+y_1=-0.0531856861000841\\
&0.0682088948475448\,x_0-0.1651917752267487\,x_1-0.0413346954944568\,x_2-0.0532349804461065\,x_3+0.0783732630578606\,x_4+y_2=0.0703701003068877\\
&0.7179187345461103\,x_0-0.5038326161213537\,x_1+0.9210968531714094\,x_2-0.4759925591110667\,x_3-1.776260360500366\,x_4+t_0=0.6058017967567707\\[4pt]
&t_0^2\;\le\;y_0^2+y_1^2+y_2^2\\[4pt]
&x_0,x_1,x_2,x_3,x_4,y_0,y_1,y_2,t_0\in\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

m = gp.Model(""OptimizationModel"")

# Decision variables
x = m.addVars(5, vtype=GRB.CONTINUOUS, name=""x"")
y = m.addVars(3, vtype=GRB.CONTINUOUS, name=""y"")
t0 = m.addVar(vtype=GRB.CONTINUOUS, name=""t0"")

# Objective function
m.setObjective(-1.27457045729125*x[0] + 0.3829428410019269*x[1] + 0.8634766321930054*x[2] - 0.8495951803940098*x[3] + 0.7818351274236842*x[4], GRB.MINIMIZE)

# Constraints
m.addConstr(0.3779915609931544*x[0] - 0.2098956852913138*x[1] - 0.2045186307690221*x[2] + 1.70241687084974*x[3] - 0.0830495385416335*x[4] == -0.8872046273965938, ""c1"")
m.addConstr(-0.1980432307652125*x[0] + 0.5734762682253645*x[1] + 0.8168321608033806*x[2] + 0.4534299593541723*x[3] - 1.551957669500629*x[4] == -1.682642259460053, ""c2"")
m.addConstr(2.09940339313846*x[0] - 0.5382869592818297*x[1] - 0.4711126728138521*x[2] + 2.41705884114686*x[3] + 0.3807643962655075*x[4] == -1.178472853778845, ""c3"")
m.addConstr(-0.0319043926204142*x[0] + 1.274635913461541*x[1] + 0.2494503935760785*x[2] - 1.178243710464141*x[3] - 0.658162908023939*x[4] == 1.097123236331887, ""c4"")
m.addConstr(-2.38990451126146*x[0] - 0.4143841871813654*x[1] - 0.1278674033858785*x[2] - 0.0913945158661918*x[3] - 0.6463312417465074*x[4] == 0.1278954511759081, ""c5"")
m.addConstr(0.0811031804701355*x[0] + 0.0614084577317061*x[1] - 0.0221560152059943*x[2] + 0.2071308897950201*x[3] + 0.1014268263641295*x[4] + y[0] == -0.0612422178599395, ""c6"")
m.addConstr(-0.0913274075374076*x[0] + 0.0084232463574275*x[1] + 0.0231115788245813*x[2] - 0.0528298653734004*x[3] - 0.1547249726938889*x[4] + y[1] == -0.0531856861000841, ""c7"")
m.addConstr(0.0682088948475448*x[0] - 0.1651917752267487*x[1] - 0.0413346954944568*x[2] - 0.0532349804461065*x[3] + 0.0783732630578606*x[4] + y[2] == 0.0703701003068877, ""c8"")
m.addConstr(0.7179187345461103*x[0] - 0.5038326161213537*x[1] + 0.9210968531714094*x[2] - 0.4759925591110667*x[3] - 1.776260360500366*x[4] + t0 == 0.6058017967567707, ""c9"")

# Quadratic constraint
m.addQConstr(t0*t0 <= y[0]*y[0] + y[1]*y[1] + y[2]*y[2], ""c10"")

m.optimize()

if m.status == GRB.OPTIMAL:
    print(""Optimal objective:"", m.objVal)
    for i in range(5):
        print(f""x[{i}] ="", x[i].X)
    for i in range(3):
        print(f""y[{i}] ="", y[i].X)
    print(""t0 ="", t0.X)",,-0.5148358,0,,,,,,,,
"The goal is to minimize the total cost, which is calculated as 0.786272624432491 times x[0] plus 0.8625634188757304 times x[1] minus 1.12398756204435 times x[2]. The decision variables include x[0], x[1], x[2], y_0[0], y_0[1], y_0[2], y_1[0], y_1[1], y_1[2], y_2[0], y_2[1], y_2[2], y_3[0], y_3[1], y_3[2], t_0[0], t_1[0], t_2[0], and t_3[0]. All variables are free to take any real value.

The problem is subject to linear equality constraints. The first constraint requires that 1.265089926033166 times x[0] plus 0.8265511590295959 times x[1] plus 0.6425143729335491 times x[2] equals -1.340261867227508. The second constraint requires that -1.038046026005065 times x[0] minus 0.978681730406505 times x[1] minus 0.3158917890099441 times x[2] equals 0.9895473898354382. The third constraint requires that 0.3708381346357463 times x[0] plus 0.2148963219535531 times x[1] minus 1.83990668416334 times x[2] equals 3.062677436779988. The fourth constraint requires that -1.872418427024533 times x[0] minus 1.159027962632082 times x[1] plus 0.3313042271069708 times x[2] equals -0.2396557035046597.

Additional constraints ensure that specific combinations of the decision variables and auxiliary variables satisfy certain conditions. For the first set of auxiliary variables, 0.0845901604928491 times x[0] plus 0.00653062634511069 times x[1] minus 0.0396187361282293 times x[2] plus y_0[0] equals 0.1028911134186171, -0.1655645187396123 times x[0] minus 0.00481490476108966 times x[1] plus 0.1091868022965404 times x[2] plus y_0[1] equals -0.0791773986380616, and 0.0657601002643706 times x[0] plus 0.0770866340133718 times x[1] plus 0.0717168532804696 times x[2] plus y_0[2] equals 0.1545300907589844. For the second set of auxiliary variables, 0.3298234267560927 times x[0] plus 1.022831383811937 times x[1] minus 0.00493650012051474 times x[2] plus t_0[0] equals 0.9587050025563594, 0.8976617894842607 times x[0] minus 1.960565868013685 times x[1] plus 0.2084251295126738 times x[2] plus y_1[0] equals -0.1849711881061493, -0.7094023471201548 times x[0] plus 0.6353877939866961 times x[1] minus 0.0876866180562744 times x[2] plus y_1[1] equals -0.4919818599100178, and 2.698160782648244 times x[0] minus 0.4574765835824846 times x[1] plus 0.6985665960561629 times x[2] plus y_1[2] equals 0.2614076505075524.

For the third set of auxiliary variables, -0.7226507325429118 times x[0] plus 0.0568702304829931 times x[1] plus 1.471507498629236 times x[2] plus t_1[0] equals 0.320143628846921, 0.0533180689091473 times x[0] minus 0.1728737890908431 times x[1] plus 0.0319070165322495 times x[2] plus y_2[0] equals 0.0152872162677227, -0.0512090278756547 times x[0] minus 0.0557654636443004 times x[1] minus 0.2980053053415462 times x[2] plus y_2[1] equals -0.0964105256925016, and 0.176881384588485 times x[0] plus 0.0368327469045029 times x[1] plus 0.0368571461194376 times x[2] plus y_2[2] equals 0.0672644472047825. For the fourth set of auxiliary variables, 0.7106618613482838 times x[0] minus 0.7138000011448565 times x[1] plus 0.1976996075797842 times x[2] plus t_2[0] equals 1.260005801822901, 0.0443424626310529 times x[0] plus 0.1363607191306093 times x[1] minus 0.0668054006192922 times x[2] plus y_3[0] equals 0.0932454917759326, 0.0536583684212656 times x[0] minus 0.0491976587190737 times x[1] plus 0.06269906389831 times x[2] plus y_3[1] equals -0.00327479473248982, and -0.1482437619827962 times x[0] minus 0.1780634692898283 times x[1] plus 0.1091477105610945 times x[2] plus y_3[2] equals 0.0218802336021696.

The problem also includes Second-Order Cone Constraints. The first Second-Order Cone Constraint ensures that the negative square of t_0[0] plus the squares of y_0[0], y_0[1], and y_0[2] is less than or equal to zero. The second Second-Order Cone Constraint ensures that the negative square of t_1[0] plus the squares of y_1[0], y_1[1], and y_1[2] is less than or equal to zero. The third Second-Order Cone Constraint ensures that the negative square of t_2[0] plus the squares of y_2[0], y_2[1], and y_2[2] is less than or equal to zero. The fourth Second-Order Cone Constraint ensures that the negative square of t_3[0] plus the squares of y_3[0], y_3[1], and y_3[2] is less than or equal to zero. These constraints are critical for ensuring the problem's feasibility and optimality.","\[
\begin{aligned}
\min\quad & 0.786272624432491\,x_0 + 0.8625634188757304\,x_1 - 1.12398756204435\,x_2\\
\text{s.t.}\quad & 1.265089926033166\,x_0 + 0.8265511590295959\,x_1 + 0.6425143729335491\,x_2 = -1.340261867227508\\
& -1.038046026005065\,x_0 - 0.978681730406505\,x_1 - 0.3158917890099441\,x_2 = 0.9895473898354382\\
& 0.3708381346357463\,x_0 + 0.2148963219535531\,x_1 - 1.83990668416334\,x_2 = 3.062677436779988\\
& -1.872418427024533\,x_0 - 1.159027962632082\,x_1 + 0.3313042271069708\,x_2 = -0.2396557035046597\\
& 0.0845901604928491\,x_0 + 0.00653062634511069\,x_1 - 0.0396187361282293\,x_2 + y_{0,0} = 0.1028911134186171\\
& -0.1655645187396123\,x_0 - 0.00481490476108966\,x_1 + 0.1091868022965404\,x_2 + y_{0,1} = -0.0791773986380616\\
& 0.0657601002643706\,x_0 + 0.0770866340133718\,x_1 + 0.0717168532804696\,x_2 + y_{0,2} = 0.1545300907589844\\
& 0.3298234267560927\,x_0 + 1.022831383811937\,x_1 - 0.00493650012051474\,x_2 + t_{0,0} = 0.9587050025563594\\
& 0.8976617894842607\,x_0 - 1.960565868013685\,x_1 + 0.2084251295126738\,x_2 + y_{1,0} = -0.1849711881061493\\
& -0.7094023471201548\,x_0 + 0.6353877939866961\,x_1 - 0.0876866180562744\,x_2 + y_{1,1} = -0.4919818599100178\\
& 2.698160782648244\,x_0 - 0.4574765835824846\,x_1 + 0.6985665960561629\,x_2 + y_{1,2} = 0.2614076505075524\\
& -0.7226507325429118\,x_0 + 0.0568702304829931\,x_1 + 1.471507498629236\,x_2 + t_{1,0} = 0.320143628846921\\
& 0.0533180689091473\,x_0 - 0.1728737890908431\,x_1 + 0.0319070165322495\,x_2 + y_{2,0} = 0.0152872162677227\\
& -0.0512090278756547\,x_0 - 0.0557654636443004\,x_1 - 0.2980053053415462\,x_2 + y_{2,1} = -0.0964105256925016\\
& 0.176881384588485\,x_0 + 0.0368327469045029\,x_1 + 0.0368571461194376\,x_2 + y_{2,2} = 0.0672644472047825\\
& 0.7106618613482838\,x_0 - 0.7138000011448565\,x_1 + 0.1976996075797842\,x_2 + t_{2,0} = 1.260005801822901\\
& 0.0443424626310529\,x_0 + 0.1363607191306093\,x_1 - 0.0668054006192922\,x_2 + y_{3,0} = 0.0932454917759326\\
& 0.0536583684212656\,x_0 - 0.0491976587190737\,x_1 + 0.06269906389831\,x_2 + y_{3,1} = -0.00327479473248982\\
& -0.1482437619827962\,x_0 - 0.1780634692898283\,x_1 + 0.1091477105610945\,x_2 + y_{3,2} = 0.0218802336021696\\
& \| (y_{0,0},\,y_{0,1},\,y_{0,2}) \|_2 \le t_{0,0}\\
& \| (y_{1,0},\,y_{1,1},\,y_{1,2}) \|_2 \le t_{1,0}\\
& \| (y_{2,0},\,y_{2,1},\,y_{2,2}) \|_2 \le t_{2,0}\\
& \| (y_{3,0},\,y_{3,1},\,y_{3,2}) \|_2 \le t_{3,0}\\
\text{with } & x_0,x_1,x_2,y_{0,0},y_{0,1},y_{0,2},y_{1,0},y_{1,1},y_{1,2},y_{2,0},y_{2,1},y_{2,2},y_{3,0},y_{3,1},y_{3,2},t_{0,0},t_{1,0},t_{2,0},t_{3,0}\in\mathbb{R}.
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create the model
m = gp.Model(""OptimizationModel"")

# Decision variables
x0 = m.addVar(vtype=GRB.CONTINUOUS, name=""x0"")
x1 = m.addVar(vtype=GRB.CONTINUOUS, name=""x1"")
x2 = m.addVar(vtype=GRB.CONTINUOUS, name=""x2"")

y = {}
for i in range(4):
    for j in range(3):
        y[(i,j)] = m.addVar(vtype=GRB.CONTINUOUS, name=f""y_{i}_{j}"")

t = {}
for i in range(4):
    t[i] = m.addVar(vtype=GRB.CONTINUOUS, name=f""t_{i}_0"")
    m.addConstr(t[i] >= 0, name=f""t_nonneg_{i}"")

# Objective function
m.setObjective(0.786272624432491*x0 + 0.8625634188757304*x1 - 1.12398756204435*x2, GRB.MINIMIZE)

# Linear constraints for x variables
m.addConstr(1.265089926033166*x0 + 0.8265511590295959*x1 + 0.6425143729335491*x2 == -1.340261867227508, name=""eq_x0"")
m.addConstr(-1.038046026005065*x0 - 0.978681730406505*x1 - 0.3158917890099441*x2 == 0.9895473898354382, name=""eq_x1"")
m.addConstr(0.3708381346357463*x0 + 0.2148963219535531*x1 - 1.83990668416334*x2 == 3.062677436779988, name=""eq_x2"")
m.addConstr(-1.872418427024533*x0 - 1.159027962632082*x1 + 0.3313042271069708*x2 == -0.2396557035046597, name=""eq_x3"")

# Linear constraints for y variables with t
m.addConstr(0.0845901604928491*x0 + 0.00653062634511069*x1 - 0.0396187361282293*x2 + y[(0,0)] == 0.1028911134186171, name=""eq_y00"")
m.addConstr(-0.1655645187396123*x0 - 0.00481490476108966*x1 + 0.1091868022965404*x2 + y[(0,1)] == -0.0791773986380616, name=""eq_y01"")
m.addConstr(0.0657601002643706*x0 + 0.0770866340133718*x1 + 0.0717168532804696*x2 + y[(0,2)] == 0.1545300907589844, name=""eq_y02"")
m.addConstr(0.3298234267560927*x0 + 1.022831383811937*x1 - 0.00493650012051474*x2 + t[0] == 0.9587050025563594, name=""eq_t00"")
m.addConstr(0.8976617894842607*x0 - 1.960565868013685*x1 + 0.2084251295126738*x2 + y[(1,0)] == -0.1849711881061493, name=""eq_y10"")
m.addConstr(-0.7094023471201548*x0 + 0.6353877939866961*x1 - 0.0876866180562744*x2 + y[(1,1)] == -0.4919818599100178, name=""eq_y11"")
m.addConstr(2.698160782648244*x0 - 0.4574765835824846*x1 + 0.6985665960561629*x2 + y[(1,2)] == 0.2614076505075524, name=""eq_y12"")
m.addConstr(-0.7226507325429118*x0 + 0.0568702304829931*x1 + 1.471507498629236*x2 + t[1] == 0.320143628846921, name=""eq_t10"")
m.addConstr(0.0533180689091473*x0 - 0.1728737890908431*x1 + 0.0319070165322495*x2 + y[(2,0)] == 0.0152872162677227, name=""eq_y20"")
m.addConstr(-0.0512090278756547*x0 - 0.0557654636443004*x1 - 0.2980053053415462*x2 + y[(2,1)] == -0.0964105256925016, name=""eq_y21"")
m.addConstr(0.176881384588485*x0 + 0.0368327469045029*x1 + 0.0368571461194376*x2 + y[(2,2)] == 0.0672644472047825, name=""eq_y22"")
m.addConstr(0.7106618613482838*x0 - 0.7138000011448565*x1 + 0.1976996075797842*x2 + t[2] == 1.260005801822901, name=""eq_t20"")
m.addConstr(0.0443424626310529*x0 + 0.1363607191306093*x1 - 0.0668054006192922*x2 + y[(3,0)] == 0.0932454917759326, name=""eq_y30"")
m.addConstr(0.0536583684212656*x0 - 0.0491976587190737*x1 + 0.06269906389831*x2 + y[(3,1)] == -0.00327479473248982, name=""eq_y31"")
m.addConstr(-0.1482437619827962*x0 - 0.1780634692898283*x1 + 0.1091477105610945*x2 + y[(3,2)] == 0.0218802336021696, name=""eq_y32"")

# Second-order cone constraints (norm <= t)
for i in range(4):
    m.addQConstr(gp.quicksum(y[(i,j)]*y[(i,j)] for j in range(3)) <= t[i]*t[i], name=f""soc_{i}"")

# Solve the model
m.optimize()
",,1.45802959,0,,,,,,,,
"Minimize the total cost of allocating six resources, where the cost coefficients for each resource are -0.2230299351960377, 0.2260048024316069, -0.1766835611048999, 0.5573216224422132, -1.208376221550068, and 0.5847966392616851 units per unit allocated, respectively. The allocation must satisfy sixteen linear equality constraints and three second-order cone constraints. The first five linear equality constraints are as follows: the first constraint requires that 0.0864123382415046 times the first resource minus 0.2999520944563616 times the second resource minus 0.4373153026838008 times the third resource plus 0.2236844833244651 times the fourth resource minus 0.1726687049023944 times the fifth resource plus 1.131231237141819 times the sixth resource equals -0.2555719673916053. The second constraint requires that 0.6475024542623146 times the first resource minus 0.2411773085202067 times the second resource minus 1.152365276965448 times the third resource plus 0.0681294271686064 times the fourth resource minus 0.460006367650037 times the fifth resource minus 0.8626734903353966 times the sixth resource equals -1.611099466848817. The third constraint requires that -0.1892421564042141 times the first resource plus 0.4442286186625635 times the second resource plus 0.0351084932857791 times the third resource minus 1.65945657674057 times the fourth resource plus 1.813083837788898 times the fifth resource minus 0.1731007007836295 times the sixth resource equals -2.302900632383548. The fourth constraint requires that 0.6105836251433618 times the first resource plus 1.224758698265837 times the second resource minus 0.6569021430924753 times the third resource minus 1.723125872166611 times the fourth resource plus 0.6658852466385591 times the fifth resource plus 0.8417973521416725 times the sixth resource equals -3.826954722671106. The fifth constraint requires that -0.1167867054929794 times the first resource plus 0.1666505226611245 times the second resource minus 0.0580663537752885 times the third resource minus 0.1929108225442672 times the fourth resource minus 1.118313643238442 times the fifth resource plus 1.582899027912414 times the sixth resource equals 0.5701541914439772.

The remaining eleven linear equality constraints involve auxiliary variables introduced for the second-order cone constraints. The sixth constraint requires that -0.0231503875559003 times the first resource plus 0.00454721771555977 times the second resource minus 0.0401563754472746 times the third resource plus 0.0319081283767895 times the fourth resource minus 0.0445254387459282 times the fifth resource plus 0.0666388070919248 times the sixth resource plus y_0[0] equals 0.1220045375876136. The seventh constraint requires that -0.0850790157464754 times the first resource minus 0.0476072870612039 times the second resource minus 0.068828152035275 times the third resource minus 0.0919526883283748 times the fourth resource minus 0.0484614346821255 times the fifth resource minus 0.157778975935517 times the sixth resource plus y_0[1] equals 0.00586701808623117. The eighth constraint requires that 0.0578622514811724 times the first resource minus 0.1018459374054135 times the second resource plus 0.028959008397348 times the third resource plus 0.0124914167995535 times the fourth resource minus 0.1217493644708651 times the fifth resource minus 0.0455371326070688 times the sixth resource plus y_0[2] equals 0.00103506581258387. The ninth constraint requires that 0.5438484424289765 times the first resource minus 0.4058548451270487 times the second resource plus 0.00464438168201298 times the third resource plus 0.6829984219379786 times the fourth resource minus 0.813089431925804 times the fifth resource plus 0.1465879382567549 times the sixth resource plus t_0[0] equals 0.8921404899384406.

The tenth constraint requires that -0.1565490941785506 times the first resource minus 0.0151974010871207 times the second resource plus 0.0330083659733866 times the third resource plus 0.0409835559769911 times the fourth resource minus 0.025926735354538 times the fifth resource minus 0.0791575923837095 times the sixth resource plus y_1[0] equals 0.0252004385932512. The eleventh constraint requires that -0.00679732652950372 times the first resource minus 0.0159930899677971 times the second resource plus 0.00044788212331377231 times the third resource minus 0.00870755949376334 times the fourth resource plus 0.0106774891090615 times the fifth resource minus 0.0819505944729122 times the sixth resource plus y_1[1] equals -0.2461745595888191. The twelfth constraint requires that -0.0767410168100431 times the first resource minus 0.1162981298613443 times the second resource plus 0.2516807060221921 times the third resource minus 0.00442617885794681 times the fourth resource minus 0.0897268862621352 times the fifth resource minus 0.1001649216336424 times the sixth resource plus y_1[2] equals 0.0676538189988438. The thirteenth constraint requires that 2.12708121691458 times the first resource plus 0.5354675680200557 times the second resource plus 0.1244147628194144 times the third resource plus 1.32540724304661 times the fourth resource minus 0.6888780286074161 times the fifth resource plus 1.1055685780941 times the sixth resource plus t_1[0] equals 0.8216483573755342.

The fourteenth constraint requires that 0.1045779404782078 times the first resource plus 0.117211531954123 times the second resource minus 0.093303260093519 times the third resource plus 0.114920382796502 times the fourth resource plus 0.0892956784939136 times the fifth resource minus 0.1270063126632456 times the sixth resource plus y_2[0] equals 0.1487112654209727. The fifteenth constraint requires that 0.1031929746661822 times the first resource plus 0.0366834994452099 times the second resource minus 0.0811775022010661 times the third resource minus 0.0941975746436261 times the fourth resource plus 0.034402649559877 times the fifth resource minus 0.2382614709448476 times the sixth resource plus y_2[1] equals -0.00259845523628418. The sixteenth constraint requires that -0.0649606742324766 times the first resource plus 0.1500400272048616 times the second resource plus 0.0157455125935616 times the third resource minus 0.0173529909921789 times the fourth resource minus 0.045730709242314 times the fifth resource minus 0.068092234748515 times the sixth resource plus y_2[2] equals -0.1982729375753503.

The three second-order cone constraints are as follows: the first cone constraint requires that the sum of the squares of y_0[0], y_0[1], and y_0[2] is at most the square of t_0[0]. The second cone constraint requires that the sum of the squares of y_1[0], y_1[1], and y_1[2] is at most the square of t_1[0]. The third cone constraint requires that the sum of the squares of y_2[0], y_2[1], and y_2[2] is at most the square of t_2[0]. All decision variables, including the resource allocations x[0], x[1], x[2], x[3], x[4], and x[5], and the auxiliary variables y_0[0], y_0[1], y_0[2], y_1[0], y_1[1], y_1[2], y_2[0], y_2[1], y_2[2], t_0[0], t_1[0], and t_2[0], are free to take any real value. The goal is to determine the optimal allocation of the six resources that minimizes the total cost while satisfying all linear equality and second-order cone constraints.","\[
\begin{aligned}
\min\quad & -0.2230299351960377\,x_{1}+0.2260048024316069\,x_{2}-0.1766835611048999\,x_{3}+0.5573216224422132\,x_{4}-1.208376221550068\,x_{5}+0.5847966392616851\,x_{6}\\
\text{s.t.}\quad & 0.0864123382415046\,x_{1}-0.2999520944563616\,x_{2}-0.4373153026838008\,x_{3}+0.2236844833244651\,x_{4}-0.1726687049023944\,x_{5}+1.131231237141819\,x_{6}=-0.2555719673916053\\
& 0.6475024542623146\,x_{1}-0.2411773085202067\,x_{2}-1.152365276965448\,x_{3}+0.0681294271686064\,x_{4}-0.460006367650037\,x_{5}-0.8626734903353966\,x_{6}=-1.611099466848817\\
& -0.1892421564042141\,x_{1}+0.4442286186625635\,x_{2}+0.0351084932857791\,x_{3}-1.65945657674057\,x_{4}+1.813083837788898\,x_{5}-0.1731007007836295\,x_{6}=-2.302900632383548\\
& 0.6105836251433618\,x_{1}+1.224758698265837\,x_{2}-0.6569021430924753\,x_{3}-1.723125872166611\,x_{4}+0.6658852466385591\,x_{5}+0.8417973521416725\,x_{6}=-3.826954722671106\\
& -0.1167867054929794\,x_{1}+0.1666505226611245\,x_{2}-0.0580663537752885\,x_{3}-0.1929108225442672\,x_{4}-1.118313643238442\,x_{5}+1.582899027912414\,x_{6}=0.5701541914439772\\
& -0.0231503875559003\,x_{1}+0.00454721771555977\,x_{2}-0.0401563754472746\,x_{3}+0.0319081283767895\,x_{4}-0.0445254387459282\,x_{5}+0.0666388070919248\,x_{6}+y_{0,1}=0.1220045375876136\\
& -0.0850790157464754\,x_{1}-0.0476072870612039\,x_{2}-0.068828152035275\,x_{3}-0.0919526883283748\,x_{4}-0.0484614346821255\,x_{5}-0.157778975935517\,x_{6}+y_{0,2}=0.00586701808623117\\
& 0.0578622514811724\,x_{1}-0.1018459374054135\,x_{2}+0.028959008397348\,x_{3}+0.0124914167995535\,x_{4}-0.1217493644708651\,x_{5}-0.0455371326070688\,x_{6}+y_{0,3}=0.00103506581258387\\
& 0.5438484424289765\,x_{1}-0.4058548451270487\,x_{2}+0.00464438168201298\,x_{3}+0.6829984219379786\,x_{4}-0.813089431925804\,x_{5}+0.1465879382567549\,x_{6}+t_{0,1}=0.8921404899384406\\
& -0.1565490941785506\,x_{1}-0.0151974010871207\,x_{2}+0.0330083659733866\,x_{3}+0.0409835559769911\,x_{4}-0.025926735354538\,x_{5}-0.0791575923837095\,x_{6}+y_{1,1}=0.0252004385932512\\
& -0.00679732652950372\,x_{1}-0.0159930899677971\,x_{2}+0.00044788212331377231\,x_{3}-0.00870755949376334\,x_{4}+0.0106774891090615\,x_{5}-0.0819505944729122\,x_{6}+y_{1,2}=-0.2461745595888191\\
& -0.0767410168100431\,x_{1}-0.1162981298613443\,x_{2}+0.2516807060221921\,x_{3}-0.00442617885794681\,x_{4}-0.0897268862621352\,x_{5}-0.1001649216336424\,x_{6}+y_{1,3}=0.0676538189988438\\
& 2.12708121691458\,x_{1}+0.5354675680200557\,x_{2}+0.1244147628194144\,x_{3}+1.32540724304661\,x_{4}-0.6888780286074161\,x_{5}+1.1055685780941\,x_{6}+t_{1,1}=0.8216483573755342\\
& 0.1045779404782078\,x_{1}+0.117211531954123\,x_{2}-0.093303260093519\,x_{3}+0.114920382796502\,x_{4}+0.0892956784939136\,x_{5}-0.1270063126632456\,x_{6}+y_{2,1}=0.1487112654209727\\
& 0.1031929746661822\,x_{1}+0.0366834994452099\,x_{2}-0.0811775022010661\,x_{3}-0.0941975746436261\,x_{4}+0.034402649559877\,x_{5}-0.2382614709448476\,x_{6}+y_{2,2}=-0.00259845523628418\\
& -0.0649606742324766\,x_{1}+0.1500400272048616\,x_{2}+0.0157455125935616\,x_{3}-0.0173529909921789\,x_{4}-0.045730709242314\,x_{5}-0.068092234748515\,x_{6}+y_{2,3}=-0.1982729375753503\\
& y_{0,1}^{2}+y_{0,2}^{2}+y_{0,3}^{2}\le t_{0,1}^{2}\\
& y_{1,1}^{2}+y_{1,2}^{2}+y_{1,3}^{2}\le t_{1,1}^{2}\\
& y_{2,1}^{2}+y_{2,2}^{2}+y_{2,3}^{2}\le t_{2,1}^{2}\\
& x_{1},x_{2},x_{3},x_{4},x_{5},x_{6},y_{0,1},y_{0,2},y_{0,3},y_{1,1},y_{1,2},y_{1,3},y_{2,1},y_{2,2},y_{2,3},t_{0,1},t_{1,1},t_{2,1}\in\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Optimization_Model"")

# Decision variables
x1 = m.addVar(vtype=GRB.CONTINUOUS, name=""x1"")
x2 = m.addVar(vtype=GRB.CONTINUOUS, name=""x2"")
x3 = m.addVar(vtype=GRB.CONTINUOUS, name=""x3"")
x4 = m.addVar(vtype=GRB.CONTINUOUS, name=""x4"")
x5 = m.addVar(vtype=GRB.CONTINUOUS, name=""x5"")
x6 = m.addVar(vtype=GRB.CONTINUOUS, name=""x6"")

y0_1 = m.addVar(vtype=GRB.CONTINUOUS, name=""y0_1"")
y0_2 = m.addVar(vtype=GRB.CONTINUOUS, name=""y0_2"")
y0_3 = m.addVar(vtype=GRB.CONTINUOUS, name=""y0_3"")
y1_1 = m.addVar(vtype=GRB.CONTINUOUS, name=""y1_1"")
y1_2 = m.addVar(vtype=GRB.CONTINUOUS, name=""y1_2"")
y1_3 = m.addVar(vtype=GRB.CONTINUOUS, name=""y1_3"")
y2_1 = m.addVar(vtype=GRB.CONTINUOUS, name=""y2_1"")
y2_2 = m.addVar(vtype=GRB.CONTINUOUS, name=""y2_2"")
y2_3 = m.addVar(vtype=GRB.CONTINUOUS, name=""y2_3"")

t0_1 = m.addVar(vtype=GRB.CONTINUOUS, name=""t0_1"")
t1_1 = m.addVar(vtype=GRB.CONTINUOUS, name=""t1_1"")
t2_1 = m.addVar(vtype=GRB.CONTINUOUS, name=""t2_1"")

# Objective function
m.setObjective(
    -0.2230299351960377 * x1
    + 0.2260048024316069 * x2
    - 0.1766835611048999 * x3
    + 0.5573216224422132 * x4
    - 1.208376221550068 * x5
    + 0.5847966392616851 * x6,
    GRB.MINIMIZE
)

# Linear equality constraints
m.addConstr(0.0864123382415046 * x1 - 0.2999520944563616 * x2 - 0.4373153026838008 * x3
            + 0.2236844833244651 * x4 - 0.1726687049023944 * x5 + 1.131231237141819 * x6
            == -0.2555719673916053, name=""c1"")

m.addConstr(0.6475024542623146 * x1 - 0.2411773085202067 * x2 - 1.152365276965448 * x3
            + 0.0681294271686064 * x4 - 0.460006367650037 * x5 - 0.8626734903353966 * x6
            == -1.611099466848817, name=""c2"")

m.addConstr(-0.1892421564042141 * x1 + 0.4442286186625635 * x2 + 0.0351084932857791 * x3
            - 1.65945657674057 * x4 + 1.813083837788898 * x5 - 0.1731007007836295 * x6
            == -2.302900632383548, name=""c3"")

m.addConstr(0.6105836251433618 * x1 + 1.224758698265837 * x2 - 0.6569021430924753 * x3
            - 1.723125872166611 * x4 + 0.6658852466385591 * x5 + 0.8417973521416725 * x6
            == -3.826954722671106, name=""c4"")

m.addConstr(-0.1167867054929794 * x1 + 0.1666505226611245 * x2 - 0.0580663537752885 * x3
            - 0.1929108225442672 * x4 - 1.118313643238442 * x5 + 1.582899027912414 * x6
            == 0.5701541914439772, name=""c5"")

m.addConstr(-0.0231503875559003 * x1 + 0.00454721771555977 * x2 - 0.0401563754472746 * x3
            + 0.0319081283767895 * x4 - 0.0445254387459282 * x5 + 0.0666388070919248 * x6
            + y0_1 == 0.1220045375876136, name=""c6"")

m.addConstr(-0.0850790157464754 * x1 - 0.0476072870612039 * x2 - 0.068828152035275 * x3
            - 0.0919526883283748 * x4 - 0.0484614346821255 * x5 - 0.157778975935517 * x6
            + y0_2 == 0.00586701808623117, name=""c7"")

m.addConstr(0.0578622514811724 * x1 - 0.1018459374054135 * x2 + 0.028959008397348 * x3
            + 0.0124914167995535 * x4 - 0.1217493644708651 * x5 - 0.0455371326070688 * x6
            + y0_3 == 0.00103506581258387, name=""c8"")

m.addConstr(0.5438484424289765 * x1 - 0.4058548451270487 * x2 + 0.00464438168201298 * x3
            + 0.6829984219379786 * x4 - 0.813089431925804 * x5 + 0.1465879382567549 * x6
            + t0_1 == 0.8921404899384406, name=""c9"")

m.addConstr(-0.1565490941785506 * x1 - 0.0151974010871207 * x2 + 0.0330083659733866 * x3
            + 0.0409835559769911 * x4 - 0.025926735354538 * x5 - 0.0791575923837095 * x6
            + y1_1 == 0.0252004385932512, name=""c10"")

m.addConstr(-0.00679732652950372 * x1 - 0.0159930899677971 * x2 + 0.00044788212331377231 * x3
            - 0.00870755949376334 * x4 + 0.0106774891090615 * x5 - 0.0819505944729122 * x6
            + y1_2 == -0.2461745595888191, name=""c11"")

m.addConstr(-0.0767410168100431 * x1 - 0.1162981298613443 * x2 + 0.2516807060221921 * x3
            - 0.00442617885794681 * x4 - 0.0897268862621352 * x5 - 0.1001649216336424 * x6
            + y1_3 == 0.0676538189988438, name=""c12"")

m.addConstr(2.12708121691458 * x1 + 0.5354675680200557 * x2 + 0.1244147628194144 * x3
            + 1.32540724304661 * x4 - 0.6888780286074161 * x5 + 1.1055685780941 * x6
            + t1_1 == 0.8216483573755342, name=""c13"")

m.addConstr(0.1045779404782078 * x1 + 0.117211531954123 * x2 - 0.093303260093519 * x3
            + 0.114920382796502 * x4 + 0.0892956784939136 * x5 - 0.1270063126632456 * x6
            + y2_1 == 0.1487112654209727, name=""c14"")

m.addConstr(0.1031929746661822 * x1 + 0.0366834994452099 * x2 - 0.0811775022010661 * x3
            - 0.0941975746436261 * x4 + 0.034402649559877 * x5 - 0.2382614709448476 * x6
            + y2_2 == -0.00259845523628418, name=""c15"")

m.addConstr(-0.0649606742324766 * x1 + 0.1500400272048616 * x2 + 0.0157455125935616 * x3
            - 0.0173529909921789 * x4 - 0.045730709242314 * x5 - 0.068092234748515 * x6
            + y2_3 == -0.1982729375753503, name=""c16"")

# Quadratic constraints
m.addQConstr(y0_1 * y0_1 + y0_2 * y0_2 + y0_3 * y0_3 <= t0_1 * t0_1, name=""qc1"")
m.addQConstr(y1_1 * y1_1 + y1_2 * y1_2 + y1_3 * y1_3 <= t1_1 * t1_1, name=""qc2"")
m.addQConstr(y2_1 * y2_1 + y2_2 * y2_2 + y2_3 * y2_3 <= t2_1 * t2_1, name=""qc3"")

# Optimize
m.optimize()
```",,0.992948765,0,,,,,,,,
"The optimization problem involves minimizing a linear objective function with coefficients 1.878721051112547 for variable x[0], -1.28487812168959 for x[1], and 0.4011175494566619 for x[2]. The problem is subject to five linear equality constraints: the first requires -0.1975342265737635 times x[0], -0.2719873754935637 times x[1], and -1.783486559633287 times x[2] to sum to 0.7278205554841768; the second requires -1.768263279220658 times x[0], 0.0736070884409486 times x[1], and -0.0509245482723127 times x[2] to sum to -2.868156724043526; the third requires 0.7748053077719607 times x[0], 3.021004813587345 times x[1], and 0.1666219482636987 times x[2] to sum to 2.766284453816483; the fourth requires 0.5458915584128072 times x[0], -1.22059114128179 times x[1], and 1.494593953041657 times x[2] to sum to -0.7394828371831723; and the fifth requires 2.433843249484103 times x[0], 0.841951398178463 times x[1], and 0.282600820817885 times x[2] to sum to 4.301152000602892. Additionally, there are twelve auxiliary constraints involving variables y_0[0], y_0[1], y_1[0], y_1[1], y_2[0], y_2[1], y_3[0], y_3[1], t_0[0], t_1[0], t_2[0], and t_3[0], which are all free to vary. These constraints include: 0.091171079971759 times x[0], 0.0086023 times x[1], 0.0626180219067843 times x[2], and y_0[0] summing to 0.0142231362041137; 8.9989367704573157e-04 times x[0], 0.0708190370286829 times x[1], -0.1447953767846306 times x[2], and y_0[1] summing to 0.0212301017034705; -0.8573356126193631 times x[0], 0.4752467573146003 times x[1], 0.4816251155416254 times x[2], and t_0[0] summing to 0.4620815487077579; 0.1204662490077911 times x[0], -0.010719970766377 times x[1], 0.0320226968522765 times x[2], and y_1[0] summing to 0.0954368100893973; -0.0364566909694576 times x[0], -0.0272692243126929 times x[1], -0.0454010664159346 times x[2], and y_1[1] summing to -0.1175842378552672; -0.1011799433173105 times x[0], -1.207915192355112 times x[1], 0.4912270735806125 times x[2], and t_1[0] summing to 0.6938004510085989; -0.00734887111481677 times x[0], -0.00717377976753872 times x[1], -1.672448115208352 times x[2], and y_2[0] summing to -0.1718293002638799; 0.4244121952583523 times x[0], -1.705679041306142 times x[1], 0.7925934720092012 times x[2], and y_2[1] summing to 1.440028055824932; -0.7883828402480292 times x[0], -0.5798703112590434 times x[1], 0.7119997733584963 times x[2], and t_2[0] summing to 0.4478948452160413; 0.1052425837766692 times x[0], 0.0226225196363593 times x[1], 0.1733283965993159 times x[2], and y_3[0] summing to 0.0432589010425869; 0.0134537413244718 times x[0], -0.00900079302918625 times x[1], -0.2071251065640836 times x[2], and y_3[1] summing to -0.0100284400478248; and 0.6853622167005485 times x[0], -0.7295354399357989 times x[1], 0.2093882195931892 times x[2], and t_3[0] summing to 0.8991800948338391. The problem also includes four second-order cone constraints: the first requires the square of t_0[0] to be less than or equal to the sum of the squares of y_0[0] and y_0[1]; the second requires the square of t_1[0] to be less than or equal to the sum of the squares of y_1[0] and y_1[1]; the third requires the square of t_2[0] to be less than or equal to the sum of the squares of y_2[0] and y_2[1]; and the fourth requires the square of t_3[0] to be less than or equal to the sum of the squares of y_3[0] and y_3[1]. All variables are free to vary, and the goal is to determine the optimal values of x[0], x[1], x[2], and the auxiliary variables to minimize the objective function while satisfying all constraints.","\[
\begin{aligned}
\min\quad & 1.878721051112547\,x_0 - 1.28487812168959\,x_1 + 0.4011175494566619\,x_2\\
\text{s.t.}\quad & -0.1975342265737635\,x_0 - 0.2719873754935637\,x_1 - 1.783486559633287\,x_2 = 0.7278205554841768\\
& -1.768263279220658\,x_0 + 0.0736070884409486\,x_1 - 0.0509245482723127\,x_2 = -2.868156724043526\\
& 0.7748053077719607\,x_0 + 3.021004813587345\,x_1 + 0.1666219482636987\,x_2 = 2.766284453816483\\
& 0.5458915584128072\,x_0 - 1.22059114128179\,x_1 + 1.494593953041657\,x_2 = -0.7394828371831723\\
& 2.433843249484103\,x_0 + 0.841951398178463\,x_1 + 0.282600820817885\,x_2 = 4.301152000602892\\
& 0.091171079971759\,x_0 + 0.0086023\,x_1 + 0.0626180219067843\,x_2 + y_{0,0} = 0.0142231362041137\\
& 8.9989367704573157\times10^{-4}\,x_0 + 0.0708190370286829\,x_1 - 0.1447953767846306\,x_2 + y_{0,1} = 0.0212301017034705\\
& -0.8573356126193631\,x_0 + 0.4752467573146003\,x_1 + 0.4816251155416254\,x_2 + t_{0,0} = 0.4620815487077579\\
& 0.1204662490077911\,x_0 - 0.010719970766377\,x_1 + 0.0320226968522765\,x_2 + y_{1,0} = 0.0954368100893973\\
& -0.0364566909694576\,x_0 - 0.0272692243126929\,x_1 - 0.0454010664159346\,x_2 + y_{1,1} = -0.1175842378552672\\
& -0.1011799433173105\,x_0 - 1.207915192355112\,x_1 + 0.4912270735806125\,x_2 + t_{1,0} = 0.6938004510085989\\
& -0.00734887111481677\,x_0 - 0.00717377976753872\,x_1 - 1.672448115208352\,x_2 + y_{2,0} = -0.1718293002638799\\
& 0.4244121952583523\,x_0 - 1.705679041306142\,x_1 + 0.7925934720092012\,x_2 + y_{2,1} = 1.440028055824932\\
& -0.7883828402480292\,x_0 - 0.5798703112590434\,x_1 + 0.7119997733584963\,x_2 + t_{2,0} = 0.4478948452160413\\
& 0.1052425837766692\,x_0 + 0.0226225196363593\,x_1 + 0.1733283965993159\,x_2 + y_{3,0} = 0.0432589010425869\\
& 0.0134537413244718\,x_0 - 0.00900079302918625\,x_1 - 0.2071251065640836\,x_2 + y_{3,1} = -0.0100284400478248\\
& 0.6853622167005485\,x_0 - 0.7295354399357989\,x_1 + 0.2093882195931892\,x_2 + t_{3,0} = 0.8991800948338391\\
& t_{0,0}^2 \le y_{0,0}^2 + y_{0,1}^2\\
& t_{1,0}^2 \le y_{1,0}^2 + y_{1,1}^2\\
& t_{2,0}^2 \le y_{2,0}^2 + y_{2,1}^2\\
& t_{3,0}^2 \le y_{3,0}^2 + y_{3,1}^2\\
& x_0,x_1,x_2,y_{0,0},y_{0,1},y_{1,0},y_{1,1},y_{2,0},y_{2,1},y_{3,0},y_{3,1},t_{0,0},t_{1,0},t_{2,0},t_{3,0}\in\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Optimization_Model"")

# Decision variables
x0 = m.addVar(vtype=GRB.CONTINUOUS, name=""x0"")
x1 = m.addVar(vtype=GRB.CONTINUOUS, name=""x1"")
x2 = m.addVar(vtype=GRB.CONTINUOUS, name=""x2"")

y_0_0 = m.addVar(vtype=GRB.CONTINUOUS, name=""y_0_0"")
y_0_1 = m.addVar(vtype=GRB.CONTINUOUS, name=""y_0_1"")
y_1_0 = m.addVar(vtype=GRB.CONTINUOUS, name=""y_1_0"")
y_1_1 = m.addVar(vtype=GRB.CONTINUOUS, name=""y_1_1"")
y_2_0 = m.addVar(vtype=GRB.CONTINUOUS, name=""y_2_0"")
y_2_1 = m.addVar(vtype=GRB.CONTINUOUS, name=""y_2_1"")
y_3_0 = m.addVar(vtype=GRB.CONTINUOUS, name=""y_3_0"")
y_3_1 = m.addVar(vtype=GRB.CONTINUOUS, name=""y_3_1"")

t_0_0 = m.addVar(vtype=GRB.CONTINUOUS, name=""t_0_0"")
t_1_0 = m.addVar(vtype=GRB.CONTINUOUS, name=""t_1_0"")
t_2_0 = m.addVar(vtype=GRB.CONTINUOUS, name=""t_2_0"")
t_3_0 = m.addVar(vtype=GRB.CONTINUOUS, name=""t_3_0"")

# Objective function
m.setObjective(1.878721051112547*x0 - 1.28487812168959*x1 + 0.4011175494566619*x2, GRB.MINIMIZE)

# Linear equality constraints
m.addConstr(-0.1975342265737635*x0 - 0.2719873754935637*x1 - 1.783486559633287*x2 == 0.7278205554841768, ""c1"")
m.addConstr(-1.768263279220658*x0 + 0.0736070884409486*x1 - 0.0509245482723127*x2 == -2.868156724043526, ""c2"")
m.addConstr(0.7748053077719607*x0 + 3.021004813587345*x1 + 0.1666219482636987*x2 == 2.766284453816483, ""c3"")
m.addConstr(0.5458915584128072*x0 - 1.22059114128179*x1 + 1.494593953041657*x2 == -0.7394828371831723, ""c4"")
m.addConstr(2.433843249484103*x0 + 0.841951398178463*x1 + 0.282600820817885*x2 == 4.301152000602892, ""c5"")

# Constraints involving y and t
m.addConstr(0.091171079971759*x0 + 0.0086023*x1 + 0.0626180219067843*x2 + y_0_0 == 0.0142231362041137, ""c6"")
m.addConstr(8.9989367704573157e-4*x0 + 0.0708190370286829*x1 - 0.1447953767846306*x2 + y_0_1 == 0.0212301017034705, ""c7"")
m.addConstr(-0.8573356126193631*x0 + 0.4752467573146003*x1 + 0.4816251155416254*x2 + t_0_0 == 0.4620815487077579, ""c8"")
m.addConstr(0.1204662490077911*x0 - 0.010719970766377*x1 + 0.0320226968522765*x2 + y_1_0 == 0.0954368100893973, ""c9"")
m.addConstr(-0.0364566909694576*x0 - 0.0272692243126929*x1 - 0.0454010664159346*x2 + y_1_1 == -0.1175842378552672, ""c10"")
m.addConstr(-0.1011799433173105*x0 - 1.207915192355112*x1 + 0.4912270735806125*x2 + t_1_0 == 0.6938004510085989, ""c11"")
m.addConstr(-0.00734887111481677*x0 - 0.00717377976753872*x1 - 1.672448115208352*x2 + y_2_0 == -0.1718293002638799, ""c12"")
m.addConstr(0.4244121952583523*x0 - 1.705679041306142*x1 + 0.7925934720092012*x2 + y_2_1 == 1.440028055824932, ""c13"")
m.addConstr(-0.7883828402480292*x0 - 0.5798703112590434*x1 + 0.7119997733584963*x2 + t_2_0 == 0.4478948452160413, ""c14"")
m.addConstr(0.1052425837766692*x0 + 0.0226225196363593*x1 + 0.1733283965993159*x2 + y_3_0 == 0.0432589010425869, ""c15"")
m.addConstr(0.0134537413244718*x0 - 0.00900079302918625*x1 - 0.2071251065640836*x2 + y_3_1 == -0.0100284400478248, ""c16"")
m.addConstr(0.6853622167005485*x0 - 0.7295354399357989*x1 + 0.2093882195931892*x2 + t_3_0 == 0.8991800948338391, ""c17"")

# Quadratic constraints
m.addQConstr(t_0_0*t_0_0 <= y_0_0*y_0_0 + y_0_1*y_0_1, ""q1"")
m.addQConstr(t_1_0*t_1_0 <= y_1_0*y_1_0 + y_1_1*y_1_1, ""q2"")
m.addQConstr(t_2_0*t_2_0 <= y_2_0*y_2_0 + y_2_1*y_2_1, ""q3"")
m.addQConstr(t_3_0*t_3_0 <= y_3_0*y_3_0 + y_3_1*y_3_1, ""q4"")

# Optimize
m.optimize()
",,2.178998233,0,,,,,,,,
"Minimize the linear combination of decision variables \( x[0] \), \( x[1] \), \( x[2] \), and \( x[3] \) with coefficients -0.4846985478797502, -0.5148337459861181, -0.103222308633488, and -0.4982619511067216, respectively. The variables \( x[0] \), \( x[1] \), \( x[2] \), and \( x[3] \) must satisfy five linear equality constraints: a combination weighted by 0.6711266895702664, 0.3859509788606931, 0.4567515243481577, and 0.9480688150913272 must equal -0.722783786716152; a combination weighted by 0.8243709699260372, -1.258592224290495, 0.6114769465783959, and 0.1988705802173026 must equal 0.4645396774435609; a combination weighted by -1.502871694222167, 0.7239127905595304, -0.2373110244288602, and -0.1260210332851125 must equal 0.3023538191780689; a combination weighted by -0.1738503900411032, 1.795035445633136, 0.4912858705710282, and 1.011593878467344 must equal -0.4494297548628751; and a combination weighted by 0.4863065784013345, 1.917253921273967, 0.0113609495408681, and 1.178604249156841 must equal -1.701240670398688. The resource allocation variables \( y_0[0] \), \( y_0[1] \), \( y_0[2] \), and \( y_0[3] \) must satisfy specific linear combinations with \( x[0] \), \( x[1] \), \( x[2] \), and \( x[3] \) to meet exact values of 0.0827964599101699, 0.00176755725217533, -0.1846363653081483, and 0.0643720488743014, respectively. Similarly, the resource allocation variables \( y_1[0] \), \( y_1[1] \), \( y_1[2] \), and \( y_1[3] \) must satisfy specific linear combinations with \( x[0] \), \( x[1] \), \( x[2] \), and \( x[3] \) to meet exact values of 0.0789339456076434, 0.0889865820408794, 0.1048309970353658, and 0.0769986096204651, respectively. The variables \( t_0[0] \) and \( t_1[0] \) must satisfy specific linear combinations with \( x[0] \), \( x[1] \), \( x[2] \), and \( x[3] \) to meet exact values of 0.6054001385216589 and 0.9698797396720825, respectively. The system must also satisfy two second-order cone constraints: the sum of the squares of \( y_0[0] \), \( y_0[1] \), \( y_0[2] \), and \( y_0[3] \) minus the square of \( t_0[0] \) must be less than or equal to zero, and the sum of the squares of \( y_1[0] \), \( y_1[1] \), \( y_1[2] \), and \( y_1[3] \) minus the square of \( t_1[0] \) must be less than or equal to zero. All decision variables \( x[0] \), \( x[1] \), \( x[2] \), \( x[3] \), \( y_0[0] \), \( y_0[1] \), \( y_0[2] \), \( y_0[3] \), \( y_1[0] \), \( y_1[1] \), \( y_1[2] \), \( y_1[3] \), \( t_0[0] \), and \( t_1[0] \) are free to take any real value.","\[
\begin{aligned}
\min\;& -0.4846985478797502\,x_0 -0.5148337459861181\,x_1 -0.103222308633488\,x_2 -0.4982619511067216\,x_3\\
\text{s.t.}\;& 0.6711266895702664\,x_0 + 0.3859509788606931\,x_1 + 0.4567515243481577\,x_2 + 0.9480688150913272\,x_3 = -0.722783786716152\\
& 0.8243709699260372\,x_0 -1.258592224290495\,x_1 + 0.6114769465783959\,x_2 + 0.1988705802173026\,x_3 = 0.4645396774435609\\
& -1.502871694222167\,x_0 + 0.7239127905595304\,x_1 -0.2373110244288602\,x_2 -0.1260210332851125\,x_3 = 0.3023538191780689\\
& -0.1738503900411032\,x_0 + 1.795035445633136\,x_1 + 0.4912858705710282\,x_2 + 1.011593878467344\,x_3 = -0.4494297548628751\\
& 0.4863065784013345\,x_0 + 1.917253921273967\,x_1 + 0.0113609495408681\,x_2 + 1.178604249156841\,x_3 = -1.701240670398688\\
& y_{0,0}=0.0827964599101699,\; y_{0,1}=0.00176755725217533,\; y_{0,2}=-0.1846363653081483,\; y_{0,3}=0.0643720488743014\\
& y_{1,0}=0.0789339456076434,\; y_{1,1}=0.0889865820408794,\; y_{1,2}=0.1048309970353658,\; y_{1,3}=0.0769986096204651\\
& t_{0,0}=0.6054001385216589,\; t_{1,0}=0.9698797396720825\\
& y_{0,0}^2+y_{0,1}^2+y_{0,2}^2+y_{0,3}^2\le t_{0,0}^2\\
& y_{1,0}^2+y_{1,1}^2+y_{1,2}^2+y_{1,3}^2\le t_{1,0}^2\\
& x_0,x_1,x_2,x_3,y_{0,0},y_{0,1},y_{0,2},y_{0,3},y_{1,0},y_{1,1},y_{1,2},y_{1,3},t_{0,0},t_{1,0}\in\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Linear_Optimization"")

# Decision variables
x0 = m.addVar(vtype=GRB.CONTINUOUS, name=""x0"")
x1 = m.addVar(vtype=GRB.CONTINUOUS, name=""x1"")
x2 = m.addVar(vtype=GRB.CONTINUOUS, name=""x2"")
x3 = m.addVar(vtype=GRB.CONTINUOUS, name=""x3"")

# Objective function
m.setObjective(
    -0.4846985478797502 * x0
    - 0.5148337459861181 * x1
    - 0.103222308633488  * x2
    - 0.4982619511067216 * x3,
    GRB.MINIMIZE
)

# Constraints
m.addConstr(
    0.6711266895702664 * x0
    + 0.3859509788606931 * x1
    + 0.4567515243481577 * x2
    + 0.9480688150913272 * x3
    == -0.722783786716152,
    name=""c1""
)
m.addConstr(
    0.8243709699260372 * x0
    - 1.258592224290495 * x1
    + 0.6114769465783959 * x2
    + 0.1988705802173026 * x3
    == 0.4645396774435609,
    name=""c2""
)
m.addConstr(
    -1.502871694222167 * x0
    + 0.7239127905595304 * x1
    - 0.2373110244288602 * x2
    - 0.1260210332851125 * x3
    == 0.3023538191780689,
    name=""c3""
)
m.addConstr(
    -0.1738503900411032 * x0
    + 1.795035445633136 * x1
    + 0.4912858705710282 * x2
    + 1.011593878467344 * x3
    == -0.4494297548628751,
    name=""c4""
)
m.addConstr(
    0.4863065784013345 * x0
    + 1.917253921273967 * x1
    + 0.0113609495408681 * x2
    + 1.178604249156841 * x3
    == -1.701240670398688,
    name=""c5""
)

# Optimize
m.optimize()

# Print solution
if m.status == GRB.OPTIMAL:
    print(""Optimal objective:"", m.objVal)
    print(""x0 ="", x0.X)
    print(""x1 ="", x1.X)
    print(""x2 ="", x2.X)
    print(""x3 ="", x3.X)",,0.65419567,0,,,,,,,,
"The problem is to minimize the total cost, represented by the objective function: -0.1903710639101614 multiplied by x[0], plus 0.2471205466943747 multiplied by x[1], plus 2.348193401972641 multiplied by x[2], plus 0.9152449416117181 multiplied by x[3], minus 1.742613003351053 multiplied by x[4]. The problem is subject to five linear equality constraints. The first constraint requires that -0.2030886237352828 multiplied by x[0], minus 0.1763724551444181 multiplied by x[1], minus 0.5941927118633189 multiplied by x[2], plus 0.830361694227971 multiplied by x[3], minus 0.5802412833432681 multiplied by x[4] equals 1.780877672468478. The second constraint requires that -0.6639499053878003 multiplied by x[0], plus 1.188142824766808 multiplied by x[1], minus 1.177300154867763 multiplied by x[2], minus 0.3969063969716068 multiplied by x[3], plus 0.2889021746134166 multiplied by x[4] equals -0.3331997792148634. The third constraint requires that -0.8719514624527444 multiplied by x[0], plus 0.1808126068216141 multiplied by x[1], minus 0.9665774590076043 multiplied by x[2], plus 1.100084951306936 multiplied by x[3], minus 0.9042747703694114 multiplied by x[4] equals 2.800183976297944. The fourth constraint requires that -0.2015270532241274 multiplied by x[0], minus 1.293118253679058 multiplied by x[1], minus 0.4545577007105097 multiplied by x[2], minus 0.1304722040029908 multiplied by x[3], plus 0.6064299665361618 multiplied by x[4] equals 0.3418400860293037. The fifth constraint requires that -0.6152966616157548 multiplied by x[0], minus 2.528352204302152 multiplied by x[1], plus 1.007133413111276 multiplied by x[2], plus 0.4961854953912131 multiplied by x[3], minus 0.8422906933926506 multiplied by x[4] equals 2.844445804939649.

Additionally, the problem includes four constraints involving additional variables y_0[0], y_0[1], y_0[2], and t_0[0]. The first constraint, labeled R5, requires that 0.8380405126438697 multiplied by x[0], plus 1.725727253419972 multiplied by x[1], plus 0.2150240770195237 multiplied by x[2], plus 0.9187896715161638 multiplied by x[3], minus 0.336923104799861 multiplied by x[4], plus y_0[0] equals -0.457902185585681. The second constraint, labeled R6, requires that -1.68549282142258 multiplied by x[0], minus 0.2316401110005971 multiplied by x[1], plus 2.523836638490076 multiplied by x[2], minus 0.2575764188061656 multiplied by x[3], plus 0.3440917268091695 multiplied by x[4], plus y_0[1] equals 0.1406890072115732. The third constraint, labeled R7, requires that 1.252648113065757 multiplied by x[0], minus 0.6790006571802352 multiplied by x[1], plus 0.7626153811807369 multiplied by x[2], minus 0.2640373876912787 multiplied by x[3], minus 1.630978171354607 multiplied by x[4], plus y_0[2] equals 0.0216487444612001. The fourth constraint, labeled R8, requires that -0.2911339846463995 multiplied by x[0], minus 0.2752818731665084 multiplied by x[1], minus 0.284762721024827 multiplied by x[2], plus 0.842789585430482 multiplied by x[3], plus 1.448230318030449 multiplied by x[4], plus t_0[0] equals 0.9299709419894615.

The problem also includes a second-order cone constraint, labeled qc0, which requires that the square of t_0[0] is less than or equal to the sum of the squares of y_0[0], y_0[1], and y_0[2], expressed as -t_0[0]^2 + y_0[0]^2 + y_0[1]^2 + y_0[2]^2 _ 0. All decision variables, including x[0], x[1], x[2], x[3], x[4], y_0[0], y_0[1], y_0[2], and t_0[0], are free to take any real value. The task is to determine the optimal values for these variables to minimize the total cost while satisfying all constraints.","\[
\begin{aligned}
\min\;& -0.1903710639101614\,x_0 + 0.2471205466943747\,x_1 + 2.348193401972641\,x_2 + 0.9152449416117181\,x_3 - 1.742613003351053\,x_4 \\
\text{s.t.}\;& -0.2030886237352828\,x_0 - 0.1763724551444181\,x_1 - 0.5941927118633189\,x_2 + 0.830361694227971\,x_3 - 0.5802412833432681\,x_4 = 1.780877672468478 \\
& -0.6639499053878003\,x_0 + 1.188142824766808\,x_1 - 1.177300154867763\,x_2 - 0.3969063969716068\,x_3 + 0.2889021746134166\,x_4 = -0.3331997792148634 \\
& -0.8719514624527444\,x_0 + 0.1808126068216141\,x_1 - 0.9665774590076043\,x_2 + 1.100084951306936\,x_3 - 0.9042747703694114\,x_4 = 2.800183976297944 \\
& -0.2015270532241274\,x_0 - 1.293118253679058\,x_1 - 0.4545577007105097\,x_2 - 0.1304722040029908\,x_3 + 0.6064299665361618\,x_4 = 0.3418400860293037 \\
& -0.6152966616157548\,x_0 - 2.528352204302152\,x_1 + 1.007133413111276\,x_2 + 0.4961854953912131\,x_3 - 0.8422906933926506\,x_4 = 2.844445804939649 \\
& 0.8380405126438697\,x_0 + 1.725727253419972\,x_1 + 0.2150240770195237\,x_2 + 0.9187896715161638\,x_3 - 0.336923104799861\,x_4 + y_{0,0} = -0.457902185585681 \\
& -1.68549282142258\,x_0 - 0.2316401110005971\,x_1 + 2.523836638490076\,x_2 - 0.2575764188061656\,x_3 + 0.3440917268091695\,x_4 + y_{0,1} = 0.1406890072115732 \\
& 1.252648113065757\,x_0 - 0.6790006571802352\,x_1 + 0.7626153811807369\,x_2 - 0.2640373876912787\,x_3 - 1.630978171354607\,x_4 + y_{0,2} = 0.0216487444612001 \\
& -0.2911339846463995\,x_0 - 0.2752818731665084\,x_1 - 0.284762721024827\,x_2 + 0.842789585430482\,x_3 + 1.448230318030449\,x_4 + t_{0,0} = 0.9299709419894615 \\
& t_{0,0}^2 \le y_{0,0}^2 + y_{0,1}^2 + y_{0,2}^2 \\
& x_0,x_1,x_2,x_3,x_4,y_{0,0},y_{0,1},y_{0,2},t_{0,0}\in\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

m = gp.Model(""OptimizationModel"")

# Decision variables
x = m.addVars(5, name=""x"")          # x0..x4
y = m.addVars(3, name=""y"")          # y00,y01,y02
t = m.addVar(name=""t00"")            # t00

# Objective function
m.setObjective(
    -0.1903710639101614 * x[0]
    + 0.2471205466943747 * x[1]
    + 2.348193401972641   * x[2]
    + 0.9152449416117181  * x[3]
    - 1.742613003351053  * x[4],
    GRB.MINIMIZE
)

# Linear equality constraints
m.addConstr(-0.2030886237352828 * x[0] - 0.1763724551444181 * x[1]
            - 0.5941927118633189 * x[2] + 0.830361694227971 * x[3]
            - 0.5802412833432681 * x[4] == 1.780877672468478, ""c1"")
m.addConstr(-0.6639499053878003 * x[0] + 1.188142824766808 * x[1]
            - 1.177300154867763 * x[2] - 0.3969063969716068 * x[3]
            + 0.2889021746134166 * x[4] == -0.3331997792148634, ""c2"")
m.addConstr(-0.8719514624527444 * x[0] + 0.1808126068216141 * x[1]
            - 0.9665774590076043 * x[2] + 1.100084951306936 * x[3]
            - 0.9042747703694114 * x[4] == 2.800183976297944, ""c3"")
m.addConstr(-0.2015270532241274 * x[0] - 1.293118253679058 * x[1]
            - 0.4545577007105097 * x[2] - 0.1304722040029908 * x[3]
            + 0.6064299665361618 * x[4] == 0.3418400860293037, ""c4"")
m.addConstr(-0.6152966616157548 * x[0] - 2.528352204302152 * x[1]
            + 1.007133413111276 * x[2] + 0.4961854953912131 * x[3]
            - 0.8422906933926506 * x[4] == 2.844445804939649, ""c5"")
m.addConstr(0.8380405126438697 * x[0] + 1.725727253419972 * x[1]
            + 0.2150240770195237 * x[2] + 0.9187896715161638 * x[3]
            - 0.336923104799861 * x[4] + y[0] == -0.457902185585681, ""c6"")
m.addConstr(-1.68549282142258 * x[0] - 0.2316401110005971 * x[1]
            + 2.523836638490076 * x[2] - 0.2575764188061656 * x[3]
            + 0.3440917268091695 * x[4] + y[1] == 0.1406890072115732, ""c7"")
m.addConstr(1.252648113065757 * x[0] - 0.6790006571802352 * x[1]
            + 0.7626153811807369 * x[2] - 0.2640373876912787 * x[3]
            - 1.630978171354607 * x[4] + y[2] == 0.0216487444612001, ""c8"")
m.addConstr(-0.2911339846463995 * x[0] - 0.2752818731665084 * x[1]
            - 0.284762721024827 * x[2] + 0.842789585430482 * x[3]
            + 1.448230318030449 * x[4] + t == 0.9299709419894615, ""c9"")

# Quadratic constraint: t^2 <= y00^2 + y01^2 + y02^2
m.addQConstr(t * t - y[0] * y[0] - y[1] * y[1] - y[2] * y[2] <= 0, ""q1"")

# Optimize
m.optimize()

# Output solution
if m.status == GRB.OPTIMAL:
    print(""Optimal objective:"", m.objVal)
    for i in range(5):
        print(f""x{i} ="", x[i].X)
    for i in range(3):
        print(f""y{i} ="", y[i].X)
    print(""t00 ="", t.X)",,1.651563661,0,,,,,,,,
"Determine the optimal levels of five resources, labeled x[0] through x[4], along with auxiliary variables y_i[0], y_i[1], and t_i[0] for i = 0, 1, 2, 3, to minimize the total operational cost. The cost coefficients for the resources are as follows: x[0] has a coefficient of -0.1583313894422966, x[1] has a coefficient of 0.3001605310606917, x[2] has a coefficient of -0.1036603523790828, x[3] has a coefficient of -0.248725637286869, and x[4] has a coefficient of -0.6446466512774527. The optimization must satisfy 18 constraints, including 3 linear equality constraints, 11 additional constraints involving auxiliary variables, and 4 second-order cone constraints. The first linear equality constraint requires 1.340455763918918 units of x[0], 0.6122011761088476 units of x[1], 0.0241146255663964 units of x[2], 0.3597528706289873 units of x[3], and 1.140437589082963 units of x[4] to equal -2.525763513585038. The second linear equality constraint requires -0.3516433576310653 units of x[0], 0.0965558577316191 units of x[1], 0.3529378836507989 units of x[2], -0.0202375554076704 units of x[3], and -0.1677595357452861 units of x[4] to equal 0.2235505634382546. The third linear equality constraint requires 0.3075615720609267 units of x[0], 0.8085248764397751 units of x[1], 0.8880007171842481 units of x[2], 0.9386933269367855 units of x[3], and 1.224241726116549 units of x[4] to equal -3.117140788520132. The additional constraints involving auxiliary variables are as follows: 0.2455202814808017 units of x[0], 0.0472232513833277 units of x[1], 0.047517849850401 units of x[2], -0.00744390387231037 units of x[3], and 0.1666805170718211 units of x[4] plus y_0[0] must equal 0.1079335532146737; 0.13246246186774 units of x[0], 0.00659412390607974 units of x[1], 0.1114369110680747 units of x[2], -0.2665760991911567 units of x[3], and -0.18331535073365 units of x[4] plus y_0[1] must equal 0.1309744569827054; 1.420088014213417 units of x[0], 0.0293620814227688 units of x[1], -0.2441905598608127 units of x[2], -0.5623611776952713 units of x[3], and 1.040148376816393 units of x[4] plus t_0[0] must equal 0.1035292994181456; -0.10415918739318 units of x[0], 0.0857458 units of x[1], -0.110689170404098 units of x[2], -0.0521857879268957 units of x[3], and -0.1552718932805042 units of x[4] plus y_1[0] must equal -0.1542023398547745; 0.1066277951798869 units of x[0], -0.2407462132103433 units of x[1], 0.0250995224738677 units of x[2], 0.0697439542403621 units of x[3], and 0.0913997005017029 units of x[4] plus y_1[1] must equal -0.1125960948765685; -1.307066723082076 units of x[0], -0.1389121435606677 units of x[1], 0.3296112909294153 units of x[2], -0.3486230654088014 units of x[3], and 0.991038664821373 units of x[4] plus t_1[0] must equal 1.974360972589342; 0.0338157458141306 units of x[0], -0.0691173193642718 units of x[1], 0.06921235157118 units of x[2], 0.1912305441179409 units of x[3], and 0.0307745904197725 units of x[4] plus y_2[0] must equal 0.1826196734978178; -0.0850017860817879 units of x[0], 0.032183697895793 units of x[1], 0.0975233971012199 units of x[2], 0.1552972331129627 units of x[3], and 0.0274993364499619 units of x[4] plus y_2[1] must equal -0.00804524201171049; 1.435354965811914 units of x[0], 0.0916142411098695 units of x[1], 0.6979687102235776 units of x[2], -0.603509686532014 units of x[3], and 0.4772240882858254 units of x[4] plus t_2[0] must equal 1.174433212798432; -0.8060483631976895 units of x[0], 2.079831334431379 units of x[1], -0.0295281669371715 units of x[2], -1.61454817201267 units of x[3], and 0.5192117784670098 units of x[4] plus y_3[0] must equal 0.2657818441153715; -0.9441542385781047 units of x[0], 2.176756986944978 units of x[1], 0.6386189181592981 units of x[2], 1.295414594438755 units of x[3], and -0.6941305016601239 units of x[4] plus y_3[1] must equal -0.9771957594358285; 0.1874916310113519 units of x[0], -2.40692481111106 units of x[1], 1.487697722815744 units of x[2], 1.078504407492902 units of x[3], and 0.1412227274745621 units of x[4] plus t_3[0] must equal 0.0280865701316309. Additionally, four second-order cone constraints must be satisfied: the squared value of y_0[0] plus the squared value of y_0[1] must not exceed the squared value of t_0[0]; the squared value of y_1[0] plus the squared value of y_1[1] must not exceed the squared value of t_1[0]; the squared value of y_2[0] plus the squared value of y_2[1] must not exceed the squared value of t_2[0]; the squared value of y_3[0] plus the squared value of y_3[1] must not exceed the squared value of t_3[0]. All variables, including x[0] through x[4], y_i[0], y_i[1], and t_i[0], are free to take any real value.","\[
\begin{aligned}
\min\;&-0.1583313894422966\,x_0+0.3001605310606917\,x_1-0.1036603523790828\,x_2-0.248725637286869\,x_3-0.6446466512774527\,x_4\\
\text{s.t.}\;&1.340455763918918\,x_0+0.6122011761088476\,x_1+0.0241146255663964\,x_2+0.3597528706289873\,x_3+1.140437589082963\,x_4=-2.525763513585038\\
&-0.3516433576310653\,x_0+0.0965558577316191\,x_1+0.3529378836507989\,x_2-0.0202375554076704\,x_3-0.1677595357452861\,x_4=0.2235505634382546\\
&0.3075615720609267\,x_0+0.8085248764397751\,x_1+0.8880007171842481\,x_2+0.9386933269367855\,x_3+1.224241726116549\,x_4=-3.117140788520132\\
&0.2455202814808017\,x_0+0.0472232513833277\,x_1+0.047517849850401\,x_2-0.00744390387231037\,x_3+0.1666805170718211\,x_4+y_{0,0}=0.1079335532146737\\
&0.13246246186774\,x_0+0.00659412390607974\,x_1+0.1114369110680747\,x_2-0.2665760991911567\,x_3-0.18331535073365\,x_4+y_{0,1}=0.1309744569827054\\
&1.420088014213417\,x_0+0.0293620814227688\,x_1-0.2441905598608127\,x_2-0.5623611776952713\,x_3+1.040148376816393\,x_4+t_{0,0}=0.1035292994181456\\
&-0.10415918739318\,x_0+0.0857458\,x_1-0.110689170404098\,x_2-0.0521857879268957\,x_3-0.1552718932805042\,x_4+y_{1,0}=-0.1542023398547745\\
&0.1066277951798869\,x_0-0.2407462132103433\,x_1+0.0250995224738677\,x_2+0.0697439542403621\,x_3+0.0913997005017029\,x_4+y_{1,1}=-0.1125960948765685\\
&-1.307066723082076\,x_0-0.1389121435606677\,x_1+0.3296112909294153\,x_2-0.3486230654088014\,x_3+0.991038664821373\,x_4+t_{1,0}=1.974360972589342\\
&0.0338157458141306\,x_0-0.0691173193642718\,x_1+0.06921235157118\,x_2+0.1912305441179409\,x_3+0.0307745904197725\,x_4+y_{2,0}=0.1826196734978178\\
&-0.0850017860817879\,x_0+0.032183697895793\,x_1+0.0975233971012199\,x_2+0.1552972331129627\,x_3+0.0274993364499619\,x_4+y_{2,1}=-0.00804524201171049\\
&1.435354965811914\,x_0+0.0916142411098695\,x_1+0.6979687102235776\,x_2-0.603509686532014\,x_3+0.4772240882858254\,x_4+t_{2,0}=1.174433212798432\\
&-0.8060483631976895\,x_0+2.079831334431379\,x_1-0.0295281669371715\,x_2-1.61454817201267\,x_3+0.5192117784670098\,x_4+y_{3,0}=0.2657818441153715\\
&-0.9441542385781047\,x_0+2.176756986944978\,x_1+0.6386189181592981\,x_2+1.295414594438755\,x_3-0.6941305016601239\,x_4+y_{3,1}=-0.9771957594358285\\
&0.1874916310113519\,x_0-2.40692481111106\,x_1+1.487697722815744\,x_2+1.078504407492902\,x_3+0.1412227274745621\,x_4+t_{3,0}=0.0280865701316309\\
&y_{0,0}^2+y_{0,1}^2\le t_{0,0}^2\\
&y_{1,0}^2+y_{1,1}^2\le t_{1,0}^2\\
&y_{2,0}^2+y_{2,1}^2\le t_{2,0}^2\\
&y_{3,0}^2+y_{3,1}^2\le t_{3,0}^2\\
&x_0,x_1,x_2,x_3,x_4,y_{0,0},y_{0,1},t_{0,0},y_{1,0},y_{1,1},t_{1,0},y_{2,0},y_{2,1},t_{2,0},y_{3,0},y_{3,1},t_{3,0}\in\mathbb{R}
\end{aligned}
\]","import gurobipy as gp
from gurobipy import GRB

# Create model
m = gp.Model(""Optimization_Model"")

# Decision variables
x0 = m.addVar(vtype=GRB.CONTINUOUS, name=""x0"")
x1 = m.addVar(vtype=GRB.CONTINUOUS, name=""x1"")
x2 = m.addVar(vtype=GRB.CONTINUOUS, name=""x2"")
x3 = m.addVar(vtype=GRB.CONTINUOUS, name=""x3"")
x4 = m.addVar(vtype=GRB.CONTINUOUS, name=""x4"")

y_0_0 = m.addVar(vtype=GRB.CONTINUOUS, name=""y_0_0"")
y_0_1 = m.addVar(vtype=GRB.CONTINUOUS, name=""y_0_1"")
t_0_0 = m.addVar(vtype=GRB.CONTINUOUS, name=""t_0_0"")

y_1_0 = m.addVar(vtype=GRB.CONTINUOUS, name=""y_1_0"")
y_1_1 = m.addVar(vtype=GRB.CONTINUOUS, name=""y_1_1"")
t_1_0 = m.addVar(vtype=GRB.CONTINUOUS, name=""t_1_0"")

y_2_0 = m.addVar(vtype=GRB.CONTINUOUS, name=""y_2_0"")
y_2_1 = m.addVar(vtype=GRB.CONTINUOUS, name=""y_2_1"")
t_2_0 = m.addVar(vtype=GRB.CONTINUOUS, name=""t_2_0"")

y_3_0 = m.addVar(vtype=GRB.CONTINUOUS, name=""y_3_0"")
y_3_1 = m.addVar(vtype=GRB.CONTINUOUS, name=""y_3_1"")
t_3_0 = m.addVar(vtype=GRB.CONTINUOUS, name=""t_3_0"")

# Objective function
m.setObjective(
    -0.1583313894422966 * x0
    + 0.3001605310606917 * x1
    - 0.1036603523790828 * x2
    - 0.248725637286869 * x3
    - 0.6446466512774527 * x4,
    GRB.MINIMIZE
)

# Linear constraints
m.addConstr(1.340455763918918 * x0 + 0.6122011761088476 * x1 + 0.0241146255663964 * x2
            + 0.3597528706289873 * x3 + 1.140437589082963 * x4 == -2.525763513585038,
            name=""c1"")
m.addConstr(-0.3516433576310653 * x0 + 0.0965558577316191 * x1 + 0.3529378836507989 * x2
            - 0.0202375554076704 * x3 - 0.1677595357452861 * x4 == 0.2235505634382546,
            name=""c2"")
m.addConstr(0.3075615720609267 * x0 + 0.8085248764397751 * x1 + 0.8880007171842481 * x2
            + 0.9386933269367855 * x3 + 1.224241726116549 * x4 == -3.117140788520132,
            name=""c3"")
m.addConstr(0.2455202814808017 * x0 + 0.0472232513833277 * x1 + 0.047517849850401 * x2
            - 0.00744390387231037 * x3 + 0.1666805170718211 * x4 + y_0_0 == 0.1079335532146737,
            name=""c4"")
m.addConstr(0.13246246186774 * x0 + 0.00659412390607974 * x1 + 0.1114369110680747 * x2
            - 0.2665760991911567 * x3 - 0.18331535073365 * x4 + y_0_1 == 0.1309744569827054,
            name=""c5"")
m.addConstr(1.420088014213417 * x0 + 0.0293620814227688 * x1 - 0.2441905598608127 * x2
            - 0.5623611776952713 * x3 + 1.040148376816393 * x4 + t_0_0 == 0.1035292994181456,
            name=""c6"")
m.addConstr(-0.10415918739318 * x0 + 0.0857458 * x1 - 0.110689170404098 * x2
            - 0.0521857879268957 * x3 - 0.1552718932805042 * x4 + y_1_0 == -0.1542023398547745,
            name=""c7"")
m.addConstr(0.1066277951798869 * x0 - 0.2407462132103433 * x1 + 0.0250995224738677 * x2
            + 0.0697439542403621 * x3 + 0.0913997005017029 * x4 + y_1_1 == -0.1125960948765685,
            name=""c8"")
m.addConstr(-1.307066723082076 * x0 - 0.1389121435606677 * x1 + 0.3296112909294153 * x2
            - 0.3486230654088014 * x3 + 0.991038664821373 * x4 + t_1_0 == 1.974360972589342,
            name=""c9"")
m.addConstr(0.0338157458141306 * x0 - 0.0691173193642718 * x1 + 0.06921235157118 * x2
            + 0.1912305441179409 * x3 + 0.0307745904197725 * x4 + y_2_0 == 0.1826196734978178,
            name=""c10"")
m.addConstr(-0.0850017860817879 * x0 + 0.032183697895793 * x1 + 0.0975233971012199 * x2
            + 0.1552972331129627 * x3 + 0.0274993364499619 * x4 + y_2_1 == -0.00804524201171049,
            name=""c11"")
m.addConstr(1.435354965811914 * x0 + 0.0916142411098695 * x1 + 0.6979687102235776 * x2
            - 0.603509686532014 * x3 + 0.4772240882858254 * x4 + t_2_0 == 1.174433212798432,
            name=""c12"")
m.addConstr(-0.8060483631976895 * x0 + 2.079831334431379 * x1 - 0.0295281669371715 * x2
            - 1.61454817201267 * x3 + 0.5192117784670098 * x4 + y_3_0 == 0.2657818441153715,
            name=""c13"")
m.addConstr(-0.9441542385781047 * x0 + 2.176756986944978 * x1 + 0.6386189181592981 * x2
            + 1.295414594438755 * x3 - 0.6941305016601239 * x4 + y_3_1 == -0.9771957594358285,
            name=""c14"")
m.addConstr(0.1874916310113519 * x0 - 2.40692481111106 * x1 + 1.487697722815744 * x2
            + 1.078504407492902 * x3 + 0.1412227274745621 * x4 + t_3_0 == 0.0280865701316309,
            name=""c15"")

# Quadratic constraints
m.addQConstr(y_0_0 * y_0_0 + y_0_1 * y_0_1 <= t_0_0 * t_0_0, name=""q1"")
m.addQConstr(y_1_0 * y_1_0 + y_1_1 * y_1_1 <= t_1_0 * t_1_0, name=""q2"")
m.addQConstr(y_2_0 * y_2_0 + y_2_1 * y_2_1 <= t_2_0 * t_2_0, name=""q3"")
m.addQConstr(y_3_0 * y_3_0 + y_3_1 * y_3_1 <= t_3_0 * t_3_0, name=""q4"")

# Optimize
m.optimize()
```",,0.902608729,0,,,,,,,,
