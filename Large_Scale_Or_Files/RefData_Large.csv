prompt,Data_address,Label,Label_Code,Related,problem type
"The data of the store offers several styles of Nike shoes is provided in ""Nike_Shoes_Sales.csv"". Through the dataset, the revenue of each shoes is listed in the column ""revenue"". The demand for each style is independent. The store’s objective is to maximize the total expected revenue based on the fixed initial inventories of the Nike x Olivia Kim brand, which are detailed in column “inventory.” During the sales horizon, no replenishment is allowed, and there are no in-transit inventories. Customer arrivals, corresponding to demand for different styles of Nike shoes, occur in each period according to a Poisson process, with arrival rates specified in column “demand.” Moreover, the trade will be started only when the total demand is no less than 100 to ensure the trading efficiency. The decision variables y_i represent the number of customer requests the store intends to fulfill for Nike shoe style i, with each y_i being a positive integer.
","Large_Scale_Or_Files/NRM_example/nike_Shoes_Sales.csv
","
##### Objective Function: 

$\quad \quad \max \quad \sum_i A_i \cdot x_i$

##### Constraints

###### 1. Inventory Constraints: 

$\quad \quad x_i \leq I_i, \quad \forall i $

###### 2. Demand Constraints: 

$x_i \leq d_i, \quad \forall i $

###### 3. Variable Constraints: 

$x_i \in \mathbb Z, x_i \geq 0, \quad \forall i $

###### Retrieved Information
$\small I = [97, 240, 322, 281]$
$\small A =  [11197, 9097, 11197, 9995]$
$\small d =  [17, 26, 50, 53]$
$\small s = 100$",,"related to Nike x OliviaKim
",Network Revenue Management Problem
"A supermarket needs to allocate various products, including high-demand items like the Sony Alpha Refrigerator, Sony Bravia XR, and Sony PlayStation 5, across different retail shelves. The product values and space requirements are provided in the ""Products.csv"" dataset. Additionally, the store has multiple shelves, each with a total space limit and specific space constraints for Sony and Apple products, as outlined in the ""Capacity.csv"" file. The goal is to determine the optimal number of units of each Sony product to place on each shelf to maximize total value while ensuring that the space used by Sony products on each shelf does not exceed the brand-specific limits. The decision variables x_ij represent the number of units of product i to be placed on shelf j.
","Large_Scale_Or_Files/RA_example/capacity.csv
Large_Scale_Or_Files/RA_example/products.csv
","
##### Objective Function: 

$\quad \quad \max \sum_i \sum_j p_i \cdot x_{ij}$

##### Constraints

###### 1. Capacity Constraints: 

$\quad \quad \sum_i a_i x_{ij} \leq c_j, \quad \forall j$

###### 2. Non-negativity Constraints: 

$\quad \quad  x_{ij} \geq 0, \quad \forall i,j $

###### Retrieved Information
p = [1818, 1609, 509, 1808, 528]

a = [400, 200, 40, 60, 50]
c = [1200, 1374, 800, 2042, 1000, 1800]
",,"Sony
",Resource Allocation
"Walmart stores play a critical role in supplying essential goods to various customer groups on a daily basis. The problem involves determining the optimal transportation plan that satisfies the demands of 4 customer groups, whose daily demand data is provided in ""customer_demands.csv"". These demands must be met using supplies from 3 Walmart stores, each with a specific daily supply capacity detailed in ""supply_capacity.csv"". The transportation cost per unit of goods from each Walmart store to each customer group is recorded in ""transportation_costs.csv"". The objective is to determine the quantity of goods transported from each Walmart store to each customer group, ensuring that all demands are met without exceeding the supply capacity of any store, while minimizing the total transportation cost.","Large_Scale_Or_Files/TP_example/customer_demand.csv
Large_Scale_Or_Files/TP_example/supply_capacity.csv
Large_Scale_Or_Files/TP_example/transportation_costs.csv
","
##### Objective Function: 

$\quad \quad \min \sum_i \sum_j c_{ij} \cdot x_{ij}$

##### Constraints

###### 1. Demand Constraints: 

$\quad \quad \sum_i x_{ij} \geq d_j, \quad \forall j$

###### 2. Capacity Constraints: 

$\quad \quad  \sum_j x_{ij} \leq s_i, \quad \forall i$

###### Retrieved Information
```python
$d = [11, 1148, 54, 833]$
$s = [4, 575, 1504]$
$ c = \\begin{bmatrix}
0.63 & 49.71 & 33.75 & 1570.67 \\
605.47 & 64.53 & 478.47 & 887.04 \\
1139.04 & 4.78 & 1805.62 & 1302.89
\\end{bmatrix}$
```
",,,Transportation Problem
"In the Superstore chain, multiple branches require inventory replenishment, and several suppliers located in different cities can provide the necessary goods. Each supplier incurs a fixed cost upon starting operations, with the fixed cost data provided in the 'fixed_costs.csv' file. Each branch needs to source a certain quantity of goods from these suppliers. For each branch, the transportation cost per unit of goods from each supplier is recorded in the 'transportation_costs.csv' file. Demand information can be gained in 'demand.csv'. The objective is to determine which suppliers to activate so that the demand of all branches is met while minimizing the total cost.","Large_Scale_Or_Files/UFLP_example/demand.csv
Large_Scale_Or_Files/UFLP_example/fixed_cost.csv
Large_Scale_Or_Files/UFLP_example/transportation_costs.csv","
##### Objective Function: 

$\quad \quad \min \sum_{i} \sum_{j} A_{ij} x_{ij} + \sum_{j} c_j y_j $

##### Constraints

###### 1. Demand Constraints: 

$\quad \quad \sum_i x_{ij} = d_j, \quad \forall j$

###### 2. M Constraints: 

$\quad \quad \sum_i x_{ij} \leq M y_j, \quad \forall j$

###### 3. Variable Constraints: 

$ y_j \in \{{0,1\\}, \quad \forall j$

$ x_{ij} \geq 0, \forall i,j $
###### Retrieved Information

$d = [7564, 5246]$
$c = [105.1815083, 112.18423885]$
$M = \sum_j d_j = 7564 + 5246 = 12810$
$ A = \\begin{bmatrix}
937.34065048 & 86.93019411 \\
49.38016148 & 1726.06210136
\\end{bmatrix}$
",,,Facility Location Problem
"Based on flight ticket options provided in file ""./Test_Dataset/Air_NRM/information.csv"", along with their average passengers (Avg Pax), average prices (Avg Price), and capacity coefficients (Flex Cpy Coef), considering that each Eco_flex ticket consumes 2 units of flight capacity and each Eco_lite ticket consumes 1 unit of capacity, while enforcing flow conservation constraints at each airport for long-term planning model, develop a Sales-Based Linear Programming (SBLP) model. 

The goal of this model is to recommend the optimal 3 flights that maximize total ticket sale revenue, specifically among flights where the origin-destination pairs are: 
OD = ('A', 'B') or OD = ('A', 'C') or OD = ('B', 'A') or OD = ('B', 'C') or ('C', 'A') or ('C', 'B') in a departure period (7am-12:00am) in which the optional flights are:
[(OD = ('C', 'A') AND Departure Time='7:40'),
(OD = ('C', 'B') AND Departure Time='7:40'),
(OD = ('B', 'A') AND Departure Time='9:05'),
(OD = ('B', 'C') AND Departure Time='9:05'),
(OD = ('C', 'B') AND Departure Time='10:45'),
(OD = ('A', 'B') AND Departure Time='11:20'),
(OD = ('B', 'C') AND Departure Time='11:20')]",v1.csv/v2.csv/information_addB_2.csv,,,,Sales-Based Linear Programming-Flow
"Based on flight ticket options provided in './Test_Dataset/Air_NRM/information.csv', along with their associated attraction values (v1) and shadow attraction value ratios (v2), develop a Sales-Based Linear Programming (SBLP) model. The goal of this model is to recommend the optimal 3 flights that maximize total ticket sale revenue, specifically among flights with an origin-destination: OD = ('A', 'B') and a departure period (11am-1pm) in which the flights are: [(OD = ('A', 'B') AND Departure Time='11:20'), (OD = ('A', 'B') AND Departure Time='12:40')]",v1.csv/v2.csv/information_addB_2.csv,,,,Sales-Based Linear Programming-CA
"Based on all flight ticket choices in 'information1_addB_2.csv' with attraction values in v1 and shadow attraction value ratios in v2, develop the SBLP(sales-based linear programming) formulation  with flights (OD = ('B', 'A') AND Departure Time='12:25'), (OD = ('C', 'B') AND Departure Time='14:15'), (OD = ('B', 'A') AND Departure Time='20:25') that maximize the total revenue of flight ticket sales. The SBLP should include decision variables, objective function, balance constraints, scale constraints, nonnegative constraints.",v1.csv/v2.csv/information_addB_2.csv,,,,Sales-Based Linear Programming - CA
"A company plans to produce three products A_{1}, A_{2}, A_{3}. It can produce for 22 days in a month. The 36-1.csv file gives the maximum demand (in units of 100 kg), prices ($/100 kg), production costs (per 100 kg of product), and production quotas (the maximum number of units of 100 kg of product that can be produced in a day if all production lines are dedicated to that product).

The fixed activation cost for each production line is shown in 36-2.csv.

The minimum production batch sizes are shown in 36-3.csv.

The objective is to determine the production plan that maximizes total profit, accounting for total revenue, production costs, fixed activation costs, and minimum batch size restrictions.

Furthermore, we only consider integer decision variables, meaning the quantities of products produced are integer multiples of 100 kg. The binary decisions on whether to activate each production line are also integer (0 or 1).","Large_Scale_Or_Files/Other_example/36-1.csv
Large_Scale_Or_Files/Other_example/36-2.csv
Large_Scale_Or_Files/Other_example/36-3.csv","## Mathematical Model

**Maximize**

$$
50.7\, x_1 - 170{,}000\, y_1 
+ 56.1\, x_2 - 150{,}000\, y_2 
+ 49.6\, x_3 - 100{,}000\, y_3
$$

**subject to**

$$
x_1 \leq 5300 
\quad (\text{product 1 demand})
$$

$$
x_2 \leq 4500 
\quad (\text{product 2 demand})
$$

$$
x_3 \leq 5400 
\quad (\text{product 3 demand})
$$

$$
x_1 \leq 11{,}000 
\quad (\text{product 1 monthly quota})
$$

$$
x_2 \leq 9{,}900 
\quad (\text{product 2 monthly quota})
$$

$$
x_3 \leq 12{,}100 
\quad (\text{product 3 monthly quota})
$$

$$
x_1 \geq 20\, y_1 
\quad (\text{minimum batch for product 1})
$$

$$
x_2 \geq 20\, y_2 
\quad (\text{minimum batch for product 2})
$$

$$
x_3 \geq 16\, y_3 
\quad (\text{minimum batch for product 3})
$$

$$
x_1 \leq 5300\, y_1 
\quad (\text{linking product 1 activation})
$$

$$
x_2 \leq 4500\, y_2 
\quad (\text{linking product 2 activation})
$$

$$
x_3 \leq 5400\, y_3 
\quad (\text{linking product 3 activation})
$$

**where**

$$
x_1, x_2, x_3 \geq 0 
\quad (\text{integer, production amount in 100kg units})
$$

$$
y_1, y_2, y_3 \in \{0,1\} 
\quad (\text{binary, activation of production line})
$$","import gurobipy as gp
import pandas as pd
import numpy as np
import sys
import re

# (Helper function from template - not used in this static model)
def find_col(df, pattern):
    for col in df.columns:
        if re.search(pattern, col, re.IGNORECASE):
            return col
    raise KeyError(f""Could not find a column matching pattern '{{pattern}}'"")

try:
    # 1. Load data
    # (This step is skipped as all parameters are hard-coded
    # in the mathematical model provided.)

    # 2. Prepare data structures
    # (Based on the static values from the problem description)
    
    products = [1, 2, 3]
    
    # Objective function coefficients
    profit = {1: 50.7, 2: 56.1, 3: 49.6}
    fixed_cost = {1: 170000, 2: 150000, 3: 100000}
    
    # Constraint parameters
    demand = {1: 5300, 2: 4500, 3: 5400}
    quota = {1: 11000, 2: 9900, 3: 12100}
    min_batch = {1: 20, 2: 20, 3: 16}

    # 3. Build Gurobi model
    m = gp.Model('ProductionOptimization')
    
    # 4. Define variables
    # x[i]: production amount (in 100kg units) for product i
    x = m.addVars(products, vtype=gp.GRB.INTEGER, name=""x"")
    
    # y[i]: binary activation variable for product i
    y = m.addVars(products, vtype=gp.GRB.BINARY, name=""y"")
    
    # 5. Set objective
    # Maximize 50.7*x1 - 170000*y1 + 56.1*x2 - 150000*y2 + ...
    objective = gp.quicksum(profit[i] * x[i] - fixed_cost[i] * y[i] for i in products)
    m.setObjective(objective, gp.GRB.MAXIMIZE)

    # 6. Add constraints
    
    # Product demand constraints
    # x1 <= 5300, x2 <= 4500, ...
    m.addConstrs((x[i] <= demand[i] for i in products), name=""demand"")
    
    # Product monthly quota constraints
    # x1 <= 11000, x2 <= 9900, ...
    m.addConstrs((x[i] <= quota[i] for i in products), name=""quota"")
    
    # Minimum batch constraints
    # x1 >= 20*y1, x2 >= 20*y2, ...
    m.addConstrs((x[i] >= min_batch[i] * y[i] for i in products), name=""min_batch"")
    
    # Linking constraints (activation)
    # x1 <= 5300*y1, x2 <= 4500*y2, ...
    # (Note: These values match the 'demand' dictionary)
    m.addConstrs((x[i] <= demand[i] * y[i] for i in products), name=""linking"")
    
    # 7. Solve
    m.optimize()
    
    # 8. Print results
    if m.status == gp.GRB.OPTIMAL:
        print(f""Optimal total value/cost: {m.objVal:.2f}"")
        print(""--- Production Plan ---"")
        for i in products:
            if y[i].X > 0.5: # Check if line is active
                print(f""Product {i}:"")
                print(f""  Status: ACTIVE (y{i} = {y[i].X:.0f})"")
                print(f""  Production: {x[i].X:.0f} (100kg units)"")
            else:
                print(f""Product {i}:"")
                print(f""  Status: INACTIVE (y{i} = {y[i].X:.0f})"")
                print(f""  Production: {x[i].X:.0f} (100kg units)"")
                
    else:
        print(f""No optimal solution found. Status: {m.status}"")

except KeyError as e:
    print(f""Data Error: A required column was not found. {e}"", file=sys.stderr)
except pd.errors.EmptyDataError as e:
    print(f""Data Error: CSV file is empty or unreadable. {e}"", file=sys.stderr)
except Exception as e:
    print(f""An unexpected error occurred: {e}"", file=sys.stderr)",,Others with CSV
"A factory plans to produce two products (A and B) using three limited resources: steel, iron, and machine hours. The resource consumption per unit of product and profit margins are shown in production_data.csv. Determine the optimal production quantities to maximize total profit while respecting resource constraints.",Large_Scale_Or_Files/Other_example/model2/production_data.csv,"#### Decision Variables
- $x_1$: Quantity of Product A to produce
- $x_2$: Quantity of Product B to produce

#### Objective Function
Maximize total profit: 
$\quad \quad \max \ 80x_1 + 125x_2$

#### Constraints
**1. Steel Constraint** 
$\quad \quad 8x_1 + 5x_2 \leq 3500$ 

**2. Iron Constraint** 
$\quad \quad 6x_1 + 4x_2 \leq 1800$ 

**3. Machine Hours Constraint** 
$\quad \quad 4x_1 + 5x_2 \leq 2800$ 

**4. Non-negativity** 
$\quad \quad x_1 \geq 0, x_2 \geq 0$","import gurobipy as gp
import pandas as pd
import numpy as np
import sys
import re

# Helper function to find columns robustly
# (Not used in this static model, but included as part of the template)
def find_col(df, pattern):
    for col in df.columns:
        if re.search(pattern, col, re.IGNORECASE):
            return col
    raise KeyError(f""Could not find a column matching pattern '{{pattern}}'"")

try:
    # 1. Load data
    # (This step is skipped as all parameters are hard-coded
    # in the mathematical model provided.)
    data_path = '{dataset_address}' # Not used

    # 2. Prepare data structures
    # (Skipped as all coefficients are used directly in the model)

    # 3. Build Gurobi model
    m = gp.Model('ProductionProfit')
    
    # 4. Define variables
    # x1: Quantity of Product A to produce
    # x2: Quantity of Product B to produce
    # Variables are continuous and non-negative by default (lb=0.0)
    x1 = m.addVar(name=""x1"")
    x2 = m.addVar(name=""x2"")
    
    # 5. Set objective
    # Maximize total profit: 80*x1 + 125*x2
    m.setObjective(80 * x1 + 125 * x2, gp.GRB.MAXIMIZE)

    # 6. Add constraints
    
    # 1. Steel Constraint
    # 8*x1 + 5*x2 <= 3500
    m.addConstr(8 * x1 + 5 * x2 <= 3500, name=""Steel"")
    
    # 2. Iron Constraint
    # 6*x1 + 4*x2 <= 1800
    m.addConstr(6 * x1 + 4 * x2 <= 1800, name=""Iron"")
    
    # 3. Machine Hours Constraint
    # 4*x1 + 5*x2 <= 2800
    m.addConstr(4 * x1 + 5 * x2 <= 2800, name=""MachineHours"")
    
    # 4. Non-negativity (x1 >= 0, x2 >= 0)
    # This is handled by default as the default lower bound (lb) for addVar is 0.0
    
    # 7. Solve
    m.optimize()
    
    # 8. Print results
    if m.status == gp.GRB.OPTIMAL:
        print(f""Optimal total value/cost: {m.objVal:.2f}"")
        print(""--- Optimal Production Plan ---"")
        print(f""Product A (x1): {x1.X:.2f} units"")
        print(f""Product B (x2): {x2.X:.2f} units"")
    
    else:
        print(f""No optimal solution found. Status: {m.status}"")

except KeyError as e:
    print(f""Data Error: A required column was not found. {e}"", file=sys.stderr)
except pd.errors.EmptyDataError as e:
    print(f""Data Error: CSV file is empty or unreadable. {e}"", file=sys.stderr)
except Exception as e:
    print(f""An unexpected error occurred: {e}"", file=sys.stderr)",,Others with CSV
"A specialty chemical factory produces three premium products (A, B, C) by blending three raw materials (1, 2, 3). The factory supplies custom formulations to high-end manufacturers:

Product A is a precision industrial lubricant requiring _50% Material 1 and _25% Material 2
Product B is an aerospace-grade adhesive requiring _25% Material 1 and _50% Material 2
Product C is a general-purpose compound with no material restrictions
Raw material costs and availability are in raw_materials.csv, while product specifications and selling prices are in products.csv. Determine the optimal blending plan to maximize daily profit.","Large_Scale_Or_Files/Other_example/model3/products.csv
Large_Scale_Or_Files/Other_example/model3/raw_materials.csv","#### Decision Variables
- $x_{ij}$: kg of material $j$ used in product $i$ 
$i \in \{\text{A}, \text{B}, \text{C}\}, j \in \{1,2,3\}$

#### Objective Function
Maximize profit: 
$\quad \quad \max \ 60(x_{A1} + x_{A2} + x_{A3}) + 70(x_{B1} + x_{B2} + x_{B3}) + 60(x_{C1} + x_{C2} + x_{C3})$
$\quad \quad - 65(x_{A1} + x_{B1} + x_{C1}) - 25(x_{A2} + x_{B2} + x_{C2}) - 35(x_{A3} + x_{B3} + x_{C3})$

#### Constraints
**1. Material Availability** 
$\quad \quad x_{A1} + x_{B1} + x_{C1} \leq 100$ 
$\quad \quad x_{A2} + x_{B2} + x_{C2} \leq 100$ 
$\quad \quad x_{A3} + x_{B3} + x_{C3} \leq 60$ 

**2. Product A Specifications** 
$\quad \quad x_{A1} \geq 0.5(x_{A1} + x_{A2} + x_{A3})$ 
$\quad \quad x_{A2} \leq 0.25(x_{A1} + x_{A2} + x_{A3})$ 

**3. Product B Specifications** 
$\quad \quad x_{B1} \geq 0.25(x_{B1} + x_{B2} + x_{B3})$ 
$\quad \quad x_{B2} \leq 0.5(x_{B1} + x_{B2} + x_{B3})$ 

**4. Non-negativity** 
$\quad \quad x_{ij} \geq 0 \quad \forall i,j$","import gurobipy as gp
import pandas as pd
import numpy as np
import sys
import re

# Helper function to find columns robustly
# (Not used in this static model, but included as part of the template)
def find_col(df, pattern):
    for col in df.columns:
        if re.search(pattern, col, re.IGNORECASE):
            return col
    raise KeyError(f""Could not find a column matching pattern '{{pattern}}'"")

try:
    # 1. Load data
    # (This step is skipped as all parameters are hard-coded
    # in the mathematical model provided.)
    data_path = '{dataset_address}' # Not used

    # 2. Prepare data structures
    # (Based on the static values from the problem description)
    products = ['A', 'B', 'C']
    materials = [1, 2, 3] # Using integers for j={1,2,3}
    
    # Selling price per kg for each product
    selling_price = {'A': 60, 'B': 70, 'C': 60}
    
    # Cost per kg for each material
    material_cost = {1: 65, 2: 25, 3: 35}
    
    # Availability in kg for each material
    availability = {1: 100, 2: 100, 3: 60}

    # 3. Build Gurobi model
    m = gp.Model('MaterialBlending')
    
    # 4. Define variables
    # x[i,j]: kg of material j used in product i
    # (Default is continuous and non-negative, which matches x_ij >= 0)
    x = m.addVars(products, materials, name=""x"")
    
    # 5. Set objective
    # Maximize (Total Revenue) - (Total Cost)
    
    # Helper expressions for total amount of each product
    total_product = {
        i: gp.quicksum(x[i, j] for j in materials) for i in products
    }
    
    # Helper expressions for total amount of each material
    total_material = {
        j: gp.quicksum(x[i, j] for i in products) for j in materials
    }
    
    # Total Revenue = sum(price[i] * total_product[i])
    total_revenue = gp.quicksum(
        selling_price[i] * total_product[i] for i in products
    )
    
    # Total Cost = sum(cost[j] * total_material[j])
    total_cost = gp.quicksum(
        material_cost[j] * total_material[j] for j in materials
    )
    
    m.setObjective(total_revenue - total_cost, gp.GRB.MAXIMIZE)

    # 6. Add constraints
    
    # 1. Material Availability
    # x_A1 + x_B1 + x_C1 <= 100  (j=1)
    # x_A2 + x_B2 + x_C2 <= 100  (j=2)
    # x_A3 + x_B3 + x_C3 <= 60   (j=3)
    m.addConstrs(
        (total_material[j] <= availability[j] for j in materials), 
        name=""Material_Availability""
    )
    
    # 2. Product A Specifications
    # x_A1 >= 0.5 * (total product A)
    m.addConstr(
        x['A', 1] >= 0.5 * total_product['A'], 
        name=""ProdA_Spec1""
    )
    # x_A2 <= 0.25 * (total product A)
    m.addConstr(
        x['A', 2] <= 0.25 * total_product['A'], 
        name=""ProdA_Spec2""
    )
    
    # 3. Product B Specifications
    # x_B1 >= 0.25 * (total product B)
    m.addConstr(
        x['B', 1] >= 0.25 * total_product['B'], 
        name=""ProdB_Spec1""
    )
    # x_B2 <= 0.5 * (total product B)
    m.addConstr(
        x['B', 2] <= 0.5 * total_product['B'], 
        name=""ProdB_Spec2""
    )
    
    # 4. Non-negativity (x_ij >= 0)
    # This is handled by default in m.addVars
    
    # 7. Solve
    m.optimize()
    
    # 8. Print results
    if m.status == gp.GRB.OPTIMAL:
        print(f""Optimal total value/cost: {m.objVal:.2f}"")
        
        print(""\n--- Total Production (kg) ---"")
        for i in products:
            total_prod_kg = total_product[i].getValue()
            if total_prod_kg > 1e-6:
                print(f""Product {i}: {total_prod_kg:.2f} kg"")

        print(""\n--- Material Usage (kg) ---"")
        for i in products:
            for j in materials:
                if x[i, j].X > 1e-6: # Only print non-zero usage
                    print(f""  Product {i} uses Material {j}: {x[i, j].X:.2f} kg"")
                    
        print(""\n--- Total Material Used (kg) ---"")
        for j in materials:
            total_mat_kg = total_material[j].getValue()
            if total_mat_kg > 1e-6:
                print(f""Material {j}: {total_mat_kg:.2f} kg (Available: {availability[j]})"")
                
    else:
        print(f""No optimal solution found. Status: {m.status}"")

except KeyError as e:
    print(f""Data Error: A required column was not found. {e}"", file=sys.stderr)
except pd.errors.EmptyDataError as e:
    print(f""Data Error: CSV file is empty or unreadable. {e}"", file=sys.stderr)
except Exception as e:
    print(f""An unexpected error occurred: {e}"", file=sys.stderr)",,Others with CSV
"A closed economic system consists of three sectors: Coal, Power, and Steel. The input-output table in input_output_table.csv shows the distribution of each sector's output to the other sectors as proportions of total output. Determine equilibrium prices (if steel is 10000) for each sector such that the value of each sector's total output equals the value of all inputs it receives from other sectors.",Large_Scale_Or_Files/Other_example/model7/input_output_table.csv,"#### Decision Variables
- $x_1$: Price of Coal sector output (monetary units)
- $x_2$: Price of Power sector output (monetary units)
- $x_3$: Price of Steel sector output (monetary units)

#### Constraints
**1. Coal Sector Balance** 
$\quad \quad x_1 - 0.4x_2 - 0.6x_3 = 0$ 

**2. Power Sector Balance** 
$\quad \quad -0.6x_1 + 0.9x_2 - 0.2x_3 = 0$ 

**3. Steel Sector Balance** 
$\quad \quad -0.4x_1 - 0.5x_2 + 0.8x_3 = 0$ 

**4. Assumption Constraint** 
$\quad \quad x_3 = 10000$ 

**5. Non-negativity** 
$\quad \quad x_1 \geq 0, x_2 \geq 0, x_3 \geq 0$","import gurobipy as gp
import pandas as pd
import numpy as np
import sys
import re

# Helper function to find columns robustly
# (Not used in this static model, but included as part of the template)
def find_col(df, pattern):
    for col in df.columns:
        if re.search(pattern, col, re.IGNORECASE):
            return col
    raise KeyError(f""Could not find a column matching pattern '{{pattern}}'"")

try:
    # 1. Load data
    # (This step is skipped as all parameters are hard-coded
    # in the mathematical model provided.)
    data_path = '{dataset_address}' # Not used

    # 2. Prepare data structures
    # (Skipped as all coefficients are used directly in the model)

    # 3. Build Gurobi model
    m = gp.Model('Leontief_Price_Model')
    
    # 4. Define variables
    # x1: Price of Coal sector output
    # x2: Price of Power sector output
    # x3: Price of Steel sector output
    # (Default is continuous and non-negative, lb=0.0)
    x1 = m.addVar(name=""Price_Coal"")
    x2 = m.addVar(name=""Price_Power"")
    x3 = m.addVar(name=""Price_Steel"")
    
    # 5. Set objective
    # This is a feasibility problem (solving a system of equations),
    # not an optimization problem (no max/min).
    # We set a dummy objective of 0.
    m.setObjective(0.0, gp.GRB.MINIMIZE)

    # 6. Add constraints
    
    # 1. Coal Sector Balance
    # x1 - 0.4*x2 - 0.6*x3 = 0
    m.addConstr(x1 - 0.4*x2 - 0.6*x3 == 0, name=""Coal_Balance"")
    
    # 2. Power Sector Balance
    # -0.6*x1 + 0.9*x2 - 0.2*x3 = 0
    m.addConstr(-0.6*x1 + 0.9*x2 - 0.2*x3 == 0, name=""Power_Balance"")
    
    # 3. Steel Sector Balance
    # -0.4*x1 - 0.5*x2 + 0.8*x3 = 0
    m.addConstr(-0.4*x1 - 0.5*x2 + 0.8*x3 == 0, name=""Steel_Balance"")
    
    # 4. Assumption Constraint
    # x3 = 10000
    m.addConstr(x3 == 10000, name=""Assumption"")
    
    # 5. Non-negativity (x1, x2, x3 >= 0)
    # This is handled by default as the default lower bound (lb) for addVar is 0.0
    
    # 7. Solve
    m.optimize()
    
    # 8. Print results
    if m.status == gp.GRB.OPTIMAL:
        print(f""Feasible solution found (Objective: {m.objVal:.2f})"")
        print(""--- Equilibrium Prices ---"")
        print(f""Price Coal (x1): {x1.X:.2f}"")
        print(f""Price Power (x2): {x2.X:.2f}"")
        print(f""Price Steel (x3): {x3.X:.2f}"")
    
    else:
        print(f""No feasible solution found. Status: {m.status}"")

except KeyError as e:
    print(f""Data Error: A required column was not found. {e}"", file=sys.stderr)
except pd.errors.EmptyDataError as e:
    print(f""Data Error: CSV file is empty or unreadable. {e}"", file=sys.stderr)
except Exception as e:
    print(f""An unexpected error occurred: {e}"", file=sys.stderr)",,Others with CSV
"A financial institution wants to form a revenue-maximizing portfolio by investing in a selection of 10 structured financial products (e.g., CDOs, CLOs, MBS, etc.). Each product provides a specific expected revenue per unit invested, involves exposure to various risk factors (market, credit, interest rate, etc.), and is subject to upper limits on allocation in ProductCharacteristics_IndividualCaps.csv. The portfolio must satisfy regulatory risk exposure limits for 10 types of risk in RiskFactorLimits.csv, adhere to product-specific allocation caps, and meet a minimum investment guideline in each risk factor.

Your task:
Maximize expected portfolio revenue while satisfying the diversification/risk constraints and allocation bounds.","Large_Scale_Or_Files/Other_example/16/ProductCharacteristics_IndividualCaps.csv
Large_Scale_Or_Files/Other_example/16/RiskFactorLimits.csv","Let $\mathbf{x} = [x_1,x_2,\ldots,x_{10}]^\top$ be the vector of investment amounts (in million dollars). 
Let each constraint coefficient vector be $\mathbf{m}, \mathbf{c}, \mathbf{i}, \mathbf{f}, \mathbf{l}, \mathbf{r}, \mathbf{e}, \mathbf{v}, \mathbf{g}$ as defined below.

---

**Objective:**
$$
\text{Maximize} \quad Z = \mathbf{p} \cdot \mathbf{x} = \sum_{i=1}^{10} p_i x_i
$$
where $\mathbf{p} = [73,76,65,70,68,75,67,74,69,72]$.

---

**Subject to:**

**Total invested:**
$$
\sum_{i=1}^{10} x_i \leq 35
$$

**Box constraints:**
$$
\mathbf{0} \leq \mathbf{x} \leq \mathbf{u}
$$
where $\mathbf{u} = [12,8,10,9,7,11,8,10,9,12]$.

---

**Risk factor limits (all written as vector dot products):**

- Market Risk:
$$
\mathbf{m} \cdot \mathbf{x} \leq 42
$$
where $\mathbf{m} = [5.1,6.0,3.8,5.3,4.8,6.7,4.0,5.8,4.7,5.6]$

- Credit Risk:
$$
\mathbf{c} \cdot \mathbf{x} \leq 50
$$
where $\mathbf{c} = [6.2,7.1,5.7,6.4,6.1,6.5,5.8,6.3,6.0,6.6]$

- Interest Rate Risk:
$$
\mathbf{i} \cdot \mathbf{x} \leq 29
$$
where $\mathbf{i} = [3.4,3.8,2.9,3.2,3.1,4.1,3.0,3.7,3.3,3.5]$

- FX Risk:
$$
\mathbf{f} \cdot \mathbf{x} \leq 39
$$
where $\mathbf{f} = [4.2,4.6,3.4,4.8,4.0,5.1,3.7,4.9,4.1,4.5]$

- Liquidity Risk:
$$
\mathbf{l} \cdot \mathbf{x} \leq 25
$$
where $\mathbf{l} = [2.8,2.6,2.4,3.3,2.9,3.7,2.5,3.0,2.8,2.7]$

- IR Risk:
$$
\mathbf{r} \cdot \mathbf{x} \leq 49
$$
where $\mathbf{r} = [5.9,4.8,6.2,5.1,4.9,6.3,5.6,6.1,5.2,5.4]$

- Equity Risk:
$$
\mathbf{e} \cdot \mathbf{x} \leq 25
$$
where $\mathbf{e} = [2.7,2.5,2.2,2.6,2.3,3.0,2.4,2.9,2.7,2.8]$

- Volatility:
$$
\mathbf{v} \cdot \mathbf{x} \leq 36
$$
where $\mathbf{v} = [4.5,5.1,3.9,4.8,4.4,5.4,4.0,5.0,4.3,4.7]$

- Regulatory Risk:
$$
\mathbf{g} \cdot \mathbf{x} \leq 27
$$
where $\mathbf{g} = [2.2,3.0,2.7,2.5,2.4,3.3,2.6,3.2,2.3,2.8]$

---

**Domain:**
$$
x_i \geq 0 \quad \text{for all } i = 1, \ldots, 10
$$","import gurobipy as gp
import pandas as pd
import numpy as np
import sys
import re

# Helper function to find columns robustly
# (Not used in this static model, but included as part of the template)
def find_col(df, pattern):
    for col in df.columns:
        if re.search(pattern, col, re.IGNORECASE):
            return col
    raise KeyError(f""Could not find a column matching pattern '{{pattern}}'"")

try:
    # 1. Load data
    # (This step is skipped as all parameters are hard-coded
    # in the mathematical model provided.)
    data_path = '{dataset_address}' # Not used

    # 2. Prepare data structures
    # (Based on the static values from the problem description)
    
    # Define the 10 assets
    assets = range(1, 11)
    
    # p: Profit vector
    p_list = [73, 76, 65, 70, 68, 75, 67, 74, 69, 72]
    p = dict(zip(assets, p_list))
    
    # u: Upper bound (box) constraints
    u_list = [12, 8, 10, 9, 7, 11, 8, 10, 9, 12]
    u = dict(zip(assets, u_list))
    
    # Total investment limit
    total_investment_limit = 35

    # Risk factor data: (coefficient_list, limit)
    risk_data = {
        ""Market"": ([5.1, 6.0, 3.8, 5.3, 4.8, 6.7, 4.0, 5.8, 4.7, 5.6], 42),
        ""Credit"": ([6.2, 7.1, 5.7, 6.4, 6.1, 6.5, 5.8, 6.3, 6.0, 6.6], 50),
        ""Interest"": ([3.4, 3.8, 2.9, 3.2, 3.1, 4.1, 3.0, 3.7, 3.3, 3.5], 29),
        ""FX"": ([4.2, 4.6, 3.4, 4.8, 4.0, 5.1, 3.7, 4.9, 4.1, 4.5], 39),
        ""Liquidity"": ([2.8, 2.6, 2.4, 3.3, 2.9, 3.7, 2.5, 3.0, 2.8, 2.7], 25),
        ""IR_Risk_r"": ([5.9, 4.8, 6.2, 5.1, 4.9, 6.3, 5.6, 6.1, 5.2, 5.4], 49),
        ""Equity"": ([2.7, 2.5, 2.2, 2.6, 2.3, 3.0, 2.4, 2.9, 2.7, 2.8], 25),
        ""Volatility"": ([4.5, 5.1, 3.9, 4.8, 4.4, 5.4, 4.0, 5.0, 4.3, 4.7], 36),
        ""Regulatory"": ([2.2, 3.0, 2.7, 2.5, 2.4, 3.3, 2.6, 3.2, 2.3, 2.8], 27)
    }
    
    # Convert lists to dictionaries keyed by asset
    risk_factors = {}
    risk_limits = {}
    for name, (coeffs_list, limit) in risk_data.items():
        risk_factors[name] = dict(zip(assets, coeffs_list))
        risk_limits[name] = limit

    # 3. Build Gurobi model
    m = gp.Model('PortfolioOptimization')
    
    # 4. Define variables
    # x[i]: amount (in million $) invested in asset i
    # Domain: 0 <= x[i] <= u[i]
    x = m.addVars(assets, ub=u, name=""investment"")
    
    # 5. Set objective
    # Maximize total profit
    m.setObjective(x.prod(p), gp.GRB.MAXIMIZE)

    # 6. Add constraints
    
    # Total invested:
    m.addConstr(x.sum() <= total_investment_limit, name=""Total_Investment"")
    
    # Box constraints (0 <= x <= u) were set during variable definition
    
    # Risk factor limits:
    for name, coeffs in risk_factors.items():
        m.addConstr(
            x.prod(coeffs) <= risk_limits[name], 
            name=f""Risk_{name}""
        )
    
    # 7. Solve
    m.optimize()
    
    # 8. Print results
    if m.status == gp.GRB.OPTIMAL:
        print(f""Optimal total value/cost: {m.objVal:.2f}"")
        print(""\n--- Optimal Investment Allocation (million $) ---"")
        
        total_invested = 0
        for i in assets:
            if x[i].X > 1e-6: # Only print non-zero investments
                print(f""  Investment {i:2}: {x[i].X:5.2f} (Upper bound: {u[i]})"")
                total_invested += x[i].X
                
        print(""-------------------------------------------------"")
        print(f""Total Invested: {total_invested:5.2f} / {total_investment_limit}"")
        
    else:
        print(f""No optimal solution found. Status: {m.status}"")

except KeyError as e:
    print(f""Data Error: A required column was not found. {e}"", file=sys.stderr)
except pd.errors.EmptyDataError as e:
    print(f""Data Error: CSV file is empty or unreadable. {e}"", file=sys.stderr)
except Exception as e:
    print(f""An unexpected error occurred: {e}"", file=sys.stderr)
",,Others with CSV
"A bank is planning its loan allocation strategy across 7 different industry sectors (S1, S2, S3, S4, S5, S6, S7). Within each of these sectors, the bank can provide loans across up to 6 loan types, labeled L1 through L6 (for example: Short-Term, Medium-Term, Long-Term, Consumer, SME, and Real Estate).

The bank has the following data, organized in three separate CSV tables:

ProjectedInterestIncome.csv:
Each cell represents the expected interest income earned per million dollars invested in a given combination of sector and loan type (sector *loan type).

RiskWeight.csv:
Each cell shows the estimated risk weight associated with lending one million dollars in the corresponding combination of sector and loan type.
(Risk weights reflect factors such as the financial health of the sector, characteristics of the loan type, and current macroeconomic trends.)

LendingAllocationCaps.csv:
Each cell indicates the maximum allowable allocation (in millions of dollars) that can be lent in each combination of industry sector and loan type.

The bank wants to determine a lending allocation plan across the sectors and loan types to maximize the total expected interest income while:
Do not exceeding the per-loan-type allocation (per sector) caps;
Total risk-weighted exposure must stay below a regulatory cap: Total risk-weighted exposure cap: $14.0$;
Minimum lending requirement: The total lending across all sectors and loan types must be at least $30 million;
All allocations must be in integer millions.","Large_Scale_Or_Files/Other_example/18/ProjectedInterestIncome.csv
Large_Scale_Or_Files/Other_example/18/RiskWeight.csv
Large_Scale_Or_Files/Other_example/18/LendingAllocationCaps.csv","### 1. Interest Rates Matrix $\boldsymbol{A} = [a_{ij}]$ (income per million lent)
$$
\mathbf{A} =
\begin{bmatrix}
46 & 38 & 41 & 43 & 40 & 37 & 45 \\
44 & 39 & 43 & 41 & 39 & 38 & 41 \\
47 & 36 & 40 & 45 & 42 & 34 & 43 \\
42 & 40 & 41 & 42 & 43 & 39 & 44 \\
48 & 38 & 38 & 44 & 43 & 37 & 46 \\
46 & 37 & 42 & 41 & 41 & 35 & 45
\end{bmatrix}
$$

---

### 2. Risk Coefficients Matrix $\boldsymbol{R} = [r_{ij}]$ (risk per million lent)
$$
\mathbf{R} =
\begin{bmatrix}
0.13 & 0.12 & 0.17 & 0.10 & 0.14 & 0.13 & 0.18 \\
0.11 & 0.12 & 0.16 & 0.13 & 0.13 & 0.11 & 0.17 \\
0.15 & 0.13 & 0.19 & 0.13 & 0.15 & 0.14 & 0.18 \\
0.12 & 0.15 & 0.15 & 0.12 & 0.13 & 0.13 & 0.15 \\
0.18 & 0.13 & 0.21 & 0.16 & 0.19 & 0.13 & 0.20 \\
0.14 & 0.15 & 0.14 & 0.15 & 0.15 & 0.12 & 0.14
\end{bmatrix}
$$

---

### 3. Lending Caps Matrix $\boldsymbol{C} = [c_{ij}]$ (max million per lender-sector)
$$
\mathbf{C} =
\begin{bmatrix}
7 & 5 & 4 & 8 & 6 & 5 & 7 \\
6 & 7 & 5 & 7 & 6 & 4 & 5 \\
5 & 6 & 6 & 6 & 5 & 5 & 4 \\
8 & 5 & 7 & 8 & 6 & 6 & 5 \\
7 & 6 & 6 & 7 & 7 & 4 & 5 \\
6 & 5 & 5 & 7 & 5 & 7 & 6
\end{bmatrix}
$$

---

### 4. **Global Constraints**
- Max Total Risk: $R_{\max} = 14.0$
- Min Total Lending: $L_{\min} = 30$

---

#### **Decision Variables**
- $x_{ij} \in \mathbb{Z}_+$ : Amount lent (in million) by lender $i$ to sector $j$.

---

#### **Objective Function**

Maximize total interest income:
$$
\max \sum_{i=1}^{6} \sum_{j=1}^{7} a_{ij}\, x_{ij}
$$

---

#### **Constraints**

1. **Lending Capacity** (per lender-sector pair):
$$
x_{ij} \leq c_{ij} \qquad \forall i \in \{1,\dots,6\},\ j \in \{1,\dots,7\}
$$

2. **Total Risk Limit**:
$$
\sum_{i=1}^{6} \sum_{j=1}^{7} r_{ij} x_{ij} \leq 14.0
$$

3. **Minimum Total Lending**:
$$
\sum_{i=1}^{6} \sum_{j=1}^{7} x_{ij} \geq 30
$$

4. **Non-negativity and Integrality:**
$$
x_{ij} \geq 0,\quad x_{ij} \in \mathbb{Z} \qquad \forall i, j
$$

---

### **Key Properties**
- **Total Variables:** $6 \times 7 = 42$
- **Total Constraints:**
- 42 capacity constraints (one per $x_{ij}$)
- 1 risk constraint
- 1 lending constraint
- **Total:** 44 constraints
- **Solution Type:** Integer Linear Programming (ILP)","import gurobipy as gp
import pandas as pd
import numpy as np
import sys
import re

# Helper function to find columns robustly
# (Not used in this static model, but included as part of the template)
def find_col(df, pattern):
    for col in df.columns:
        if re.search(pattern, col, re.IGNORECASE):
            return col
    raise KeyError(f""Could not find a column matching pattern '{{pattern}}'"")

try:
    # 1. Load data
    # (This step is skipped as all parameters are hard-coded
    # in the mathematical model provided.)
    data_path = '{dataset_address}' # Not used

    # 2. Prepare data structures
    # (Based on the static values from the problem description)
    
    lenders = range(1, 7) # i = 1 to 6
    sectors = range(1, 8) # j = 1 to 7

    # 1. Interest Rates Matrix A = [a_ij]
    a_data = [
        [46, 38, 41, 43, 40, 37, 45],
        [44, 39, 43, 41, 39, 38, 41],
        [47, 36, 40, 45, 42, 34, 43],
        [42, 40, 41, 42, 43, 39, 44],
        [48, 38, 38, 44, 43, 37, 46],
        [46, 37, 42, 41, 41, 35, 45]
    ]

    # 2. Risk Coefficients Matrix R = [r_ij]
    r_data = [
        [0.13, 0.12, 0.17, 0.10, 0.14, 0.13, 0.18],
        [0.11, 0.12, 0.16, 0.13, 0.13, 0.11, 0.17],
        [0.15, 0.13, 0.19, 0.13, 0.15, 0.14, 0.18],
        [0.12, 0.15, 0.15, 0.12, 0.13, 0.13, 0.15],
        [0.18, 0.13, 0.21, 0.16, 0.19, 0.13, 0.20],
        [0.14, 0.15, 0.14, 0.15, 0.15, 0.12, 0.14]
    ]

    # 3. Lending Caps Matrix C = [c_ij]
    c_data = [
        [7, 5, 4, 8, 6, 5, 7],
        [6, 7, 5, 7, 6, 4, 5],
        [5, 6, 6, 6, 5, 5, 4],
        [8, 5, 7, 8, 6, 6, 5],
        [7, 6, 6, 7, 7, 4, 5],
        [6, 5, 5, 7, 5, 7, 6]
    ]

    # Convert lists of lists to Gurobi tupledicts for easy access
    # We use (i, j) as keys, matching the model's 1-based indexing
    A, R, C = {}, {}, {}
    for i in lenders:
        for j in sectors:
            # Adjust for 0-based list indexing
            A[i, j] = a_data[i-1][j-1]
            R[i, j] = r_data[i-1][j-1]
            C[i, j] = c_data[i-1][j-1]

    # 4. Global Constraints
    R_max = 14.0
    L_min = 30

    # 3. Build Gurobi model
    m = gp.Model('Lending_Allocation_ILP')
    
    # 4. Define variables
    # x[i,j]: Amount (in million) by lender i to sector j
    # We can set the upper bound (c_ij) and variable type (integer)
    # directly in the variable creation.
    # This automatically handles Constraint 1 (Lending Capacity)
    # and Constraint 4 (Non-negativity and Integrality).
    x = m.addVars(lenders, sectors, vtype=gp.GRB.INTEGER, ub=C, name=""x"")
    
    # 5. Set objective
    # Maximize total interest income: sum(a_ij * x_ij)
    m.setObjective(x.prod(A), gp.GRB.MAXIMIZE)

    # 6. Add constraints
    
    # 1. Lending Capacity (x_ij <= c_ij)
    # (Handled by setting 'ub=C' in m.addVars)
    
    # 2. Total Risk Limit: sum(r_ij * x_ij) <= 14.0
    m.addConstr(x.prod(R) <= R_max, name=""Total_Risk_Limit"")
    
    # 3. Minimum Total Lending: sum(x_ij) >= 30
    m.addConstr(x.sum() >= L_min, name=""Min_Total_Lending"")
    
    # 4. Non-negativity and Integrality (x_ij >= 0, integer)
    # (Handled by 'vtype=gp.GRB.INTEGER' in m.addVars, 
    #  which implies non-negative integers)
    
    # 7. Solve
    m.optimize()
    
    # 8. Print results
    if m.status == gp.GRB.OPTIMAL:
        print(f""Optimal total value/cost: {m.objVal:.2f} (Total Interest Income)"")
        
        print(""\n--- Optimal Lending Allocation (millions) ---"")
        total_lending = 0
        for i in lenders:
            for j in sectors:
                if x[i, j].X > 0.5: # Print only non-zero integer allocations
                    print(f""  Lender {i} to Sector {j}: {x[i, j].X:.0f} (Cap: {C[i, j]})"")
                    total_lending += x[i, j].X
        
        print(""\n--- Summary ---"")
        total_risk = x.prod(R).getValue()
        print(f""Total Lending: {total_lending:.0f} (Min required: {L_min})"")
        print(f""Total Risk:    {total_risk:.2f} (Max allowed: {R_max})"")

    else:
        print(f""No optimal solution found. Status: {m.status}"")

except KeyError as e:
    print(f""Data Error: A required column was not found. {e}"", file=sys.stderr)
except pd.errors.EmptyDataError as e:
    print(f""Data Error: CSV file is empty or unreadable. {e}"", file=sys.stderr)
except Exception as e:
    print(f""An unexpected error occurred: {e}"", file=sys.stderr)
",,Others with CSV
"A product can be processed on any one of the four devices A, B, C, or D. The setup completion cost for each device when it is activated, the unit cost of production for the product, and the maximum processing capacity for each device are known as shown in 6.csv. How can the total cost be minimized to produce 2000 units of the product? Try to establish a mathematical model.",Large_Scale_Or_Files/Other_example/6.csv,"## Mathematical Model

**Minimize**

$$
1000\, y_A + 20\, x_A 
+ 920\, y_B + 24\, x_B 
+ 800\, y_C + 16\, x_C 
+ 700\, y_D + 28\, x_D
$$

**subject to**

$$
x_A + x_B + x_C + x_D = 2000
$$

$$
x_A \leq 900\, y_A
$$

$$
x_B \leq 1000\, y_B
$$

$$
x_C \leq 1200\, y_C
$$

$$
x_D \leq 1600\, y_D
$$

**where**

$$
x_A, x_B, x_C, x_D \geq 0 \quad (\text{continuous})
$$

$$
y_A, y_B, y_C, y_D \in \{0,1\} \quad (\text{binary})
$$","import gurobipy as gp
import pandas as pd
import numpy as np
import sys
import re

# Helper function to find columns robustly
# (Not used in this static model, but included as part of the template)
def find_col(df, pattern):
    for col in df.columns:
        if re.search(pattern, col, re.IGNORECASE):
            return col
    raise KeyError(f""Could not find a column matching pattern '{{pattern}}'"")

try:
    # 1. Load data
    # (This step is skipped as all parameters are hard-coded
    # in the mathematical model provided.)
    data_path = '{dataset_address}' # Not used

    # 2. Prepare data structures
    # (Based on the static values from the problem description)
    
    # Define the four options/plants
    plants = ['A', 'B', 'C', 'D']
    
    # Fixed costs (for y variables)
    fixed_cost = {'A': 1000, 'B': 920, 'C': 800, 'D': 700}
    
    # Variable costs (for x variables)
    var_cost = {'A': 20, 'B': 24, 'C': 16, 'D': 28}
    
    # Capacities (for linking constraints)
    capacity = {'A': 900, 'B': 1000, 'C': 1200, 'D': 1600}
    
    # Total demand to be met
    total_demand = 2000

    # 3. Build Gurobi model
    m = gp.Model('FixedCostProduction')
    
    # 4. Define variables
    # x[p]: amount produced at plant p (continuous, non-negative)
    x = m.addVars(plants, name=""x"")
    
    # y[p]: whether plant p is activated (binary)
    y = m.addVars(plants, vtype=gp.GRB.BINARY, name=""y"")
    
    # 5. Set objective
    # Minimize total cost = (fixed cost * y) + (variable cost * x)
    m.setObjective(
        y.prod(fixed_cost) + x.prod(var_cost), 
        gp.GRB.MINIMIZE
    )

    # 6. Add constraints
    
    # Total demand must be met
    # x_A + x_B + x_C + x_D = 2000
    m.addConstr(x.sum() == total_demand, name=""Total_Demand"")
    
    # Linking constraints (can only produce if plant is active)
    # x_p <= capacity[p] * y_p
    m.addConstrs(
        (x[p] <= capacity[p] * y[p] for p in plants), 
        name=""Linking""
    )
    
    # Non-negativity of x is handled by default (lb=0.0)
    
    # 7. Solve
    m.optimize()
    
    # 8. Print results
    if m.status == gp.GRB.OPTIMAL:
        print(f""Optimal total value/cost: {m.objVal:.2f}"")
        print(""\n--- Optimal Production Plan ---"")
        
        for p in plants:
            if y[p].X > 0.5: # Check if plant is activated
                print(f""  Plant {p}: Activated (y=1)"")
                print(f""    - Production (x): {x[p].X:.2f} (Capacity: {capacity[p]})"")
            else:
                print(f""  Plant {p}: Not Activated (y=0)"")

    else:
        print(f""No optimal solution found. Status: {m.status}"")

except KeyError as e:
    print(f""Data Error: A required column was not found. {e}"", file=sys.stderr)
except pd.errors.EmptyDataError as e:
    print(f""Data Error: CSV file is empty or unreadable. {e}"", file=sys.stderr)
except Exception as e:
    print(f""An unexpected error occurred: {e}"", file=sys.stderr)
",,Others with CSV
"A product consists of three components, which are produced by four workshops. The total number of production hours available for each workshop is limited. 31.csv shows the productivity of the three components. The objective is to determine how many hours should be allocated to each component in each workshop in order to maximize the number of completed products. Represent this problem as a linear programming problem.",Large_Scale_Or_Files/Other_example/31.csv,"## Mathematical Model

**Maximize**

$$
N
$$

**subject to**

$$
x_{A1} + x_{A2} + x_{A3} \leq 100 
\quad (\text{workshop A hours})
$$

$$
x_{B1} + x_{B2} + x_{B3} \leq 150 
\quad (\text{workshop B hours})
$$

$$
x_{C1} + x_{C2} + x_{C3} \leq 80 
\quad (\text{workshop C hours})
$$

$$
x_{D1} + x_{D2} + x_{D3} \leq 200 
\quad (\text{workshop D hours})
$$

**component requirements**

$$
10\, x_{A1} + 15\, x_{B1} + 20\, x_{C1} + 10\, x_{D1} \geq N 
\quad (\text{component 1})
$$

$$
15\, x_{A2} + 10\, x_{B2} + 5\, x_{C2} + 15\, x_{D2} \geq N 
\quad (\text{component 2})
$$

$$
5\, x_{A3} + 5\, x_{B3} + 10\, x_{C3} + 20\, x_{D3} \geq N 
\quad (\text{component 3})
$$

**where**

$$
x_{wc} \geq 0 
\quad \text{for all } 
w \in \{A,B,C,D\},\, 
c \in \{1,2,3\}
$$

$$
N \geq 0 
\quad (\text{number of completed products})
$$","import gurobipy as gp
import pandas as pd
import numpy as np
import sys
import re

# Helper function to find columns robustly
# (Not used in this static model, but included as part of the template)
def find_col(df, pattern):
    for col in df.columns:
        if re.search(pattern, col, re.IGNORECASE):
            return col
    raise KeyError(f""Could not find a column matching pattern '{{pattern}}'"")

try:
    # 1. Load data
    # (This step is skipped as all parameters are hard-coded
    # in the mathematical model provided.)
    data_path = '{dataset_address}' # Not used

    # 2. Prepare data structures
    # (Based on the static values from the problem description)
    
    # Define workshops and components
    workshops = ['A', 'B', 'C', 'D']
    components = ['1', '2', '3']
    
    # Workshop capacity (hours)
    capacity = {'A': 100, 'B': 150, 'C': 80, 'D': 200}
    
    # Production rates (component units per hour)
    # This matrix maps (workshop, component) -> rate
    rates = {
        ('A', '1'): 10, ('B', '1'): 15, ('C', '1'): 20, ('D', '1'): 10,
        ('A', '2'): 15, ('B', '2'): 10, ('C', '2'):  5, ('D', '2'): 15,
        ('A', '3'):  5, ('B', '3'):  5, ('C', '3'): 10, ('D', '3'): 20
    }

    # 3. Build Gurobi model
    m = gp.Model('MaximizeProducts')
    
    # 4. Define variables
    
    # N: number of completed products (continuous, non-negative)
    N = m.addVar(name=""N"")
    
    # x[w,c]: hours allocated in workshop w to produce component c
    # (continuous, non-negative)
    x = m.addVars(workshops, components, name=""x"")
    
    # 5. Set objective
    # Maximize N
    m.setObjective(N, gp.GRB.MAXIMIZE)

    # 6. Add constraints
    
    # Workshop hours constraints
    # sum(x_wc for c in components) <= capacity_w
    for w in workshops:
        m.addConstr(
            x.sum(w, '*') <= capacity[w], 
            name=f""Hours_{w}""
        )
    
    # Component requirements constraints
    # sum(rates_wc * x_wc for w in workshops) >= N
    for c in components:
        m.addConstr(
            gp.quicksum(rates[w, c] * x[w, c] for w in workshops) >= N,
            name=f""Requirement_{c}""
        )
        
    # Non-negativity of N and x is handled by default (lb=0.0)
    
    # 7. Solve
    m.optimize()
    
    # 8. Print results
    if m.status == gp.GRB.OPTIMAL:
        print(f""Optimal total value/cost: {m.objVal:.2f} (Max Products N)"")
        
        print(""\n--- Optimal Hour Allocation (x_wc) ---"")
        for w in workshops:
            total_hours = 0
            for c in components:
                if x[w, c].X > 1e-6: # Print non-zero allocations
                    print(f""  Workshop {w} -> Component {c}: {x[w, c].X:6.2f} hours"")
                    total_hours += x[w, c].X
            print(f""  >> Total hours for Workshop {w}: {total_hours:6.2f} / {capacity[w]}"")
            
    else:
        print(f""No optimal solution found. Status: {m.status}"")

except KeyError as e:
    print(f""Data Error: A required column was not found. {e}"", file=sys.stderr)
except pd.errors.EmptyDataError as e:
    print(f""Data Error: CSV file is empty or unreadable. {e}"", file=sys.stderr)
except Exception as e:
    print(f""An unexpected error occurred: {e}"", file=sys.stderr)
",,Others with CSV
"A factory needs to rent a warehouse to store materials for the next 4 months. The required warehouse area for each month is listed in 39-1.csv.The longer the rental contract period, the greater the discount on warehouse rental fees. The specific data is listed in 39-2.csv.

The warehouse rental contract can be processed at the beginning of each month, and each contract specifies the rental area and period. Therefore, the factory can rent a contract on any month, and each time, they can sign one contract or multiple contracts with different rental areas and rental periods. The overall goal is to minimize the rental fees paid. Try to establish a linear programming mathematical model based on the above requirements.","Large_Scale_Or_Files/Other_example/39-1.csv
Large_Scale_Or_Files/Other_example/39-2.csv","## Mathematical Model

**Minimize**

$$
28\, (x_{1,1} + x_{2,1} + x_{3,1} + x_{4,1})
+ 45\, (x_{1,2} + x_{2,2} + x_{3,2})
+ 60\, (x_{1,3} + x_{2,3})
+ 73\, x_{1,4}
$$

**subject to**

$$
x_{1,1} + x_{1,2} + x_{1,3} + x_{1,4} \geq 1500 
\quad (\text{month 1})
$$

$$
x_{1,2} + x_{1,3} + x_{1,4} + x_{2,1} + x_{2,2} + x_{2,3} \geq 1000 
\quad (\text{month 2})
$$

$$
x_{1,3} + x_{1,4} + x_{2,2} + x_{2,3} + x_{3,1} + x_{3,2} \geq 2000 
\quad (\text{month 3})
$$

$$
x_{1,4} + x_{2,3} + x_{3,2} + x_{4,1} \geq 1200 
\quad (\text{month 4})
$$

**where**

$$
x_{s,p} \geq 0 
\quad \text{for } s \in \{1,2,3,4\},\ p \in \{1,2,3,4\}
\quad \text{only if } s+p-1 \leq 4
$$","import gurobipy as gp
import pandas as pd
import numpy as np
import sys
import re

# Helper function to find columns robustly
# (Not used in this specific problem as data is hard-coded)
def find_col(df, pattern):
    for col in df.columns:
        if re.search(pattern, col, re.IGNORECASE):
            return col
    raise KeyError(f""Could not find a column matching pattern '{{pattern}}'"")

try:
    # 1. Load data
    # (Data for this problem is given in the mathematical model,
    # so we do not need to load any files.)
    # data_path = '{dataset_address}' 
    
    # 2. Prepare data structures
    # Costs per unit for a contract of duration p
    costs = {
        1: 28,  # p=1
        2: 45,  # p=2
        3: 60,  # p=3
        4: 73   # p=4
    }
    
    # Monthly demand
    demands = {
        1: 1500, # month 1
        2: 1000, # month 2
        3: 2000, # month 3
        4: 1200  # month 4
    }
    
    demand_months = [1, 2, 3, 4]
    
    # 3. Build Gurobi model
    m = gp.Model('CashFlowPlanning')
    
    # 4. Define variables
    # x[s,p] = amount purchased in start month 's' for duration 'p'
    # We first find all valid (s, p) pairs based on the condition s+p-1 <= 4
    var_indices = []
    for s in [1, 2, 3, 4]: # Start month
        for p in [1, 2, 3, 4]: # Duration
            if s + p - 1 <= 4:
                var_indices.append((s, p))
                
    # var_indices will be:
    # [(1,1), (1,2), (1,3), (1,4), 
    #  (2,1), (2,2), (2,3), 
    #  (3,1), (3,2), 
    #  (4,1)]
    
    x = m.addVars(var_indices, vtype=gp.GRB.CONTINUOUS, name=""x"")
    
    # 5. Set objective
    # Minimize total cost: sum(cost[p] * x[s,p]) for all valid (s,p)
    m.setObjective(
        gp.quicksum(costs[p] * x[s, p] for s, p in var_indices),
        gp.GRB.MINIMIZE
    )

    # 6. Add constraints
    # Add one constraint for each month's demand
    for month in demand_months:
        # The sum of all active contracts for a given 'month'
        # A contract (s,p) is active in 'month' if:
        # start_month <= month <= end_month
        # s <= month AND month <= s + p - 1
        
        active_contracts = gp.quicksum(
            x[s, p] for s, p in var_indices
            if s <= month and month <= (s + p - 1)
        )
        
        m.addConstr(active_contracts >= demands[month], name=f""demand_month_{month}"")
    
    # 7. Solve
    m.optimize()
    
    # 8. Print results
    if m.status == gp.GRB.OPTIMAL:
        print(f""Optimal total value/cost: {m.objVal:.2f}"")
        print(""--- Optimal Purchase Plan ---"")
        for s, p in var_indices:
            if x[s, p].X > 1e-6: # Print non-zero values
                print(f""  Month {s}, Duration {p} (x[{s},{p}]): {x[s, p].X:.2f} units"")
    else:
        print(f""No optimal solution found. Status: {m.status}"")

except KeyError as e:
    print(f""Data Error: A required column was not found. {e}"", file=sys.stderr)
except pd.errors.EmptyDataError as e:
    print(f""Data Error: CSV file is empty or unreadable. {e}"", file=sys.stderr)
except Exception as e:
    print(f""An unexpected error occurred: {e}"", file=sys.stderr)
",,Others with CSV
"A supermarket needs to replenish its daily stock of flour and rice to meet customer demand while minimizing total procurement costs. The exact required quantities are 100 kg of flour and 80 kg of rice. No more, no less. There are two existing suppliers (Supplier 1 and 2) that must be used, though order quantities from them can vary. Additionally, two new suppliers (Supplier 3 and 4) are available, but selecting any new supplier incurs a fixed management fee of 50 RMB per supplier (e.g., choosing Supplier 3 adds 50 RMB, while selecting both adds 100 RMB). If a new supplier is not chosen, no orders can be placed with them. The total cost consists of procurement expenses from all selected suppliers plus the fixed fees for any new suppliers. The objective is to minimize total cost as the primary goal, with a secondary preference for using fewer new suppliers. Detailed information for each supply is in 'supplier_details.csv'.",Large_Scale_Or_Files/Other_example/model10/supplier_details.csv,"**Objective Function:**
$$
\min Z = 200\,x_{1} + 250\,x_{2} + 380\,x_{3} + 350\,x_{4} + 50\,y_{3} + 50\,y_{4}
$$

**Constraints:**

Flour demand constraint:
$$
30\,x_{1} + 20\,x_{2} + 40\,x_{3} + 10\,x_{4} = 100
$$

Rice demand constraint:
$$
20\,x_{1} + 30\,x_{2} + 10\,x_{3} + 40\,x_{4} = 80
$$

Supplier usage constraints for new suppliers:
$$
x_{3} \leq M\,y_{3}
$$
$$
x_{4} \leq M\,y_{4}
$$

Mandatory usage of existing suppliers:
$$
x_{1} \geq 0
$$
$$
x_{2} \geq 0
$$

Non-negativity for new suppliers:
$$
x_{3} \geq 0
$$
$$
x_{4} \geq 0
$$

Binary variables for new supplier selection:
$$
y_{3} \in \{0,1\}
$$
$$
y_{4} \in \{0,1\}
$$

Where $M$ is a sufficiently large constant (e.g., $M = 100$).

**Decision Variables:**
$$
x_{i} \geq 0, \quad i = 1,2,3,4
$$
$$
y_{j} \in \{0,1\}, \quad j = 3,4
$$

**Retrieved Information**

- Supplier 1: New Supplier, Flour per batch = 30, Rice per batch = 20, Price per batch = 200, Administrative fee = 1
- Supplier 2: New Supplier, Flour per batch = 20, Rice per batch = 30, Price per batch = 250, Administrative fee = 1
- Supplier 3: Previous Supplier, Flour per batch = 40, Rice per batch = 10, Price per batch = 380, Administrative fee = 50
- Supplier 4: Previous Supplier, Flour per batch = 10, Rice per batch = 40, Price per batch = 350, Administrative fee = 50

- Demand: Flour = 100 kg, Rice = 80 kg

- $x_{i}$: Number of batches ordered from supplier $i$ ($i=1,2,3,4$)
- $y_{j}$: Binary variable indicating if new supplier $j$ ($j=3,4$) is selected (1 if selected, 0 otherwise)","import gurobipy as gp
import pandas as pd
import numpy as np
import sys
import re

# Helper function to find columns robustly
# (Not used in this static model, but included as part of the template)
def find_col(df, pattern):
    for col in df.columns:
        if re.search(pattern, col, re.IGNORECASE):
            return col
    raise KeyError(f""Could not find a column matching pattern '{{pattern}}'"")

try:
    # 1. Load data
    # (This step is skipped as all parameters are hard-coded
    # in the mathematical model provided.)
    data_path = '{dataset_address}' # Not used

    # 2. Prepare data structures
    # (Based on the static values from the problem description)
    
    # All suppliers
    suppliers = [1, 2, 3, 4]
    
    # Suppliers with a fixed cost (binary variable)
    # Based on your model, these are 3 and 4
    new_suppliers = [3, 4]
    
    # Variable cost per batch (for x_i)
    var_cost = {1: 200, 2: 250, 3: 380, 4: 350}
    
    # Fixed administrative cost (for y_j)
    fixed_cost = {3: 50, 4: 50}
    
    # Coefficients for constraints
    flour_coeff = {1: 30, 2: 20, 3: 40, 4: 10}
    rice_coeff = {1: 20, 2: 30, 3: 10, 4: 40}
    
    # Demands
    flour_demand = 100
    rice_demand = 80
    
    # Big-M value (as given in your description)
    M = 100

    # 3. Build Gurobi model
    m = gp.Model('SupplierSelection')
    
    # 4. Define variables
    
    # x[i]: Number of batches ordered from supplier i (continuous)
    x = m.addVars(suppliers, name=""x"") # Default lb=0.0
    
    # y[j]: Binary variable to select supplier j
    y = m.addVars(new_suppliers, vtype=gp.GRB.BINARY, name=""y"")
    
    # 5. Set objective
    # Minimize total cost = variable costs + fixed costs
    
    total_variable_cost = gp.quicksum(var_cost[i] * x[i] for i in suppliers)
    total_fixed_cost = gp.quicksum(fixed_cost[j] * y[j] for j in new_suppliers)
    
    m.setObjective(total_variable_cost + total_fixed_cost, gp.GRB.MINIMIZE)

    # 6. Add constraints
    
    # Flour demand constraint
    m.addConstr(
        gp.quicksum(flour_coeff[i] * x[i] for i in suppliers) == flour_demand,
        name=""Flour_Demand""
    )
    
    # Rice demand constraint
    m.addConstr(
        gp.quicksum(rice_coeff[i] * x[i] for i in suppliers) == rice_demand,
        name=""Rice_Demand""
    )
    
    # Supplier usage constraints (Linking constraints)
    # x_j <= M * y_j  (for j = 3, 4)
    for j in new_suppliers:
        m.addConstr(x[j] <= M * y[j], name=f""Link_{j}"")
    
    # Non-negativity for x_i is handled by default (lb=0.0)
    
    # 7. Solve
    m.optimize()
    
    # 8. Print results
    if m.status == gp.GRB.OPTIMAL:
        print(f""Optimal total value/cost: {m.objVal:.2f}"")
        
        print(""\n--- Optimal Order Plan (Batches) ---"")
        for i in suppliers:
            if x[i].X > 1e-6: # Print non-zero orders
                print(f""  Supplier {i}: {x[i].X:8.2f} batches"")

        print(""\n--- Supplier Activation ---"")
        for j in new_suppliers:
            if y[j].X > 0.5:
                print(f""  Supplier {j}: ACTIVATED (y=1)"")
            else:
                print(f""  Supplier {j}: NOT Activated (y=0)"")

    else:
        print(f""No optimal solution found. Status: {m.status}"")

except KeyError as e:
    print(f""Data Error: A required column was not found. {e}"", file=sys.stderr)
except pd.errors.EmptyDataError as e:
    print(f""Data Error: CSV file is empty or unreadable. {e}"", file=sys.stderr)
except Exception as e:
    print(f""An unexpected error occurred: {e}"", file=sys.stderr)
",,Others with CSV
